{
  "language": "Solidity",
  "sources": {
    "contracts/BridgedToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract BridgedToken is\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    OwnableUpgradeable\n{\n    function initialize(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external initializer {\n        __ERC20_init(name, symbol);\n        __ERC20Burnable_init();\n        // decimals(decimals);\n        // _setupDecimals(decimals);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/TokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/RLPReader.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BridgedToken.sol\";\n\ncontract TokenRegistry {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event TokenMapReq(\n        address indexed tokenReq,\n        uint8 indexed decimals,\n        string name,\n        string symbol\n    );\n\n    event TokenMapAck(address indexed tokenReq, address indexed tokenAck);\n\n    bytes32 constant TokenMapReqEventSig =\n        keccak256(\"TokenMapReq(address,uint8,string,string)\");\n    bytes32 constant TokenMapAckEventSig =\n        keccak256(\"TokenMapAck(address,address)\");\n\n    IERC20Upgradeable[] public TxTokens; // thisSide locked ERC20 list\n    BridgedToken[] public RxTokens; // bridged token list, keys of\n\n    // TX means token issued in this chain, and cross to another chain\n    mapping(address => address) public TxMapped; // thisSide locked => otherSide mint\n    mapping(address => IERC20Upgradeable) public TxMappedInv; // inverse KV\n\n    // RX means token issued in another chain, and cross to this chain.\n    mapping(address => BridgedToken) public RxMapped; // otherSide locked => thisSide mint\n    mapping(address => address) public RxMappedInv; // inverse KV\n\n    function totalBridgedTokens() external view returns (uint256, uint256) {\n        return (TxTokens.length, RxTokens.length);\n    }\n\n    function issueTokenMapReq(ERC20Upgradeable thisSideToken)\n        external\n    {\n        require(\n            TxMapped[address(thisSideToken)] == address(0),\n            \"token is already mapped\"\n        );\n        ERC20Upgradeable tokenDetail = thisSideToken;\n        emit TokenMapReq(\n            address(thisSideToken),\n            tokenDetail.decimals(),\n            tokenDetail.name(),\n            tokenDetail.symbol()\n        );\n    }\n\n    function onTokenMapReqEvent(bytes32[] memory topics, bytes memory data)\n        internal\n    {\n        // event TokenMapReq(address indexed tokenReq, uint256 decimals, string name, string symbol);\n        address tokenReq = address(uint160(uint256(topics[1])));\n        require(\n            address(RxMapped[tokenReq]) == address(0),\n            \"bridge already exist\"\n        );\n        uint8 decimals = uint8(uint256(topics[2]));\n        (string memory name, string memory symbol) = abi.decode(\n            data,\n            (string, string)\n        );\n        bytes32 salt = bytes32(uint256(uint160(tokenReq)));\n        BridgedToken mintAddress = new BridgedToken{salt: salt}();\n        mintAddress.initialize(\n            name,\n            symbol,\n            decimals\n        );\n        RxMappedInv[address(mintAddress)] = tokenReq;\n        RxMapped[tokenReq] = mintAddress;\n        RxTokens.push(mintAddress);\n        emit TokenMapAck(tokenReq, address(mintAddress));\n    }\n\n    function onTokenMapAckEvent(bytes32[] memory topics)\n        internal\n    {\n        address tokenReq = address(uint160(uint256(topics[1])));\n        address tokenAck = address(uint160(uint256(topics[2])));\n        require(\n            TxMapped[tokenReq] == address(0),\n            \"missing mapping to acknowledge\"\n        );\n        TxMapped[tokenReq] = tokenAck;\n        TxMappedInv[tokenAck] = IERC20Upgradeable(tokenReq);\n        TxTokens.push(IERC20Upgradeable(tokenReq));\n    }\n}\n"
    },
    "contracts/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n *   Updated by Tuan Vu (tuanvd@gmail.com)\n * Please reach out with any questions or concerns\n */\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self)\n        internal\n        pure\n        returns (Iterator memory)\n    {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item)\n        internal\n        pure\n        returns (RLPItem[] memory)\n    {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n        // return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n        // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function toRlpBytesHash(RLPItem memory item)\n        internal\n        pure\n        returns (bytes32 _hash)\n    {\n        require(item.len > 0);\n        uint256 len = item.len;\n        uint256 ptr = item.memPtr;\n        assembly {\n            _hash := keccak256(ptr, len)\n        }\n    }\n\n    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n        return _bytesToBytes32(toBytes(item), 0);\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr);\n            // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (\n            byte0 < STRING_LONG_START ||\n            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n        ) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        if (len > 0) {\n            if (len >= WORD_SIZE) {\n                len = WORD_SIZE - 1;\n            }\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n     * @param convert a memory bytes to byte32\n     */\n    function _bytesToBytes32(bytes memory b, uint256 offset)\n        private\n        pure\n        returns (bytes32)\n    {\n        bytes32 out;\n\n        for (uint256 i = 0; i < 32; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function safeGetItemByIndex(RLPItem memory item, uint256 idx)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint256 endPtr = item.memPtr + item.len;\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n\n        require(memPtr + dataLen <= endPtr, \"RLP item overflow\");\n        return RLPItem(dataLen, memPtr);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/HarmonyLightClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./HarmonyParser.sol\";\nimport \"./lib/SafeCast.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n// import \"openzeppelin-solidity/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n// import \"openzeppelin-solidity/contracts/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract HarmonyLightClient is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable\n{\n    using SafeCast for *;\n    using SafeMathUpgradeable for uint256;\n\n    struct BlockHeader {\n        bytes32 parentHash;\n        bytes32 stateRoot;\n        bytes32 transactionsRoot;\n        bytes32 receiptsRoot;\n        uint256 number;\n        uint256 epoch;\n        uint256 shard;\n        uint256 time;\n        bytes32 mmrRoot;\n        bytes32 hash;\n    }\n\n    event CheckPoint(\n        bytes32 stateRoot,\n        bytes32 transactionsRoot,\n        bytes32 receiptsRoot,\n        uint256 number,\n        uint256 epoch,\n        uint256 shard,\n        uint256 time,\n        bytes32 mmrRoot,\n        bytes32 hash\n    );\n\n    BlockHeader firstBlock;\n    BlockHeader lastCheckPointBlock;\n\n    // epoch to block numbers, as there could be >=1 mmr entries per epoch\n    mapping(uint256 => uint256[]) epochCheckPointBlockNumbers;\n\n    // block number to BlockHeader\n    mapping(uint256 => BlockHeader) checkPointBlocks;\n\n    mapping(uint256 => mapping(bytes32 => bool)) epochMmrRoots;\n\n    uint8 relayerThreshold;\n\n    event RelayerThresholdChanged(uint256 newThreshold);\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n    // number of the oldest epoch that stored, we use this to prune the expired epochs from state\n    uint256 public oldestEpochStored;\n    uint256 private constant BLOCK_EXPIRED = 30 days;\n    uint256 private constant MAX_PRUNE_ONCE = 2;\n\n\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"sender doesn't have admin role\");\n        _;\n    }\n\n    modifier onlyRelayers() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"sender doesn't have relayer role\");\n        _;\n    }\n\n    function adminPauseLightClient() external onlyAdmin {\n        _pause();\n    }\n\n    function adminUnpauseLightClient() external onlyAdmin {\n        _unpause();\n    }\n\n    function renounceAdmin(address newAdmin) external onlyAdmin {\n        require(msg.sender != newAdmin, 'cannot renounce self');\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function adminChangeRelayerThreshold(uint256 newThreshold) external onlyAdmin {\n        relayerThreshold = newThreshold.toUint8();\n        emit RelayerThresholdChanged(newThreshold);\n    }\n\n    function adminAddRelayer(address relayerAddress) external onlyAdmin {\n        require(!hasRole(RELAYER_ROLE, relayerAddress), \"addr already has relayer role!\");\n        grantRole(RELAYER_ROLE, relayerAddress);\n        emit RelayerAdded(relayerAddress);\n    }\n\n    function adminRemoveRelayer(address relayerAddress) external onlyAdmin {\n        require(hasRole(RELAYER_ROLE, relayerAddress), \"addr doesn't have relayer role!\");\n        revokeRole(RELAYER_ROLE, relayerAddress);\n        emit RelayerRemoved(relayerAddress);\n    }\n\n    function initialize(\n        bytes memory firstRlpHeader,\n        address[] memory initialRelayers,\n        uint8 initialRelayerThreshold\n    ) external initializer {\n        HarmonyParser.BlockHeader memory header = HarmonyParser.toBlockHeader(\n            firstRlpHeader\n        );\n        \n        firstBlock.parentHash = header.parentHash;\n        firstBlock.stateRoot = header.stateRoot;\n        firstBlock.transactionsRoot = header.transactionsRoot;\n        firstBlock.receiptsRoot = header.receiptsRoot;\n        firstBlock.number = header.number;\n        firstBlock.epoch = header.epoch;\n        firstBlock.shard = header.shardID;\n        firstBlock.time = header.timestamp;\n        firstBlock.mmrRoot = HarmonyParser.toBytes32(header.mmrRoot);\n        firstBlock.hash = header.hash;\n        oldestEpochStored = header.epoch;\n        \n        epochCheckPointBlockNumbers[header.epoch].push(header.number);\n        checkPointBlocks[header.number] = firstBlock;\n\n        epochMmrRoots[header.epoch][firstBlock.mmrRoot] = true;\n\n        relayerThreshold = initialRelayerThreshold;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        for (uint256 i; i < initialRelayers.length; i++) {\n            grantRole(RELAYER_ROLE, initialRelayers[i]);\n        }\n\n    }\n\n    function _deleteEpoch(uint256 epochNo) private {\n        uint256[] storage blockNumbers = epochCheckPointBlockNumbers[epochNo];\n        for(uint256 i = 0; i < blockNumbers.length; i++) {\n            uint256 blockNo = blockNumbers[i];\n            bytes32 mmrRoot = checkPointBlocks[blockNo].mmrRoot;\n            delete checkPointBlocks[blockNo];\n            delete epochMmrRoots[epochNo][mmrRoot];\n        }\n        delete epochCheckPointBlockNumbers[epochNo];\n    }\n \n    function _pruneEpochs(uint256 pruneTime) private {\n        uint256 epochCur = oldestEpochStored;\n        if (epochCheckPointBlockNumbers[epochCur].length == 0) return;\n        for(uint256 i = 0; i < MAX_PRUNE_ONCE; i++) {\n            uint256 epochNo = epochCur++;\n            uint256[] storage epochBlockNumbers = epochCheckPointBlockNumbers[epochCur];\n            uint256 epochBlockCount = epochBlockNumbers.length;\n            if (epochBlockCount == 0) break;\n            if (checkPointBlocks[epochBlockNumbers[epochBlockCount-1]].time > pruneTime) break;\n            _deleteEpoch(epochNo);\n        }\n        if(epochCur > oldestEpochStored) oldestEpochStored = epochCur;\n    }\n\n    function submitCheckpoint(bytes memory rlpHeader) external onlyRelayers whenNotPaused {\n        _pruneEpochs(block.timestamp - BLOCK_EXPIRED);\n        HarmonyParser.BlockHeader memory header = HarmonyParser.toBlockHeader(\n            rlpHeader\n        );\n\n        BlockHeader memory checkPointBlock;\n        \n        checkPointBlock.parentHash = header.parentHash;\n        checkPointBlock.stateRoot = header.stateRoot;\n        checkPointBlock.transactionsRoot = header.transactionsRoot;\n        checkPointBlock.receiptsRoot = header.receiptsRoot;\n        checkPointBlock.number = header.number;\n        checkPointBlock.epoch = header.epoch;\n        checkPointBlock.shard = header.shardID;\n        checkPointBlock.time = header.timestamp;\n        checkPointBlock.mmrRoot = HarmonyParser.toBytes32(header.mmrRoot);\n        checkPointBlock.hash = header.hash;\n        \n        epochCheckPointBlockNumbers[header.epoch].push(header.number);\n        checkPointBlocks[header.number] = checkPointBlock;\n\n        epochMmrRoots[header.epoch][checkPointBlock.mmrRoot] = true;\n        emit CheckPoint(\n            checkPointBlock.stateRoot,\n            checkPointBlock.transactionsRoot,\n            checkPointBlock.receiptsRoot,\n            checkPointBlock.number,\n            checkPointBlock.epoch,\n            checkPointBlock.shard,\n            checkPointBlock.time,\n            checkPointBlock.mmrRoot,\n            checkPointBlock.hash\n        );\n    }\n\n    function getLatestCheckPoint(uint256 blockNumber, uint256 epoch)\n        public\n        view\n        returns (BlockHeader memory checkPointBlock)\n    {\n        require(\n            epochCheckPointBlockNumbers[epoch].length > 0,\n            \"no checkpoints for epoch\"\n        );\n        uint256[] memory checkPointBlockNumbers = epochCheckPointBlockNumbers[epoch];\n        uint256 nearest = 0;\n        for (uint256 i = 0; i < checkPointBlockNumbers.length; i++) {\n            uint256 checkPointBlockNumber = checkPointBlockNumbers[i];\n            if (\n                checkPointBlockNumber > blockNumber &&\n                checkPointBlockNumber < nearest\n            ) {\n                nearest = checkPointBlockNumber;\n            }\n        }\n        checkPointBlock = checkPointBlocks[nearest];\n    }\n\n    function isValidCheckPoint(uint256 epoch, bytes32 mmrRoot) public view returns (bool status) {\n        return epochMmrRoots[epoch][mmrRoot];\n    }\n}\n"
    },
    "contracts/HarmonyParser.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/RLPReader.sol\";\nimport \"./lib/RLPEncode.sol\";\n\nlibrary HarmonyParser {\n    using RLPReader for bytes;\n    using RLPReader for uint256;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n\n    using RLPEncode for bytes;\n    using RLPEncode for bytes[];\n\n    struct BlockHeader {\n        bytes32 hash;\n        bytes32 parentHash;\n        address miner;\n        bytes32 stateRoot;\n        bytes32 transactionsRoot;\n        bytes32 receiptsRoot;\n        bytes32 outgoingReceiptsRoot;\n        bytes32 incomingReceiptsRoot;\n        bytes logsBloom;\n        uint256 number;\n        uint256 gasLimit;\n        uint256 gasUsed;\n        uint256 timestamp;\n        bytes extraData;\n        bytes32 mixHash;\n        uint256 viewID;\n        uint256 epoch;\n        uint256 shardID;\n        bytes lastCommitSignature;\n        bytes lastCommitBitmap;\n        bytes vrf;\n        bytes vdf;\n        bytes shardState;\n        bytes crossLink;\n        bytes slashes;\n        bytes mmrRoot;\n    }\n\n    struct Account {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct Transaction {\n        uint256 nonce;\n        uint256 gasPrice;\n        uint256 gas;\n        uint256 shardID;\n        uint256 toShardID;\n        address to;\n        uint256 value;\n        bytes input;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Log {\n        address contractAddress;\n        bytes32[] topics;\n        bytes data;\n    }\n\n    struct TransactionReceipt {\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address from;\n        address to;\n        uint256 gasUsed;\n        uint256 cummulativeGasUsed;\n        address contractAddress;\n        Log[] logs;\n        uint256 status; // root?\n        bytes logsBloom;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct TransactionReceiptTrie {\n        uint8 status;\n        uint256 gasUsed;\n        bytes logsBloom;\n        Log[] logs;\n    }\n\n    function getBlockRlpData(BlockHeader memory header)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        bytes[] memory list = new bytes[](15);\n\n        list[0] = RLPEncode.encodeBytes(abi.encodePacked(header.parentHash));\n        list[1] = RLPEncode.encodeAddress(header.miner);\n        list[2] = RLPEncode.encodeBytes(abi.encodePacked(header.stateRoot));\n        list[3] = RLPEncode.encodeBytes(\n            abi.encodePacked(header.transactionsRoot)\n        );\n        list[4] = RLPEncode.encodeBytes(abi.encodePacked(header.receiptsRoot));\n        list[5] = RLPEncode.encodeBytes(\n            abi.encodePacked(header.outgoingReceiptsRoot)\n        );\n        list[6] = RLPEncode.encodeBytes(\n            abi.encodePacked(header.incomingReceiptsRoot)\n        );\n        list[7] = RLPEncode.encodeBytes(header.logsBloom);\n        list[8] = RLPEncode.encodeUint(header.number);\n        list[9] = RLPEncode.encodeUint(header.gasLimit);\n        list[10] = RLPEncode.encodeUint(header.gasUsed);\n        list[11] = RLPEncode.encodeUint(header.timestamp);\n        list[12] = RLPEncode.encodeBytes(header.extraData);\n        list[13] = RLPEncode.encodeBytes(abi.encodePacked(header.mixHash));\n\n        list[14] = RLPEncode.encodeUint(header.viewID);\n        list[15] = RLPEncode.encodeUint(header.epoch);\n        list[16] = RLPEncode.encodeUint(header.shardID);\n\n        list[17] = RLPEncode.encodeBytes(header.lastCommitSignature);\n        list[18] = RLPEncode.encodeBytes(header.lastCommitBitmap);\n        list[19] = RLPEncode.encodeBytes(header.vrf);\n        list[20] = RLPEncode.encodeBytes(header.vdf);\n\n        list[21] = RLPEncode.encodeBytes(header.shardState);\n        list[22] = RLPEncode.encodeBytes(header.crossLink);\n        list[23] = RLPEncode.encodeBytes(header.slashes);\n        list[24] = RLPEncode.encodeBytes(header.mmrRoot);\n\n        data = RLPEncode.encodeList(list);\n    }\n\n    /**\n     * Parse RLP-encoded block header into BlockHeader data structure\n     *  @param rlpHeader: RLP-encoded block header with data fields order as defined in the BlockHeader struct\n     **/\n    function toBlockHeader(bytes memory rlpHeader)\n        internal\n        pure\n        returns (BlockHeader memory header)\n    {\n        RLPReader.Iterator memory it = rlpHeader.toRlpItem().iterator();\n        // skip two dummy header fields\n        it.next();\n        it.next();\n        it = it.next().iterator();\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) header.parentHash = bytes32(it.next().toUint());\n            else if (idx == 1) header.miner = it.next().toAddress();\n            else if (idx == 2) header.stateRoot = bytes32(it.next().toUint());\n            else if (idx == 3)\n                header.transactionsRoot = bytes32(it.next().toUint());\n            else if (idx == 4)\n                header.receiptsRoot = bytes32(it.next().toUint());\n            else if (idx == 5)\n                header.outgoingReceiptsRoot = bytes32(it.next().toUint());\n            else if (idx == 6)\n                header.incomingReceiptsRoot = bytes32(it.next().toUint());\n            else if (idx == 7) header.logsBloom = it.next().toBytes();\n            else if (idx == 8) header.number = it.next().toUint();\n            else if (idx == 9) header.gasLimit = it.next().toUint();\n            else if (idx == 10) header.gasUsed = it.next().toUint();\n            else if (idx == 11) header.timestamp = it.next().toUint();\n            else if (idx == 12) header.extraData = it.next().toBytes();\n            else if (idx == 13) header.mixHash = bytes32(it.next().toUint());\n            else if (idx == 14) header.viewID = it.next().toUint();\n            else if (idx == 15) header.epoch = it.next().toUint();\n            else if (idx == 16) header.shardID = it.next().toUint();\n            else if (idx == 17)\n                header.lastCommitSignature = it.next().toBytes();\n            else if (idx == 18) header.lastCommitBitmap = it.next().toBytes();\n            else if (idx == 19) header.vrf = it.next().toBytes();\n            else if (idx == 20) header.vdf = it.next().toBytes();\n            else if (idx == 21) header.shardState = it.next().toBytes();\n            else if (idx == 22) header.crossLink = it.next().toBytes();\n            else if (idx == 23) header.slashes = it.next().toBytes();\n            else if (idx == 24) header.mmrRoot = it.next().toBytes();\n            else it.next();\n\n            idx++;\n        }\n        header.hash = keccak256(rlpHeader);\n    }\n\n    function getFirstKey(bytes memory keys) public returns (bytes memory) {\n        RLPReader.Iterator memory it = keys.toRlpItem().iterator();\n        while (it.hasNext()) {\n            bytes memory key = it.next().toBytes();\n            return key;\n        }\n    }\n\n    function calcBlockHeaderHash(bytes memory rlpHeader)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(rlpHeader));\n    }\n\n    function calcBlockSealHash(bytes memory rlpHeader)\n        internal\n        pure\n        returns (uint256)\n    {\n        bytes[] memory rlpFields = new bytes[](13);\n        RLPReader.Iterator memory it = rlpHeader.toRlpItem().iterator();\n        uint256 idx = 0;\n        while (it.hasNext() && idx < 13) {\n            rlpFields[idx] = it.next().toRlpBytes();\n            idx++;\n        }\n\n        bytes memory toSealRlpData = rlpFields.encodeList();\n        return uint256(keccak256(toSealRlpData));\n    }\n\n    function getBlockHash(BlockHeader memory header)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        return keccak256(getBlockRlpData(header));\n    }\n\n    function getLog(Log memory log) internal pure returns (bytes memory data) {\n        bytes[] memory list = new bytes[](3);\n        bytes[] memory topics = new bytes[](log.topics.length);\n\n        for (uint256 i = 0; i < log.topics.length; i++) {\n            topics[i] = RLPEncode.encodeBytes(abi.encodePacked(log.topics[i]));\n        }\n\n        list[0] = RLPEncode.encodeAddress(log.contractAddress);\n        list[1] = RLPEncode.encodeList(topics);\n        list[2] = RLPEncode.encodeBytes(log.data);\n        data = RLPEncode.encodeList(list);\n    }\n\n    function getReceiptRlpData(TransactionReceiptTrie memory receipt)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        bytes[] memory list = new bytes[](4);\n\n        bytes[] memory logs = new bytes[](receipt.logs.length);\n        for (uint256 i = 0; i < receipt.logs.length; i++) {\n            logs[i] = getLog(receipt.logs[i]);\n        }\n\n        list[0] = RLPEncode.encodeUint(receipt.status);\n        list[1] = RLPEncode.encodeUint(receipt.gasUsed);\n        list[2] = RLPEncode.encodeBytes(receipt.logsBloom);\n        list[3] = RLPEncode.encodeList(logs);\n        data = RLPEncode.encodeList(list);\n    }\n\n    function toReceiptLog(bytes memory data)\n        internal\n        pure\n        returns (Log memory log)\n    {\n        RLPReader.Iterator memory it = RLPReader.toRlpItem(data).iterator();\n\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) {\n                log.contractAddress = it.next().toAddress();\n            } else if (idx == 1) {\n                RLPReader.RLPItem[] memory list = it.next().toList();\n                log.topics = new bytes32[](list.length);\n                for (uint256 i = 0; i < list.length; i++) {\n                    bytes32 topic = bytes32(list[i].toUint());\n                    log.topics[i] = topic;\n                }\n            } else if (idx == 2) log.data = it.next().toBytes();\n            else it.next();\n            idx++;\n        }\n    }\n\n    function toReceipt(bytes memory data)\n        internal\n        pure\n        returns (TransactionReceiptTrie memory receipt)\n    {\n        RLPReader.Iterator memory it = RLPReader.toRlpItem(data).iterator();\n\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) receipt.status = uint8(it.next().toUint());\n            else if (idx == 1) receipt.gasUsed = it.next().toUint();\n            else if (idx == 2) receipt.logsBloom = it.next().toBytes();\n            else if (idx == 3) {\n                RLPReader.RLPItem[] memory list = it.next().toList();\n                receipt.logs = new Log[](list.length);\n                for (uint256 i = 0; i < list.length; i++) {\n                    receipt.logs[i] = toReceiptLog(list[i].toRlpBytes());\n                }\n            } else it.next();\n            idx++;\n        }\n    }\n\n    function getTransactionRaw(Transaction memory transaction, uint256 chainId)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        bytes[] memory list = new bytes[](9);\n\n        list[0] = RLPEncode.encodeUint(transaction.nonce);\n        list[1] = RLPEncode.encodeUint(transaction.gasPrice);\n        list[2] = RLPEncode.encodeUint(transaction.gas);\n        list[3] = RLPEncode.encodeUint(transaction.shardID);\n        list[4] = RLPEncode.encodeUint(transaction.toShardID);\n        list[5] = RLPEncode.encodeAddress(transaction.to);\n        list[6] = RLPEncode.encodeUint(transaction.value);\n        list[7] = RLPEncode.encodeBytes(transaction.input);\n        list[8] = RLPEncode.encodeUint(chainId);\n        list[9] = RLPEncode.encodeUint(0);\n        list[10] = RLPEncode.encodeUint(0);\n        data = RLPEncode.encodeList(list);\n    }\n\n    /**\n     * @param rlpTx: RLP-encoded tx with data fields order as defined in the Tx struct\n     **/\n    function toTransaction(bytes memory rlpTx)\n        internal\n        pure\n        returns (Transaction memory transaction)\n    {\n        RLPReader.Iterator memory it = rlpTx.toRlpItem().iterator();\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) transaction.nonce = it.next().toUint();\n            else if (idx == 1) transaction.gasPrice = it.next().toUint();\n            else if (idx == 2) transaction.gas = it.next().toUint();\n            else if (idx == 3) transaction.shardID = it.next().toUint();\n            else if (idx == 4) transaction.toShardID = it.next().toUint();\n            else if (idx == 5) transaction.to = it.next().toAddress();\n            else if (idx == 6) transaction.value = it.next().toUint();\n            else if (idx == 7) transaction.input = it.next().toBytes();\n            else if (idx == 8) transaction.v = uint8(it.next().toUint());\n            else if (idx == 9) transaction.r = it.next().toBytes32();\n            else if (idx == 10) transaction.s = it.next().toBytes32();\n            else it.next();\n            idx++;\n        }\n        return transaction;\n    }\n\n    function toAccount(bytes memory data)\n        internal\n        pure\n        returns (Account memory account)\n    {\n        RLPReader.Iterator memory it = RLPReader.toRlpItem(data).iterator();\n\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) account.nonce = it.next().toUint();\n            else if (idx == 1) account.balance = it.next().toUint();\n            else if (idx == 2)\n                account.storageRoot = toBytes32(it.next().toBytes());\n            else if (idx == 3)\n                account.codeHash = toBytes32(it.next().toBytes());\n            else it.next();\n            idx++;\n        }\n    }\n\n    function toBytes32(bytes memory data)\n        internal\n        pure\n        returns (bytes32 _data)\n    {\n        assembly {\n            _data := mload(add(data, 32))\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary SafeCast {\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value < 2**200, \"value does not fit in 200 bits\");\n        return uint200(value);\n    }\n\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"value does not fit in 128 bits\");\n        return uint128(value);\n    }\n\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value < 2**40, \"value does not fit in 40 bits\");\n        return uint40(value);\n    }\n\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"value does not fit in 8 bits\");\n        return uint8(value);\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/lib/RLPEncode.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n */\nlibrary RLPEncode {\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) <= 128) {\n            encoded = self;\n        } else {\n            encoded = concat(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory list = flatten(self);\n        return concat(encodeLength(list.length, 192), list);\n    }\n\n    /**\n     * @dev RLP encodes a string.\n     * @param self The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeString(string memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return encodeBytes(bytes(self));\n    }\n\n    /**\n     * @dev RLP encodes an address.\n     * @param self The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory inputBytes;\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, self)\n            )\n            mstore(0x40, add(m, 52))\n            inputBytes := m\n        }\n        return encodeBytes(inputBytes);\n    }\n\n    /**\n     * @dev RLP encodes a uint.\n     * @param self The uint to encode.\n     * @return The RLP encoded uint in bytes.\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @dev RLP encodes an int.\n     * @param self The int to encode.\n     * @return The RLP encoded int in bytes.\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @dev RLP encodes a bool.\n     * @param self The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (self ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint256 len, uint256 offset)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen - i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), _x)\n        }\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n        return res;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n\n    /**\n     * @dev Concatenates two bytes.\n     * @notice From: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol.\n     * @param _preBytes First byte string.\n     * @param _postBytes Second byte string.\n     * @return Both byte string combined.\n     */\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            tempBytes := mload(0x40)\n\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            let mc := add(tempBytes, 0x20)\n            let end := add(mc, length)\n\n            for {\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            mc := end\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31)\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/TokenLockerOnEthereum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./HarmonyLightClient.sol\";\nimport \"./lib/MMRVerifier.sol\";\nimport \"./HarmonyProver.sol\";\nimport \"./TokenLocker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract TokenLockerOnEthereum is TokenLocker, OwnableUpgradeable {\n    HarmonyLightClient public lightclient;\n\n    mapping(bytes32 => bool) public spentReceipt;\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function changeLightClient(HarmonyLightClient newClient)\n        external\n        onlyOwner\n    {\n        lightclient = newClient;\n    }\n\n    function bind(address otherSide) external onlyOwner {\n        otherSideBridge = otherSide;\n    }\n\n    function validateAndExecuteProof(\n        HarmonyParser.BlockHeader memory header,\n        MMRVerifier.MMRProof memory mmrProof,\n        HarmonyProver.MerkleProof memory receiptdata\n    ) external {\n        require(lightclient.isValidCheckPoint(header.epoch, mmrProof.root), \"checkpoint validation failed\");\n        bytes32 blockHash = HarmonyParser.getBlockHash(header);\n        bytes32 rootHash = header.receiptsRoot;\n        (bool status, string memory message) = HarmonyProver.verifyHeader(\n            header,\n            mmrProof\n        );\n        require(rootHash == receiptdata.root, \"invalid proof root\");\n        require(status, \"block header could not be verified\");\n        bytes32 receiptHash = keccak256(\n            abi.encodePacked(blockHash, rootHash, receiptdata.paths)\n        );\n        require(spentReceipt[receiptHash] == false, \"double spent!\");\n        spentReceipt[receiptHash] = true;\n        bytes memory receipt = HarmonyProver.verifyReceipt(header, receiptdata);\n        uint256 executedEvents = execute(receipt);\n        require(executedEvents > 0, \"no valid event\");\n    }\n}\n"
    },
    "contracts/lib/MMRVerifier.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @author Wanseob Lim <email@wanseob.com>\n * @title Merkle Mountain Range solidity library\n *\n * @dev The index of this MMR implementation starts from 1 not 0.\n *      And it uses keccak256 for its hash function instead of blake2b\n */\nlibrary MMRVerifier {\n    struct MMRProof {\n        bytes32 root;\n        uint256 width;\n        uint256 index;\n        bytes32[] peaks;\n        bytes32[] siblings;\n    }\n    \n    /**\n     * @dev It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    function inclusionProof(\n        bytes32 root,\n        uint256 width,\n        uint256 index,\n        bytes32 value32,\n        bytes32[] memory peaks,\n        bytes32[] memory siblings\n    ) internal pure returns (bool) {\n        // bytes32 value32;\n\n        // assembly {\n        //     value32 := mload(add(value, 32))\n        // }\n        uint256 size = getSize(width);\n        require(size >= index, \"Index is out of range\");\n        // Check the root equals the peak bagging hash\n        require(\n            root ==\n                // keccak256(\n                //     abi.encodePacked(\n                //         size,\n                //         keccak256(abi.encodePacked(size, peaks))\n                //     )\n                // ),\n                keccak256(\n                    abi.encodePacked(\n                        peaks\n                    )\n                ),\n            \"Invalid root hash from the peaks\"\n        );\n\n        // Find the mountain where the target index belongs to\n        uint256 cursor;\n        bytes32 targetPeak;\n        uint256[] memory peakIndexes = getPeakIndexes(width);\n        for (uint256 i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i]-1 >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i]-1;\n                break;\n            }\n        }\n        require(targetPeak != bytes32(0), \"Target is not found\");\n\n        // Find the path climbing down\n        uint256[] memory path = new uint256[](siblings.length + 1);\n        uint256 left;\n        uint256 right;\n        uint8 height = uint8(siblings.length) + 1;\n        while (height > 0) {\n            // Record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor == index) {\n                // On the leaf node. Stop climbing down\n                break;\n            } else {\n                // On the parent node. Go left or right\n                (left, right) = getChildren(cursor+1);\n                cursor = index > (left-1) ? (right-1) : (left-1);\n                continue;\n            }\n        }\n\n        // Calculate the summit hash climbing up again\n        bytes32 node;\n        while (height < path.length) {\n            // Move cursor\n            cursor = path[height];\n            if (height == 0) {\n                // cursor is on the leaf\n                node = value32;//hashLeaf(cursor, keccak256(value));\n            } else if (cursor - 1 == path[height - 1]) {\n                // cursor is on a parent and a sibling is on the left\n                node = hashBranch(siblings[height - 1], node);\n            } else {\n                // cursor is on a parent and a sibling is on the right\n                node = hashBranch(node, siblings[height - 1]);\n            }\n            // Climb up\n            height++;\n        }\n\n        // Computed hash value of the summit should equal to the target peak hash\n        require(node == targetPeak, \"Hashed peak is invalid\");\n        return true;\n    }\n\n    /**\n     * @dev\n     */\n    function getSize(uint256 width) internal pure returns (uint256) {\n        return (width << 1) - numOfPeaks(width);\n    }\n\n    /**\n     * @dev It returns the hash a parent node with hash(M | Left child | Right child)\n     *      M is the index of the node\n     */\n    function hashBranch(bytes32 left, bytes32 right)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(left, right));\n    }\n\n    /**\n     * @dev it returns the hash of a leaf node with hash(M | DATA )\n     *      M is the index of the node\n     */\n    function hashLeaf(uint256 index, bytes32 dataHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // return keccak256(abi.encodePacked(index, dataHash));\n        return keccak256(abi.encodePacked(dataHash));\n    }\n\n    /**\n     * @dev It returns the height of the highest peak\n     */\n    function mountainHeight(uint256 size) internal pure returns (uint8) {\n        uint8 height = 1;\n        while (uint256(1) << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n\n    /**\n     * @dev It returns the height of the index\n     */\n    function heightAt(uint256 index) internal pure returns (uint8 height) {\n        uint256 reducedIndex = index;\n        uint256 peakIndex;\n        // If an index has a left mountain subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (uint256(1) << height) - 1;\n            height = mountainHeight(reducedIndex);\n            peakIndex = (uint256(1) << height) - 1;\n        }\n        // Index is on the right slope\n        height = height - uint8((peakIndex - reducedIndex));\n    }\n\n    /**\n     * @dev It returns the children when it is a parent node\n     */\n    function getChildren(uint256 index)\n        internal\n        pure\n        returns (uint256 left, uint256 right)\n    {\n        left = index - (uint256(1) << (heightAt(index) - 1));\n        right = index - 1;\n        require(left != right, \"Not a parent\");\n    }\n\n    /**\n     * @dev It returns all peaks of the smallest merkle mountain range tree which includes\n     *      the given index(size)\n     */\n    function getPeakIndexes(uint256 width)\n        internal\n        pure\n        returns (uint256[] memory peakIndexes)\n    {\n        peakIndexes = new uint256[](numOfPeaks(width));\n        uint256 count;\n        uint256 size;\n        for (uint256 i = 255; i > 0; i--) {\n            if (width & (1 << (i - 1)) != 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n            }\n        }\n        require(count == peakIndexes.length, \"Invalid bit calculation\");\n    }\n\n    function numOfPeaks(uint256 width) internal pure returns (uint256 num) {\n        uint256 bits = width;\n        while (bits > 0) {\n            if (bits % 2 == 1) num++;\n            bits = bits >> 1;\n        }\n        return num;\n    }\n}\n"
    },
    "contracts/HarmonyProver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// largely based on\n// https://github.com/loredanacirstea/goldengate/blob/master/contracts/contracts/Prover.sol\n\nimport \"./HarmonyParser.sol\";\nimport \"./HarmonyLightClient.sol\";\nimport \"./lib/MMRVerifier.sol\";\nimport \"./lib/ECVerify.sol\";\nimport \"./lib/MPTValidatorV2.sol\";\n\nlibrary HarmonyProver {\n    using HarmonyProver for MerkleProof;\n\n    struct MerkleProof {\n        bytes32 root;\n        uint256 paths;\n        bytes proof;\n    }\n\n    function verifyTrieProof(MerkleProof memory data)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return MPTValidatorV2.validateProof(data.root, data.paths, data.proof);\n    }\n\n    function verifyHeader(\n        HarmonyParser.BlockHeader memory header,\n        MMRVerifier.MMRProof memory proof\n    ) internal pure returns (bool valid, string memory reason) {\n        bytes32 blockHash = HarmonyParser.getBlockHash(header);\n        if (blockHash != header.hash)\n            return (false, \"Header data or hash invalid\");\n\n        // Check block hash was registered in light client\n        valid = MMRVerifier.inclusionProof(\n            proof.root,\n            proof.width,\n            proof.index,\n            blockHash,\n            proof.peaks,\n            proof.siblings\n        );\n        if (!valid) return (false, \"verifyHeader - invalid proof\");\n\n        return (true, \"\");\n    }\n\n    function verifyTransaction(\n        HarmonyParser.BlockHeader memory header,\n        MerkleProof memory txdata\n    ) internal pure returns (bytes memory serializedTx) {\n        require(header.transactionsRoot == txdata.root, \"verifyTransaction - different trie roots\");\n        return txdata.verifyTrieProof();\n    }\n\n    function verifyReceipt(\n        HarmonyParser.BlockHeader memory header,\n        MerkleProof memory receiptdata\n    ) internal pure returns (bytes memory serializedReceipt) {\n        require(header.receiptsRoot == receiptdata.root, \"verifyReceipt - different trie roots\");\n        return receiptdata.verifyTrieProof();\n    }\n\n    function verifyAccount(\n        HarmonyParser.BlockHeader memory header,\n        MerkleProof memory accountdata\n    ) internal pure returns (bytes memory serializedAccount) {\n        require(header.stateRoot == accountdata.root, \"verifyAccount - different trie roots\");\n        return accountdata.verifyTrieProof();\n    }\n\n    function verifyLog(\n        MerkleProof memory receiptdata,\n        uint256 logIndex\n    ) internal pure returns (bytes memory logdata) {\n        bytes memory serializedReceipt = receiptdata.verifyTrieProof();\n        HarmonyParser.TransactionReceiptTrie memory receipt = HarmonyParser\n            .toReceipt(serializedReceipt);\n        return HarmonyParser.getLog(receipt.logs[logIndex]);\n    }\n\n    function verifyTransactionAndStatus(\n        HarmonyParser.BlockHeader memory header,\n        MerkleProof memory receiptdata\n    ) internal pure returns (bool valid, string memory reason) {}\n\n    function verifyCode(\n        HarmonyParser.BlockHeader memory header,\n        MerkleProof memory accountdata\n    ) internal pure returns (bool valid, string memory reason) {}\n\n    function verifyStorage(\n        MerkleProof memory accountProof,\n        MerkleProof memory storageProof\n    ) internal pure returns (bytes memory data) {\n        HarmonyParser.Account memory account = HarmonyParser.toAccount(\n            accountProof.verifyTrieProof()\n        );\n        require(account.storageRoot == storageProof.root, \"verifyStorage - different trie roots\");\n        return storageProof.verifyTrieProof();\n    }\n\n    function getTransactionSender(\n        bytes memory txdata,\n        uint256 chainId\n    ) internal pure returns (address sender) {\n        HarmonyParser.Transaction memory transaction = HarmonyParser\n            .toTransaction(txdata);\n        bytes memory txraw = HarmonyParser.getTransactionRaw(\n            transaction,\n            chainId\n        );\n\n        bytes32 message_hash = keccak256(txraw);\n        sender = ECVerify.ecverify(\n            message_hash,\n            transaction.v,\n            transaction.r,\n            transaction.s\n        );\n    }\n\n    function getTransactionHash(bytes memory signedTransaction)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        hash = keccak256(signedTransaction);\n    }\n\n    function getBlockHash(HarmonyParser.BlockHeader memory header)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        return keccak256(getBlockRlpData(header));\n    }\n\n    function getBlockRlpData(HarmonyParser.BlockHeader memory header)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        return HarmonyParser.getBlockRlpData(header);\n    }\n\n    function toBlockHeader(bytes memory data)\n        internal\n        pure\n        returns (HarmonyParser.BlockHeader memory header)\n    {\n        return HarmonyParser.toBlockHeader(data);\n    }\n\n    function getLog(HarmonyParser.Log memory log)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        return HarmonyParser.getLog(log);\n    }\n\n    function getReceiptRlpData(\n        HarmonyParser.TransactionReceiptTrie memory receipt\n    ) internal pure returns (bytes memory data) {\n        return HarmonyParser.getReceiptRlpData(receipt);\n    }\n\n    function toReceiptLog(bytes memory data)\n        internal\n        pure\n        returns (HarmonyParser.Log memory log)\n    {\n        return HarmonyParser.toReceiptLog(data);\n    }\n\n    function toReceipt(bytes memory data)\n        internal\n        pure\n        returns (HarmonyParser.TransactionReceiptTrie memory receipt)\n    {\n        return HarmonyParser.toReceipt(data);\n    }\n\n    function toTransaction(bytes memory data)\n        internal\n        pure\n        returns (HarmonyParser.Transaction memory transaction)\n    {\n        return HarmonyParser.toTransaction(data);\n    }\n\n    function toAccount(bytes memory data)\n        internal\n        pure\n        returns (HarmonyParser.Account memory account)\n    {\n        return HarmonyParser.toAccount(data);\n    }\n}\n"
    },
    "contracts/TokenLocker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/RLPReader.sol\";\nimport \"./BridgedToken.sol\";\nimport \"./TokenRegistry.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\n// import \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n// import \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract TokenLocker is TokenRegistry {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMathUpgradeable for uint256;\n\n    event Locked(\n        address indexed token,\n        address indexed sender,\n        uint256 amount,\n        address recipient\n    );\n\n    event Burn(\n        address indexed token,\n        address indexed sender,\n        uint256 amount,\n        address recipient\n    );\n\n    bytes32 constant lockEventSig =\n        keccak256(\"Locked(address,address,uint256,address)\");\n    bytes32 constant burnEventSig =\n        keccak256(\"Burn(address,address,uint256,address)\");\n\n    address public otherSideBridge;\n\n    function unlock(\n        BridgedToken token,\n        address recipient,\n        uint256 amount\n    ) external {\n        require(recipient != address(0), \"recipient is a zero address\");\n        require(\n            RxMappedInv[address(token)] != address(0),\n            \"bridge does not exist\"\n        );\n        token.burnFrom(msg.sender, amount);\n        emit Burn(address(token), msg.sender, amount, recipient);\n    }\n\n    function lock(\n        IERC20Upgradeable token,\n        address recipient,\n        uint256 amount\n    ) external {\n        require(recipient != address(0), \"recipient is a zero address\");\n        require(\n            TxMapped[address(token)] != address(0),\n            \"bridge does not exist\"\n        );\n        // grabbing the actual amount that is transferred\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualAmount = balanceAfter.sub(balanceBefore);\n        emit Locked(address(token), msg.sender, actualAmount, recipient);\n    }\n\n    function toReceiptItems(bytes memory rlpdata) private pure returns(RLPReader.RLPItem[] memory receipt) {\n        RLPReader.RLPItem memory stacks = rlpdata.toRlpItem();\n        if(rlpdata[0] <= 0x7f) { // if rlpdata[0] between [0,0x7f], it means TransactionType of EIP-2718.\n            stacks.memPtr += 1;\n            stacks.len -= 1;\n        }\n        return stacks.toList();\n    }\n\n    function execute(bytes memory rlpdata) internal returns (uint256 events) {\n        RLPReader.RLPItem[] memory receipt = toReceiptItems(rlpdata);\n        // TODO: check txs is revert or not\n        uint256 postStateOrStatus = receipt[0].toUint();\n        require(postStateOrStatus == 1, \"revert receipt\");\n        RLPReader.RLPItem[] memory logs = receipt[3].toList();\n        for (uint256 i = 0; i < logs.length; i++) {\n            RLPReader.RLPItem[] memory rlpLog = logs[i].toList();\n            address Address = rlpLog[0].toAddress();\n            if (Address != otherSideBridge) continue;\n            RLPReader.RLPItem[] memory Topics = rlpLog[1].toList(); // TODO: if is lock event\n            bytes32[] memory topics = new bytes32[](Topics.length);\n            for (uint256 j = 0; j < Topics.length; j++) {\n                topics[j] = bytes32(Topics[j].toUint());\n            }\n            bytes memory Data = rlpLog[2].toBytes();\n            if (topics[0] == lockEventSig) {\n                onLockEvent(topics, Data);\n                events++;\n                continue;\n            }\n            if (topics[0] == burnEventSig) {\n                onBurnEvent(topics, Data);\n                events++;\n                continue;\n            }\n            if (topics[0] == TokenMapReqEventSig) {\n                onTokenMapReqEvent(topics, Data);\n                events++;\n                continue;\n            }\n            if (topics[0] == TokenMapAckEventSig) {\n                onTokenMapAckEvent(topics);\n                events++;\n                continue;\n            }\n        }\n    }\n\n    //This argument passing is an excellent example of how to get around stack too deep\n    function onBurnEvent(bytes32[] memory topics, bytes memory data) private {\n        address token = address(uint160(uint256(topics[1])));\n        //address sender = address(uint160(uint256(topics[2])));\n        (uint256 amount, address recipient) = abi.decode(\n            data,\n            (uint256, address)\n        );\n        IERC20Upgradeable lockedToken = TxMappedInv[token];\n        lockedToken.safeTransfer(recipient, amount);\n    }\n\n    function onLockEvent(bytes32[] memory topics, bytes memory data) private {\n        address token = address(uint160(uint256(topics[1])));\n        //address sender = address(uint160(uint256(topics[2])));\n        (uint256 amount, address recipient) = abi.decode(\n            data,\n            (uint256, address)\n        );\n        BridgedToken mintToken = RxMapped[token];\n        require(address(mintToken) != address(0));\n        mintToken.mint(recipient, amount);\n    }\n}\n"
    },
    "contracts/lib/ECVerify.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary ECVerify {\n    function ecverify(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address signature_address) {\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\n        if (v < 27) {\n            v += 27;\n        }\n\n        // EIP 155: 2 * chainId + 35\n        if (v > 28) {\n            v = v % 2 == 1 ? 27 : 28;\n        }\n\n        require(v == 27 || v == 28);\n\n        signature_address = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(signature_address != address(0x0), \"ECVerify revert\");\n\n        return signature_address;\n    }\n}\n"
    },
    "contracts/lib/MPTValidatorV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./RLPReader.sol\";\n\n/// @dev MPTValidatorV2 is improved by LayerZero https://bscscan.com/address/0xCFf08a35A5f27F306e2DA99ff198dB90f13DEF77#code\nlibrary MPTValidatorV2 {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of value in the trie, the value is returned.\n    ///      It only prove the value is included in the tree, the format and sanity of the value should be checked by caller.\n    ///      It will revert if the proof is invalid.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n    /// @param paths select indexes array encoding to uint256.\n    /// @param proof is decoded to stack of MPT nodes (starting with the root) that\n    ///        need to be traversed during verification.\n    /// @return value whose inclusion is proved or an empty byte array for\n    ///         a proof of exclusion\n    function validateProof(\n        bytes32 rootHash,\n        uint256 paths,\n        bytes memory proof\n    ) internal pure returns (bytes memory) {\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(proof);\n        RLPReader.Iterator memory iterator = item.iterator();\n        uint256 numItems = item.numItems();\n        for (uint256 i = 0; i < numItems; i++) {\n            item = iterator.next();\n            uint256 index = uint8(paths);\n            paths >>= 8;\n            require(\n                rootHash == item.toRlpBytesHash(),\n                \"ProofLib: invalid hashlink\"\n            );\n            item = item.safeGetItemByIndex(index);\n            if (i < numItems - 1) rootHash = bytes32(item.toUint());\n        }\n        require(paths == 0, \"invalid path\");\n        return item.toBytes();\n    }\n}\n"
    },
    "contracts/TokenLockerOnHarmony.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"./EthereumLightClient.sol\";\nimport \"./lib/MPTValidatorV2.sol\";\nimport \"./TokenLocker.sol\";\n\ncontract TokenLockerOnHarmony is TokenLocker, OwnableUpgradeable {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    EthereumLightClient public lightclient;\n\n    mapping(bytes32 => bool) public spentReceipt;\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function changeLightClient(EthereumLightClient newClient)\n        external\n        onlyOwner\n    {\n        lightclient = newClient;\n    }\n\n    function bind(address otherSide) external onlyOwner {\n        otherSideBridge = otherSide;\n    }\n\n    function validateAndExecuteProof(\n        uint256 blockNo,\n        bytes32 rootHash,\n        uint256 proofPath,\n        bytes calldata proof\n    ) external {\n        bytes32 blockHash = bytes32(lightclient.blocksByHeight(blockNo, 0));\n        require(\n            lightclient.VerifyReceiptsHash(blockHash, rootHash),\n            \"wrong receipt hash\"\n        );\n        require(\n            lightclient.isVerified(uint256(blockHash)),\n            \"Block not verified\"\n        );\n        bytes32 receiptHash = keccak256(\n            abi.encodePacked(blockHash, rootHash, proofPath)\n        );\n        require(spentReceipt[receiptHash] == false, \"double spent!\");\n        bytes memory rlpdata = MPTValidatorV2.validateProof(\n            rootHash,\n            proofPath,\n            proof\n        );\n        spentReceipt[receiptHash] = true;\n        uint256 executedEvents = execute(rlpdata);\n        require(executedEvents > 0, \"no valid event\");\n    }\n}\n"
    },
    "contracts/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"./EthereumParser.sol\";\nimport \"./lib/EthUtils.sol\";\nimport \"./ethash/ethash.sol\";\n\n/// @title Ethereum light client\ncontract EthereumLightClient is Ethash, Initializable, PausableUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    \n    struct StoredBlockHeader {\n        uint256 parentHash;\n        uint256 stateRoot;\n        uint256 transactionsRoot;\n        uint256 receiptsRoot;\n        uint256 number;\n        uint256 difficulty;\n        uint256 totalDifficulty;\n        uint256 time;\n        uint256 hash;\n    }\n\n    struct HeaderInfo {\n        uint256 total_difficulty;\n        bytes32 parent_hash;\n        uint64 number;\n    }\n\n    // The first block header hash\n    uint256 public firstBlock;\n\n    // Block header hash of the current canonical chain head\n    uint256 public canonicalHead;\n\n    //Blocks existing in the current canonical chain, in the form blockHeaderHash => bool\n    mapping(uint256 => bool) public canonicalBlocks;\n\n    // Blocks data, in the form: blockHeaderHash => BlockHeader\n    mapping(uint256 => StoredBlockHeader) public blocks;\n\n    // Block existing map, in the form: blockHeaderHash => bool\n    mapping(uint256 => bool) public blockExisting;\n\n    // Valid relayed blocks for a block height, in the form: blockNumber => blockHeaderHash[]\n    mapping(uint256 => uint256[]) public blocksByHeight;\n\n    // Block height existing map, in the form: blockNumber => bool\n    mapping(uint256 => bool) public blocksByHeightExisting;\n\n    // Max block height stored\n    uint256 public blockHeightMax;\n\n    // Block header hash that points to longest chain head\n    // (please note that 'longest' chain is based on total difficulty)\n    // uint public longestChainHead;\n\n    // Longest branch head of each checkpoint, in the form: (checkpoint block hash) => (head block hash)\n    // (note that 'longest branch' means the branch which has biggest cumulative difficulty from checkpoint)\n    mapping(uint256 => uint256) public longestBranchHead;\n\n    uint256 private constant DEFAULT_FINALITY_CONFIRMS = 13;\n\n    uint256 public finalityConfirms;\n\n    // number of the oldest block that stored, we use this to prune the expired blocks from state\n    uint256 public oldestBlockStored;\n    uint256 private constant BLOCK_EXPIRED = 30 days;\n    uint256 private constant MAX_PRUNE_ONCE = 16;\n\n    function initialize(bytes memory _rlpHeader) external initializer {\n        finalityConfirms = DEFAULT_FINALITY_CONFIRMS;\n\n        uint256 blockHash = EthereumParser.calcBlockHeaderHash(_rlpHeader);\n        // Parse rlp-encoded block header into structure\n        EthereumParser.BlockHeader memory header = EthereumParser\n            .parseBlockHeader(_rlpHeader);\n        // Save block header info\n        StoredBlockHeader memory storedBlock = StoredBlockHeader({\n            parentHash: header.parentHash,\n            stateRoot: header.stateRoot,\n            transactionsRoot: header.transactionsRoot,\n            receiptsRoot: header.receiptsRoot,\n            number: header.number,\n            difficulty: header.difficulty,\n            totalDifficulty : header.difficulty,\n            time: header.timestamp,\n            hash: blockHash\n        });\n        _setFirstBlock(storedBlock);\n    }\n\n    function _deleteBlock(uint256 blockNo) private {\n        uint256[] storage blockHashes = blocksByHeight[blockNo];\n        for(uint256 j = 0; j < blockHashes.length; j++) {\n            uint256 blockHash = blockHashes[j];\n            delete blocks[blockHash];\n            delete blockExisting[blockHash];\n        }\n        delete blocksByHeight[blockNo];\n        delete blocksByHeightExisting[blockNo];\n        delete canonicalBlocks[blockNo];\n    }\n \n    function _pruneBlocks(uint256 pruneTime) private {\n        uint256 blockCur = oldestBlockStored;\n        for(uint256 i = 0; i < MAX_PRUNE_ONCE; i++) {\n            uint256 blockNo = blockCur++;\n            if(!blocksByHeightExisting[blockNo]) continue;\n            uint256 blockHash = blocksByHeight[blockNo][0];\n            if(blocks[blockHash].time > pruneTime) break;\n            _deleteBlock(blockNo);\n        }\n        if(blockCur > oldestBlockStored) oldestBlockStored = blockCur;\n    }\n\n    //uint32 constant loopAccesses = 64;      // Number of accesses in hashimoto loop\n    function addBlockHeader(\n        bytes memory _rlpHeader,\n        bytes32[4][loopAccesses] memory cache,\n        bytes32[][loopAccesses] memory proofs\n    ) public whenNotPaused returns (bool) {\n        _pruneBlocks(block.timestamp - BLOCK_EXPIRED);\n        // Calculate block header hash\n        uint256 blockHash = EthereumParser.calcBlockHeaderHash(_rlpHeader);\n        // Check block existing\n        require(\n            !blockExisting[blockHash],\n            \"Relay block failed: block already relayed\"\n        );\n\n        // Parse rlp-encoded block header into structure\n        EthereumParser.BlockHeader memory header = EthereumParser\n            .parseBlockHeader(_rlpHeader);\n\n        // Check the existence of parent block\n        require(\n            blockExisting[header.parentHash],\n            \"Relay block failed: parent block not relayed yet\"\n        );\n\n        // Check block height\n        require(\n            header.number == blocks[header.parentHash].number.add(1),\n            \"Relay block failed: invalid block blockHeightMax\"\n        );\n\n        // Check timestamp\n        require(\n            header.timestamp > blocks[header.parentHash].time,\n            \"Relay block failed: invalid timestamp\"\n        );\n\n        // Check difficulty\n        require(\n            _checkDiffValidity(\n                header.difficulty,\n                blocks[header.parentHash].difficulty\n            ),\n            \"Relay block failed: invalid difficulty\"\n        );\n\n        // Verify block PoW\n        uint256 sealHash = EthereumParser.calcBlockSealHash(_rlpHeader);\n        bool rVerified = verifyEthash(\n            bytes32(sealHash),\n            uint64(header.nonce),\n            uint64(header.number),\n            cache,\n            proofs,\n            header.difficulty,\n            header.mixHash\n        );\n        require(rVerified, \"Relay block failed: invalid PoW\");\n\n        // Save block header info\n        StoredBlockHeader memory storedBlock = StoredBlockHeader({\n            parentHash: header.parentHash,\n            stateRoot: header.stateRoot,\n            transactionsRoot: header.transactionsRoot,\n            receiptsRoot: header.receiptsRoot,\n            number: header.number,\n            difficulty: header.difficulty,\n            totalDifficulty : blocks[header.parentHash].totalDifficulty.add(header.difficulty),\n            time: header.timestamp,\n            hash: blockHash\n        });\n\n        blocks[blockHash] = storedBlock;\n        blockExisting[blockHash] = true;\n        // verifiedBlocks[blockHash] = true;\n\n        blocksByHeight[header.number].push(blockHash);\n        blocksByHeightExisting[header.number] = true;\n\n        if (header.number > blockHeightMax) {\n            blockHeightMax = header.number;\n        }\n\n        //Check if this block is ahead of the canonical head\n        if(header.parentHash == canonicalHead){\n            canonicalHead = blockHash;\n            canonicalBlocks[blockHash] = true;\n        }\n        //Check if the canonical chain needs to be replaced by another fork\n        else if(blocks[canonicalHead].totalDifficulty < blocks[blockHash].totalDifficulty){\n            _updateCanonicalChain(blockHash);\n        }\n\n        return true;\n    }\n\n    //Iterate backward through blocks from this block to find where the canonical chain converges with this fork\n    //Consider also that there may be no point of convergence, so in that case stop iterating when block's parent hash stops exiting in the blocks mapping\n    //Mark All blocks along the way as part of the canonical chain\n    function _updateCanonicalChain(\n        uint256 _blockHash\n    )\n        internal\n    {\n        uint256 current = _blockHash;\n\n        //Iterate backward from new head marking the blocks as part of the canonical chain\n        while(!canonicalBlocks[current] && blockExisting[current]){ //Second part of if statement if for replacing whole canonical chain\n            canonicalBlocks[current] = true;\n            current = blocks[current].parentHash;\n        }\n\n        //current now represents either our point of convergence, or the block one before the first blocked stored in the ELC\n        uint256 convergenceOrFirstBlock = current;\n        current = canonicalHead;\n\n        //Remove blocks from canonical chain until either point of convergence, or until the chain leaves range of storage\n        while(current != convergenceOrFirstBlock && blockExisting[current]){\n            canonicalBlocks[current] = false;\n            current = blocks[current].parentHash;\n        }\n\n        canonicalHead = _blockHash;\n\n    }\n\n    function isVerified(uint256 blockHash)\n        public\n        view\n        returns (bool)\n    {\n        //Check that block is in canonical chain and has at least 25 confirmations\n        return canonicalBlocks[blockHash] && blocks[blockHash].number + 25 < blocks[canonicalHead].number;\n    }\n\n    function isFinalized(uint256 blockHash)\n        public\n        view\n        returns (bool)\n    {\n        return canonicalBlocks[blockHash] && blocks[blockHash].number + 200 < blocks[canonicalHead].number;\n    }\n\n    function numberOfBlockConfirmations(uint256 blockHash)\n        public\n        view\n        returns (uint256)\n    {\n        if(!canonicalBlocks[blockHash]) return 0;\n        else return blocks[canonicalHead].number - blocks[blockHash].number;\n    }\n\n    function getBlockHeightMax() public view returns (uint256) {\n        return blockHeightMax;\n    }\n\n    function getStateRoot(bytes32 blockHash) public view returns (bytes32) {\n        return bytes32(blocks[uint256(blockHash)].stateRoot);\n    }\n\n    function getTxRoot(bytes32 blockHash) public view returns (bytes32) {\n        return bytes32(blocks[uint256(blockHash)].transactionsRoot);\n    }\n\n    function getReceiptRoot(bytes32 blockHash) public view returns (bytes32) {\n        return bytes32(blocks[uint256(blockHash)].receiptsRoot);\n    }\n\n    function VerifyReceiptsHash(bytes32 blockHash, bytes32 receiptsHash)\n        external\n        view\n        returns (bool)\n    {\n        return bytes32(blocks[uint256(blockHash)].receiptsRoot) == receiptsHash;\n    }\n\n    // Check the difficulty of block is valid or not\n    // (the block difficulty adjustment is described here: https://github.com/ethereum/EIPs/issues/100)\n    // Note that this is only 'minimal check' because we do not have 'block uncles' information to calculate exactly.\n    // 'Minimal check' is enough to prevent someone from spamming relaying blocks with quite small difficulties\n    function _checkDiffValidity(uint256 diff, uint256 parentDiff)\n        private\n        pure\n        returns (bool)\n    {\n        return diff >= parentDiff.sub((parentDiff / 10000) * 99);\n    }\n\n    function _setFirstBlock(StoredBlockHeader memory toSetBlock) private {\n        firstBlock = toSetBlock.hash;\n\n        blocks[toSetBlock.hash] = toSetBlock;\n        blockExisting[toSetBlock.hash] = true;\n\n        blocksByHeight[toSetBlock.number].push(toSetBlock.hash);\n        blocksByHeightExisting[toSetBlock.number] = true;\n\n        blockHeightMax = toSetBlock.number;\n\n        longestBranchHead[toSetBlock.hash] = toSetBlock.hash;\n\n        canonicalHead = firstBlock;\n\n        canonicalBlocks[firstBlock] = true;\n\n        oldestBlockStored = toSetBlock.number;\n    }\n}\n"
    },
    "contracts/EthereumParser.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n * Created on 2019-12-28\n * @summary: The EthCommon library contains common structures / functions\n * @author: Tuan Vu (tuanvd@gmail.com)\n */\n\npragma solidity ^0.8.0;\n\nimport \"./lib/RLPReader.sol\";\nimport \"./lib/RLPEncode.sol\";\n\nlibrary EthereumParser {\n    using RLPReader for bytes;\n    using RLPReader for uint256;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n\n    using RLPEncode for bytes;\n    using RLPEncode for bytes[];\n\n    struct BlockHeader {\n        uint256 parentHash;\n        uint256 sha3Uncles;\n        address miner;\n        uint256 stateRoot;\n        uint256 transactionsRoot;\n        uint256 receiptsRoot;\n        bytes logsBloom;\n        uint256 difficulty;\n        uint256 number;\n        uint256 gasLimit;\n        uint256 gasUsed;\n        uint256 timestamp;\n        bytes extraData;\n        uint256 mixHash;\n        uint256 nonce;\n        uint256 baseFeePerGas;\n    }\n\n    /**\n     * Parse RLP-encoded block header into BlockHeader data structure\n     *  @param _rlpHeader: RLP-encoded block header with data fields order as defined in the BlockHeader struct\n     **/\n    function parseBlockHeader(bytes memory _rlpHeader)\n        internal\n        pure\n        returns (BlockHeader memory header)\n    {\n        RLPReader.Iterator memory it = _rlpHeader.toRlpItem().iterator();\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) header.parentHash = it.next().toUint();\n            else if (idx == 1) header.sha3Uncles = it.next().toUint();\n            else if (idx == 2) header.miner = it.next().toAddress();\n            else if (idx == 3) header.stateRoot = it.next().toUint();\n            else if (idx == 4) header.transactionsRoot = it.next().toUint();\n            else if (idx == 5) header.receiptsRoot = it.next().toUint();\n            else if (idx == 6) header.logsBloom = it.next().toBytes();\n            else if (idx == 7) header.difficulty = it.next().toUint();\n            else if (idx == 8) header.number = it.next().toUint();\n            else if (idx == 9) header.gasLimit = it.next().toUint();\n            else if (idx == 10) header.gasUsed = it.next().toUint();\n            else if (idx == 11) header.timestamp = it.next().toUint();\n            else if (idx == 12) header.extraData = it.next().toBytes();\n            else if (idx == 13) header.mixHash = it.next().toUint();\n            else if (idx == 14) header.nonce = it.next().toUint();\n            else if (idx == 15) header.baseFeePerGas = it.next().toUint();\n            else it.next();\n\n            idx++;\n        }\n        return header;\n    }\n\n    function calcBlockHeaderHash(bytes memory _rlpHeader)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(_rlpHeader));\n    }\n\n    function calcBlockSealHash(bytes memory _rlpHeader)\n        internal\n        pure\n        returns (uint256)\n    {\n        bytes[] memory rlpFields = new bytes[](14);\n        RLPReader.Iterator memory it = _rlpHeader.toRlpItem().iterator();\n        uint256 idx = 0;\n        while (it.hasNext() && idx < 14) {\n            if (idx == 13) {\n                it.next();\n                it.next();\n            }\n            rlpFields[idx] = it.next().toRlpBytes();\n            idx++;\n        }\n\n        bytes memory toSealRlpData = rlpFields.encodeList();\n        return uint256(keccak256(toSealRlpData));\n    }\n\n    struct Transaction {\n        uint256 nonce;\n        uint256 gasPrice;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes input;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @param _rlpTx: RLP-encoded tx with data fields order as defined in the Tx struct\n     **/\n    function parseTx(bytes memory _rlpTx)\n        internal\n        pure\n        returns (Transaction memory trans)\n    {\n        RLPReader.Iterator memory it = _rlpTx.toRlpItem().iterator();\n        uint256 idx;\n        while (it.hasNext()) {\n            if (idx == 0) trans.nonce = it.next().toUint();\n            else if (idx == 1) trans.gasPrice = it.next().toUint();\n            else if (idx == 2) trans.gas = it.next().toUint();\n            else if (idx == 3) trans.to = it.next().toAddress();\n            else if (idx == 4) trans.value = it.next().toUint();\n            else if (idx == 5) trans.input = it.next().toBytes();\n            else if (idx == 6) trans.v = uint8(it.next().toUint());\n            else if (idx == 7) trans.r = it.next().toBytes32();\n            else if (idx == 8) trans.s = it.next().toBytes32();\n            else it.next();\n            idx++;\n        }\n        return trans;\n    }\n}\n"
    },
    "contracts/lib/EthUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n * Created on 2019-12-28\n * @summary: The EthUtils library contains utility functions\n * @author: Tuan Vu (tuanvd@gmail.com)\n */\n\npragma solidity ^0.8.0;\n\nlibrary EthUtils {\n    function bytesToBytes32(bytes memory b, uint256 offset)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 out;\n\n        for (uint256 i = 0; i < 32; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function hexStrToBytes(string memory _hexStr)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        //Check hex string is valid\n        if (\n            bytes(_hexStr)[0] != \"0\" ||\n            bytes(_hexStr)[1] != \"x\" ||\n            bytes(_hexStr).length % 2 != 0 ||\n            bytes(_hexStr).length < 4\n        ) {\n            revert(\"hexStrToBytes: invalid input\");\n        }\n\n        bytes memory bytes_array = new bytes((bytes(_hexStr).length - 2) / 2);\n\n        for (uint256 i = 2; i < bytes(_hexStr).length; i += 2) {\n            uint8 tetrad1 = 16;\n            uint8 tetrad2 = 16;\n\n            //left digit\n            if (\n                uint8(bytes(_hexStr)[i]) >= 48 && uint8(bytes(_hexStr)[i]) <= 57\n            ) tetrad1 = uint8(bytes(_hexStr)[i]) - 48;\n\n            //right digit\n            if (\n                uint8(bytes(_hexStr)[i + 1]) >= 48 &&\n                uint8(bytes(_hexStr)[i + 1]) <= 57\n            ) tetrad2 = uint8(bytes(_hexStr)[i + 1]) - 48;\n\n            //left A->F\n            if (\n                uint8(bytes(_hexStr)[i]) >= 65 && uint8(bytes(_hexStr)[i]) <= 70\n            ) tetrad1 = uint8(bytes(_hexStr)[i]) - 65 + 10;\n\n            //right A->F\n            if (\n                uint8(bytes(_hexStr)[i + 1]) >= 65 &&\n                uint8(bytes(_hexStr)[i + 1]) <= 70\n            ) tetrad2 = uint8(bytes(_hexStr)[i + 1]) - 65 + 10;\n\n            //left a->f\n            if (\n                uint8(bytes(_hexStr)[i]) >= 97 &&\n                uint8(bytes(_hexStr)[i]) <= 102\n            ) tetrad1 = uint8(bytes(_hexStr)[i]) - 97 + 10;\n\n            //right a->f\n            if (\n                uint8(bytes(_hexStr)[i + 1]) >= 97 &&\n                uint8(bytes(_hexStr)[i + 1]) <= 102\n            ) tetrad2 = uint8(bytes(_hexStr)[i + 1]) - 97 + 10;\n\n            //Check all symbols are allowed\n            if (tetrad1 == 16 || tetrad2 == 16)\n                revert(\"hexStrToBytes: invalid input\");\n\n            bytes_array[i / 2 - 1] = bytes1(16 * tetrad1 + tetrad2);\n        }\n\n        return bytes_array;\n    }\n}\n"
    },
    "contracts/ethash/ethash.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./binary.sol\";\nimport \"./keccak512.sol\";\nimport \"./Prime.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\n\nimport \"./MerkelRoot.sol\"; // npm run merkelInit\n\ncontract Ethash is MerkelRoots {\n    using LittleEndian for bytes;\n    using Keccak512 for bytes;\n    using Prime for uint256;\n\n    uint32 constant hashWords = 16;\n    uint32 constant hashBytes = 64;\n    uint32 constant datasetParents = 256;\n    uint32 constant mixBytes = 128; // Width of mix\n    uint32 constant loopAccesses = 64; // Number of accesses in hashimoto loop\n    uint256 constant MAX256 =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    uint256 constant DATASET_BYTES_INIT = 1073741824;\n    uint256 constant DATASET_BYTES_GROWTH = 8388608; // 2 ^ 23\n    uint256 constant EPOCH_LENGTH = 30000;\n\n    function getFullSize(uint256 epoc) private pure returns (uint256) {\n        uint256 sz = DATASET_BYTES_INIT + (DATASET_BYTES_GROWTH) * epoc;\n        sz -= mixBytes;\n        while (!(sz / mixBytes).probablyPrime(2)) {\n            sz -= 2 * mixBytes;\n        }\n        return sz;\n    }\n\n    // fnv is an algorithm inspired by the FNV hash, which in some cases is used as\n    // a non-associative substitute for XOR. Note that we multiply the prime with\n    // the full 32-bit input, in contrast with the FNV-1 spec which multiplies the\n    // prime with one byte (octet) in turn.\n    function fnv(uint32 a, uint32 b) internal pure returns (uint32) {\n        return (a * 0x01000193) ^ b;\n    }\n\n    // fnvHash mixes in data into mix using the ethash fnv method.\n    function fnvHash32(uint32[] memory mix, uint32[] memory data)\n        internal\n        pure\n    {\n        assembly {\n            let mixOffset := add(mix, 0x20)\n            let mixValue := mload(mixOffset)\n            let dataOffset := add(data, 0x20)\n            let dataValue := mload(dataOffset)\n\n            // fnv = return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\n            let fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 2\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 3\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 4\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 5\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 6\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 7\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 2\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 3\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 4\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 5\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 6\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 7\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n            // ---- 1\n            dataOffset := add(dataOffset, 0x20)\n            dataValue := mload(dataOffset)\n            mixOffset := add(mixOffset, 0x20)\n            mixValue := mload(mixOffset)\n            fnvValue := and(\n                xor(mul(mixValue, 0x01000193), dataValue),\n                0xFFFFFFFF\n            )\n            mstore(mixOffset, fnvValue)\n        }\n    }\n\n    // hashimoto aggregates data from the full dataset in order to produce our final\n    // value for a particular header hash and nonce.\n    function hashimoto(\n        bytes32 hash,\n        uint64 nonce,\n        uint64 size,\n        bytes32[4][loopAccesses] memory cache,\n        bytes32 rootHash,\n        bytes32[][loopAccesses] memory proofs\n    ) private pure returns (bytes32, bytes32) {\n        // Calculate the number of theoretical rows (we use one buffer nonetheless)\n        uint32 rows = uint32(size / mixBytes);\n\n        // Combine header+nonce into a 64 byte seed\n        bytes memory seed = new bytes(40);\n        seed.copyBytes32(0, hash);\n        seed.PutUint64(32, nonce);\n\n        seed = seed.sha3_512();\n        uint32 seedHead = seed.Uint32(0);\n\n        // Start the mix with replicated seed\n        uint32[] memory mix = new uint32[](mixBytes / 4);\n        for (uint32 i = 0; i < mix.length; i++) {\n            mix[i] = seed.Uint32((i % 16) * 4);\n        }\n        // Mix in random dataset nodes\n        uint32[] memory temp = new uint32[](mix.length);\n\n        bytes32 root = rootHash;\n        for (uint32 i = 0; i < loopAccesses; i++) {\n            uint32 parent = fnv(i ^ seedHead, mix[i % mix.length]) % rows;\n            //bytes32[4] memory dag = cache[2*parent];\n            bytes32[4] memory dag = cache[i];\n            uint256 dagIndex = 2 * parent;\n            bytes32[] memory proof = proofs[i];\n            bytes32 leafHash = keccak256(abi.encodePacked(dagIndex, dag));\n            MerkleProofUpgradeable.verify(proof, root, leafHash);\n            for (uint32 j = 0; j < dag.length; j++) {\n                uint32 k = j * 8;\n                uint256 data = uint256(dag[j]);\n                temp[k] = LittleEndian.reverse(uint32(data >> (7 * 32)));\n                temp[k + 1] = LittleEndian.reverse(uint32(data >> (6 * 32)));\n                temp[k + 2] = LittleEndian.reverse(uint32(data >> (5 * 32)));\n                temp[k + 3] = LittleEndian.reverse(uint32(data >> (4 * 32)));\n                temp[k + 4] = LittleEndian.reverse(uint32(data >> (3 * 32)));\n                temp[k + 5] = LittleEndian.reverse(uint32(data >> (2 * 32)));\n                temp[k + 6] = LittleEndian.reverse(uint32(data >> (1 * 32)));\n                temp[k + 7] = LittleEndian.reverse(uint32(data >> (0 * 32)));\n            }\n            fnvHash32(mix, temp);\n        }\n\n        // Compress mix\n        for (uint32 i = 0; i < mix.length; i += 4) {\n            mix[i / 4] = fnv(\n                fnv(fnv(mix[i], mix[i + 1]), mix[i + 2]),\n                mix[i + 3]\n            );\n        }\n        //mix = mix[:len(mix)/4];\n        uint256 digest = 0;\n        for (uint32 i = 0; i < mix.length / 4; i++) {\n            //binary.LittleEndian.PutUint32(digest[i*4:], val)\n            digest <<= 32;\n            uint32 val = mix[i];\n            digest |= uint256(\n                ((val & 0xff) << 24) |\n                    (((val >> 8) & 0xff) << 16) |\n                    (((val >> 16) & 0xff) << 8) |\n                    (val >> 24)\n            );\n        }\n        return (bytes32(digest), keccak256(abi.encodePacked(seed, digest)));\n    }\n\n    function verifyEthash(\n        bytes32 hash,\n        uint64 nonce,\n        uint64 number,\n        bytes32[4][loopAccesses] memory cache,\n        bytes32[][loopAccesses] memory proofs,\n        uint256 difficulty,\n        uint256 mixHash\n    ) public pure returns (bool) {\n        uint256 epoch = number / EPOCH_LENGTH;\n        bytes32 rootHash = getRootHash(uint64(epoch));\n        uint256 size = getFullSize(epoch);\n        (bytes32 mix, bytes32 _diff) = hashimoto(\n            hash,\n            nonce,\n            uint64(size),\n            cache,\n            rootHash,\n            proofs\n        );\n        uint256 target = MAX256 / difficulty; // target = (2**256)/difficult;\n        target += ((MAX256 % difficulty) + 1) / difficulty;\n        return\n            mix == bytes32(mixHash) &&\n            difficulty > 1 &&\n            target > uint256(_diff);\n    }\n}\n"
    },
    "contracts/ethash/binary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nlibrary LittleEndian {\n    using LittleEndian for bytes;\n\n    function reverse(uint32 num) internal pure returns (uint32) {\n        return\n            (num >> 24) |\n            ((num >> 8) & 0xff00) |\n            ((num << 8) & 0xff0000) |\n            ((num << 24) & 0xff000000);\n    }\n\n    function PutUint32(\n        bytes memory dst,\n        uint32 offset,\n        uint32 data\n    ) internal pure {\n        assembly {\n            let memPtr := add(dst, add(offset, 0x20))\n            mstore8(memPtr, data)\n            mstore8(add(memPtr, 1), shr(8, data))\n            mstore8(add(memPtr, 2), shr(16, data))\n            mstore8(add(memPtr, 3), shr(24, data))\n        }\n        /*\n        dst[offset] = byte(uint8(data));\n        dst[offset+1] = byte(uint8(data>>8));\n        dst[offset+2] = byte(uint8(data>>16));\n        dst[offset+3] = byte(uint8(data>>24));*/\n    }\n\n    function Uint32(bytes memory src, uint32 offset)\n        internal\n        pure\n        returns (uint32)\n    {\n        uint256 num;\n        assembly {\n            let memPtr := add(src, add(offset, 0x4)) // offset + 0x20 - (32-4)\n            num := mload(memPtr)\n        }\n        return reverse(uint32(num));\n        //return uint32(uint8(src[offset+3]))<<24 | uint32(uint8(src[offset+2]))<<16 | uint32(uint8(src[offset+1]))<<8 | uint32(uint8(src[offset]));\n    }\n\n    function PutUint64(\n        bytes memory dst,\n        uint32 offset,\n        uint64 data\n    ) internal pure {\n        dst.PutUint32(offset + 0, uint32(data));\n        dst.PutUint32(offset + 4, uint32(data >> 32));\n    }\n\n    function copyBytes32(\n        bytes memory dst,\n        uint32 offset,\n        bytes32 data\n    ) internal pure {\n        assembly {\n            let memPtr := add(dst, add(offset, 0x20))\n            mstore(memPtr, data)\n        }\n    }\n}\n"
    },
    "contracts/ethash/keccak512.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./binary.sol\";\n\nlibrary Keccak512 {\n    using LittleEndian for bytes;\n\n    function keccak_f(uint256[25] memory A)\n        private\n        pure\n        returns (uint256[25] memory)\n    {\n        uint256[5] memory C;\n        uint256[5] memory D;\n        //uint x;\n        //uint y;\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\n        uint256[25] memory B;\n\n        uint256[24] memory RC = [\n            uint256(0x0000000000000001),\n            0x0000000000008082,\n            0x800000000000808A,\n            0x8000000080008000,\n            0x000000000000808B,\n            0x0000000080000001,\n            0x8000000080008081,\n            0x8000000000008009,\n            0x000000000000008A,\n            0x0000000000000088,\n            0x0000000080008009,\n            0x000000008000000A,\n            0x000000008000808B,\n            0x800000000000008B,\n            0x8000000000008089,\n            0x8000000000008003,\n            0x8000000000008002,\n            0x8000000000000080,\n            0x000000000000800A,\n            0x800000008000000A,\n            0x8000000080008081,\n            0x8000000000008080,\n            0x0000000080000001,\n            0x8000000080008008\n        ];\n\n        for (uint256 i = 0; i < 24; i++) {\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\n            }*/\n\n            C[0] = A[0] ^ A[1] ^ A[2] ^ A[3] ^ A[4];\n            C[1] = A[5] ^ A[6] ^ A[7] ^ A[8] ^ A[9];\n            C[2] = A[10] ^ A[11] ^ A[12] ^ A[13] ^ A[14];\n            C[3] = A[15] ^ A[16] ^ A[17] ^ A[18] ^ A[19];\n            C[4] = A[20] ^ A[21] ^ A[22] ^ A[23] ^ A[24];\n\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\n            }*/\n\n            D[0] =\n                C[4] ^\n                (((C[1] * 2) & 0xffffffffffffffff) | (C[1] / (2**63)));\n            D[1] =\n                C[0] ^\n                (((C[2] * 2) & 0xffffffffffffffff) | (C[2] / (2**63)));\n            D[2] =\n                C[1] ^\n                (((C[3] * 2) & 0xffffffffffffffff) | (C[3] / (2**63)));\n            D[3] =\n                C[2] ^\n                (((C[4] * 2) & 0xffffffffffffffff) | (C[4] / (2**63)));\n            D[4] =\n                C[3] ^\n                (((C[0] * 2) & 0xffffffffffffffff) | (C[0] / (2**63)));\n\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                for( y = 0 ; y < 5 ; y++ ) {\n                    A[5*x+y] = A[5*x+y] ^ D[x];\n                }\n            }*/\n\n            A[0] = A[0] ^ D[0];\n            A[1] = A[1] ^ D[0];\n            A[2] = A[2] ^ D[0];\n            A[3] = A[3] ^ D[0];\n            A[4] = A[4] ^ D[0];\n            A[5] = A[5] ^ D[1];\n            A[6] = A[6] ^ D[1];\n            A[7] = A[7] ^ D[1];\n            A[8] = A[8] ^ D[1];\n            A[9] = A[9] ^ D[1];\n            A[10] = A[10] ^ D[2];\n            A[11] = A[11] ^ D[2];\n            A[12] = A[12] ^ D[2];\n            A[13] = A[13] ^ D[2];\n            A[14] = A[14] ^ D[2];\n            A[15] = A[15] ^ D[3];\n            A[16] = A[16] ^ D[3];\n            A[17] = A[17] ^ D[3];\n            A[18] = A[18] ^ D[3];\n            A[19] = A[19] ^ D[3];\n            A[20] = A[20] ^ D[4];\n            A[21] = A[21] ^ D[4];\n            A[22] = A[22] ^ D[4];\n            A[23] = A[23] ^ D[4];\n            A[24] = A[24] ^ D[4];\n\n            /*Rho and pi steps*/\n            B[0] = A[0];\n            B[8] = (((A[1] * (2**36)) & 0xffffffffffffffff) | (A[1] / (2**28)));\n            B[11] = (((A[2] * (2**3)) & 0xffffffffffffffff) | (A[2] / (2**61)));\n            B[19] = (((A[3] * (2**41)) & 0xffffffffffffffff) |\n                (A[3] / (2**23)));\n            B[22] = (((A[4] * (2**18)) & 0xffffffffffffffff) |\n                (A[4] / (2**46)));\n            B[2] = (((A[5] * (2**1)) & 0xffffffffffffffff) | (A[5] / (2**63)));\n            B[5] = (((A[6] * (2**44)) & 0xffffffffffffffff) | (A[6] / (2**20)));\n            B[13] = (((A[7] * (2**10)) & 0xffffffffffffffff) |\n                (A[7] / (2**54)));\n            B[16] = (((A[8] * (2**45)) & 0xffffffffffffffff) |\n                (A[8] / (2**19)));\n            B[24] = (((A[9] * (2**2)) & 0xffffffffffffffff) | (A[9] / (2**62)));\n            B[4] = (((A[10] * (2**62)) & 0xffffffffffffffff) |\n                (A[10] / (2**2)));\n            B[7] = (((A[11] * (2**6)) & 0xffffffffffffffff) |\n                (A[11] / (2**58)));\n            B[10] = (((A[12] * (2**43)) & 0xffffffffffffffff) |\n                (A[12] / (2**21)));\n            B[18] = (((A[13] * (2**15)) & 0xffffffffffffffff) |\n                (A[13] / (2**49)));\n            B[21] = (((A[14] * (2**61)) & 0xffffffffffffffff) |\n                (A[14] / (2**3)));\n            B[1] = (((A[15] * (2**28)) & 0xffffffffffffffff) |\n                (A[15] / (2**36)));\n            B[9] = (((A[16] * (2**55)) & 0xffffffffffffffff) |\n                (A[16] / (2**9)));\n            B[12] = (((A[17] * (2**25)) & 0xffffffffffffffff) |\n                (A[17] / (2**39)));\n            B[15] = (((A[18] * (2**21)) & 0xffffffffffffffff) |\n                (A[18] / (2**43)));\n            B[23] = (((A[19] * (2**56)) & 0xffffffffffffffff) |\n                (A[19] / (2**8)));\n            B[3] = (((A[20] * (2**27)) & 0xffffffffffffffff) |\n                (A[20] / (2**37)));\n            B[6] = (((A[21] * (2**20)) & 0xffffffffffffffff) |\n                (A[21] / (2**44)));\n            B[14] = (((A[22] * (2**39)) & 0xffffffffffffffff) |\n                (A[22] / (2**25)));\n            B[17] = (((A[23] * (2**8)) & 0xffffffffffffffff) |\n                (A[23] / (2**56)));\n            B[20] = (((A[24] * (2**14)) & 0xffffffffffffffff) |\n                (A[24] / (2**50)));\n\n            /*Xi state*/\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                for( y = 0 ; y < 5 ; y++ ) {\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\n                }\n            }*/\n\n            A[0] = B[0] ^ ((~B[5]) & B[10]);\n            A[1] = B[1] ^ ((~B[6]) & B[11]);\n            A[2] = B[2] ^ ((~B[7]) & B[12]);\n            A[3] = B[3] ^ ((~B[8]) & B[13]);\n            A[4] = B[4] ^ ((~B[9]) & B[14]);\n            A[5] = B[5] ^ ((~B[10]) & B[15]);\n            A[6] = B[6] ^ ((~B[11]) & B[16]);\n            A[7] = B[7] ^ ((~B[12]) & B[17]);\n            A[8] = B[8] ^ ((~B[13]) & B[18]);\n            A[9] = B[9] ^ ((~B[14]) & B[19]);\n            A[10] = B[10] ^ ((~B[15]) & B[20]);\n            A[11] = B[11] ^ ((~B[16]) & B[21]);\n            A[12] = B[12] ^ ((~B[17]) & B[22]);\n            A[13] = B[13] ^ ((~B[18]) & B[23]);\n            A[14] = B[14] ^ ((~B[19]) & B[24]);\n            A[15] = B[15] ^ ((~B[20]) & B[0]);\n            A[16] = B[16] ^ ((~B[21]) & B[1]);\n            A[17] = B[17] ^ ((~B[22]) & B[2]);\n            A[18] = B[18] ^ ((~B[23]) & B[3]);\n            A[19] = B[19] ^ ((~B[24]) & B[4]);\n            A[20] = B[20] ^ ((~B[0]) & B[5]);\n            A[21] = B[21] ^ ((~B[1]) & B[6]);\n            A[22] = B[22] ^ ((~B[2]) & B[7]);\n            A[23] = B[23] ^ ((~B[3]) & B[8]);\n            A[24] = B[24] ^ ((~B[4]) & B[9]);\n\n            /*Last step*/\n            A[0] = A[0] ^ RC[i];\n        }\n\n        return A;\n    }\n\n    function sponge(uint256[9] memory M)\n        private\n        pure\n        returns (uint256[16] memory)\n    {\n        //require( (M.length * 8) == 72 );\n        //M[7] = 0x01;\n        //M[8] = 0x8000000000000001;\n\n        uint256 r = 72;\n        uint256 w = 8;\n        uint256 size = M.length * 8;\n\n        uint256[25] memory S;\n        uint256 i;\n        uint256 y;\n        uint256 x;\n        /*Absorbing Phase*/\n        for (i = 0; i < size / r; i++) {\n            for (y = 0; y < 5; y++) {\n                for (x = 0; x < 5; x++) {\n                    if ((x + 5 * y) < (r / w)) {\n                        S[5 * x + y] = S[5 * x + y] ^ M[i * 9 + x + 5 * y];\n                    }\n                }\n            }\n            S = keccak_f(S);\n        }\n\n        /*Squeezing phase*/\n        uint256[16] memory result;\n        uint256 b = 0;\n        while (b < 16) {\n            for (y = 0; y < 5; y++) {\n                for (x = 0; x < 5; x++) {\n                    if ((x + 5 * y) < (r / w) && (b < 16)) {\n                        result[b] = S[5 * x + y] & 0xFFFFFFFF;\n                        result[b + 1] = S[5 * x + y] / 0x100000000;\n                        b += 2;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /*\n    address constant KECCAK512 = address(uint160(0x10001));\n    function keccak512(bytes memory data) view private returns(bytes memory) {\n        (bool success, bytes memory hash) = KECCAK512.staticcall(data);\n        require(success, string(hash));\n        return hash;\n    }\n\n   function sha3_512(bytes memory data) view public returns(bytes memory) {\n       return keccak512(data);\n   }\n*/\n    function sha3_512(bytes memory data) internal pure returns (bytes memory) {\n        require(\n            data.length == 40 || data.length == 64,\n            \"sha512 only support 64 or 40 bytes\"\n        );\n        uint256 dataWords = data.length / 8;\n        uint256[9] memory M;\n        for (uint256 i = 0; i < dataWords; i++) {\n            uint256 dataOffset = i * 8;\n            M[i] =\n                uint256(uint8(data[dataOffset])) |\n                (uint256(uint8(data[dataOffset + 1])) << 8) |\n                (uint256(uint8(data[dataOffset + 2])) << 16) |\n                (uint256(uint8(data[dataOffset + 3])) << 24) |\n                (uint256(uint8(data[dataOffset + 4])) << 32) |\n                (uint256(uint8(data[dataOffset + 5])) << 40) |\n                (uint256(uint8(data[dataOffset + 6])) << 48) |\n                (uint256(uint8(data[dataOffset + 7])) << 56);\n        }\n        M[dataWords] = 1;\n        M[8] |= 0x8000000000000000;\n        uint256[16] memory result32 = sponge(M);\n        bytes memory resultBytes = new bytes(64);\n        for (uint32 i = 0; i < result32.length; i++) {\n            resultBytes.PutUint32(i * 4, uint32(result32[i]));\n        }\n        return resultBytes;\n    }\n}\n"
    },
    "contracts/ethash/Prime.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// from https://gist.github.com/lhartikk/c7bbc120aa8e58a0e0e781edb9a90497\nlibrary Prime {\n    // miller rabin test\n    function probablyPrime(uint256 n, uint256 prime)\n        internal\n        pure\n        returns (bool)\n    {\n        if (n == 2 || n == 3) {\n            return true;\n        }\n\n        if (n % 2 == 0 || n < 2) {\n            return false;\n        }\n\n        uint256[2] memory values = getValues(n);\n        uint256 s = values[0];\n        uint256 d = values[1];\n\n        uint256 x = fastModularExponentiation(prime, d, n);\n\n        if (x == 1 || x == n - 1) {\n            return true;\n        }\n\n        for (uint256 i = s - 1; i > 0; i--) {\n            x = fastModularExponentiation(x, 2, n);\n            if (x == 1) {\n                return false;\n            }\n            if (x == n - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function fastModularExponentiation(\n        uint256 a,\n        uint256 b,\n        uint256 n\n    ) internal pure returns (uint256) {\n        a = a % n;\n        uint256 result = 1;\n        uint256 x = a;\n\n        while (b > 0) {\n            uint256 leastSignificantBit = b % 2;\n            b = b / 2;\n\n            if (leastSignificantBit == 1) {\n                result = result * x;\n                result = result % n;\n            }\n            x = mul(x, x);\n            x = x % n;\n        }\n        return result;\n    }\n\n    // Write (n - 1) as 2^s * d\n    function getValues(uint256 n) internal pure returns (uint256[2] memory) {\n        uint256 s = 0;\n        uint256 d = n - 1;\n        while (d % 2 == 0) {\n            d = d / 2;\n            s++;\n        }\n        uint256[2] memory ret;\n        ret[0] = s;\n        ret[1] = d;\n        return ret;\n    }\n\n    // copied from openzeppelin\n    // https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProofUpgradeable {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/ethash/MerkelRoot.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract MerkelRoots {\n    uint64 constant epochStart = 411;\n    uint64 constant epochEnd = 411;\n    bytes constant ROOTS = \"\\xf8\\x7d\\x60\\x5d\\xd4\\xbd\\xaf\\xc3\\x9b\\x13\\xb4\\x5b\\x6a\\xbf\\x6b\\x92\\x11\\x96\\xb0\\xf3\\xb5\\xd7\\xc5\\x1b\\x31\\x82\\x06\\x64\\x10\\x4a\\x69\\x7d\";\n\n   function getRootHash(uint64 epoch) internal pure returns(bytes32 hash) {\n       bytes memory roots = ROOTS;\n       require(epoch >= epochStart && epoch <= epochEnd, \"epoch out of range!\");\n       uint256 index = epoch - epochStart + 1; // skip length\n       assembly{\n           hash := mload(add(roots, mul(index, 0x20)))\n       }\n   }\n}\n\n"
    },
    "contracts/mocks/MPTTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../lib/MPTValidatorV2.sol\";\n\ncontract MPTTest {\n    function validateProof(\n        bytes32 hashRoot,\n        uint256 paths,\n        bytes calldata proofs\n    ) external pure returns (bytes memory) {\n        return MPTValidatorV2.validateProof(hashRoot, paths, proofs);\n    }\n}\n"
    },
    "contracts/lib/MPT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./RLPReader.sol\";\n\n/*\n    Documentation:\n    - https://eth.wiki/en/fundamentals/patricia-tree\n    - https://github.com/blockchainsllc/in3/wiki/Ethereum-Verification-and-MerkleProof\n    - https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/\n*/\nlibrary MPT {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n\n    struct MerkleProof {\n        bytes32 expectedRoot;\n        bytes key;\n        bytes[] proof;\n        uint256 keyIndex;\n        uint256 proofIndex;\n        bytes expectedValue;\n    }\n\n    function verifyTrieProof(MerkleProof memory data)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory node = data.proof[data.proofIndex];\n        RLPReader.Iterator memory dec = RLPReader.toRlpItem(node).iterator();\n\n        if (data.keyIndex == 0) {\n            require(\n                keccak256(node) == data.expectedRoot,\n                \"verifyTrieProof root node hash invalid\"\n            );\n        } else if (node.length < 32) {\n            bytes32 root = bytes32(dec.next().toUint());\n            require(root == data.expectedRoot, \"verifyTrieProof < 32\");\n        } else {\n            require(\n                keccak256(node) == data.expectedRoot,\n                \"verifyTrieProof else\"\n            );\n        }\n\n        uint256 numberItems = RLPReader.numItems(dec.item);\n\n        // branch\n        if (numberItems == 17) {\n            return verifyTrieProofBranch(data);\n        }\n        // leaf / extension\n        else if (numberItems == 2) {\n            return verifyTrieProofLeafOrExtension(dec, data);\n        }\n\n        if (data.expectedValue.length == 0) return true;\n        else return false;\n    }\n\n    function verifyTrieProofBranch(MerkleProof memory data)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory node = data.proof[data.proofIndex];\n\n        if (data.keyIndex >= data.key.length) {\n            bytes memory item = RLPReader\n            .toRlpItem(node)\n            .toList()[16]\n            .toBytes();\n            if (keccak256(item) == keccak256(data.expectedValue)) {\n                return true;\n            }\n        } else {\n            uint256 index = uint256(uint8(data.key[data.keyIndex]));\n            bytes memory _newExpectedRoot = RLPReader\n            .toRlpItem(node)\n            .toList()[index]\n            .toBytes();\n\n            if (!(_newExpectedRoot.length == 0)) {\n                data.expectedRoot = b2b32(_newExpectedRoot);\n                data.keyIndex += 1;\n                data.proofIndex += 1;\n                return verifyTrieProof(data);\n            }\n        }\n\n        if (data.expectedValue.length == 0) return true;\n        else return false;\n    }\n\n    function verifyTrieProofLeafOrExtension(\n        RLPReader.Iterator memory dec,\n        MerkleProof memory data\n    ) internal pure returns (bool) {\n        bytes memory nodekey = dec.next().toBytes();\n        bytes memory nodevalue = dec.next().toBytes();\n        uint256 prefix;\n        assembly {\n            let first := shr(248, mload(add(nodekey, 32)))\n            prefix := shr(4, first)\n        }\n\n        if (prefix == 2) {\n            // leaf even\n            uint256 length = nodekey.length - 1;\n            bytes memory actualKey = sliceTransform(nodekey, 33, length, false);\n            bytes memory restKey = sliceTransform(\n                data.key,\n                32 + data.keyIndex,\n                length,\n                false\n            );\n            if (keccak256(data.expectedValue) == keccak256(nodevalue)) {\n                if (keccak256(actualKey) == keccak256(restKey)) return true;\n                if (keccak256(expandKeyEven(actualKey)) == keccak256(restKey))\n                    return true;\n            }\n        } else if (prefix == 3) {\n            // leaf odd\n            bytes memory actualKey = sliceTransform(\n                nodekey,\n                32,\n                nodekey.length,\n                true\n            );\n            bytes memory restKey = sliceTransform(\n                data.key,\n                32 + data.keyIndex,\n                data.key.length - data.keyIndex,\n                false\n            );\n            if (keccak256(data.expectedValue) == keccak256(nodevalue)) {\n                if (keccak256(actualKey) == keccak256(restKey)) return true;\n                if (keccak256(expandKeyOdd(actualKey)) == keccak256(restKey))\n                    return true;\n            }\n        } else if (prefix == 0) {\n            // extension even\n            uint256 extensionLength = nodekey.length - 1;\n            bytes memory shared_nibbles = sliceTransform(\n                nodekey,\n                33,\n                extensionLength,\n                false\n            );\n            bytes memory restKey = sliceTransform(\n                data.key,\n                32 + data.keyIndex,\n                extensionLength,\n                false\n            );\n            if (\n                keccak256(shared_nibbles) == keccak256(restKey) ||\n                keccak256(expandKeyEven(shared_nibbles)) == keccak256(restKey)\n            ) {\n                data.expectedRoot = b2b32(nodevalue);\n                data.keyIndex += extensionLength;\n                data.proofIndex += 1;\n                return verifyTrieProof(data);\n            }\n        } else if (prefix == 1) {\n            // extension odd\n            uint256 extensionLength = nodekey.length;\n            bytes memory shared_nibbles = sliceTransform(\n                nodekey,\n                32,\n                extensionLength,\n                true\n            );\n            bytes memory restKey = sliceTransform(\n                data.key,\n                32 + data.keyIndex,\n                extensionLength,\n                false\n            );\n            if (\n                keccak256(shared_nibbles) == keccak256(restKey) ||\n                keccak256(expandKeyEven(shared_nibbles)) == keccak256(restKey)\n            ) {\n                data.expectedRoot = b2b32(nodevalue);\n                data.keyIndex += extensionLength;\n                data.proofIndex += 1;\n                return verifyTrieProof(data);\n            }\n        } else {\n            revert(\"Invalid proof\");\n        }\n        if (data.expectedValue.length == 0) return true;\n        else return false;\n    }\n\n    function b2b32(bytes memory data) internal pure returns (bytes32 part) {\n        assembly {\n            part := mload(add(data, 32))\n        }\n    }\n\n    function sliceTransform(\n        bytes memory data,\n        uint256 start,\n        uint256 length,\n        bool removeFirstNibble\n    ) internal pure returns (bytes memory) {\n        uint256 slots = length / 32;\n        uint256 rest = (length % 32) * 8;\n        uint256 pos = 32;\n        uint256 si = 0;\n        uint256 source;\n        bytes memory newdata = new bytes(length);\n        assembly {\n            source := add(start, data)\n\n            if removeFirstNibble {\n                mstore(\n                    add(newdata, pos),\n                    shr(4, shl(4, mload(add(source, pos))))\n                )\n                si := 1\n                pos := add(pos, 32)\n            }\n\n            for {\n                let i := si\n            } lt(i, slots) {\n                i := add(i, 1)\n            } {\n                mstore(add(newdata, pos), mload(add(source, pos)))\n                pos := add(pos, 32)\n            }\n            mstore(\n                add(newdata, pos),\n                shl(rest, shr(rest, mload(add(source, pos))))\n            )\n        }\n    }\n\n    function getNibbles(bytes1 b)\n        internal\n        pure\n        returns (bytes1 nibble1, bytes1 nibble2)\n    {\n        assembly {\n            nibble1 := shr(4, b)\n            nibble2 := shr(4, shl(4, b))\n        }\n    }\n\n    function expandKeyEven(bytes memory data)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 length = data.length * 2;\n        bytes memory expanded = new bytes(length);\n\n        for (uint256 i = 0; i < data.length; i++) {\n            (bytes1 nibble1, bytes1 nibble2) = getNibbles(data[i]);\n            expanded[i * 2] = nibble1;\n            expanded[i * 2 + 1] = nibble2;\n        }\n        return expanded;\n    }\n\n    function expandKeyOdd(bytes memory data)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 length = data.length * 2 - 1;\n        bytes memory expanded = new bytes(length);\n        expanded[0] = data[0];\n\n        for (uint256 i = 1; i < data.length; i++) {\n            (bytes1 nibble1, bytes1 nibble2) = getNibbles(data[i]);\n            expanded[i * 2 - 1] = nibble1;\n            expanded[i * 2] = nibble2;\n        }\n        return expanded;\n    }\n}\n"
    },
    "contracts/lib/MMRWrapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./MMR.sol\";\nimport \"./RLPReader.sol\";\n\ncontract MMRWrapper {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using MMR for MMR.Tree;\n\n    MMR.Tree mTree;\n\n    function append(bytes memory data) public {\n        mTree.append(data);\n    }\n\n    function appendHash(bytes32 data) public {\n        mTree.appendHash(data);\n    }\n\n    function getHash(uint256 index) public view returns (bytes32 result) {\n        return mTree.hashOf(index);\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return mTree.getRoot();\n    }\n\n    function getSize() public view returns (uint256) {\n        return mTree.getSize();\n    }\n\n    function getMerkleProof(uint256 index)\n        public\n        view\n        returns (\n            bytes32 root,\n            uint256 width,\n            bytes32[] memory peakBagging,\n            bytes32[] memory siblings\n        )\n    {\n        return mTree.getMerkleProof(index);\n    }\n\n    function deserialize(bytes memory rlpdata) public {\n        RLPReader.RLPItem memory stacks = rlpdata.toRlpItem();\n        RLPReader.RLPItem[] memory mmrHashes = stacks.toList();\n        for (uint256 i = 0; i < mmrHashes.length; i++) {\n            mTree.updateTree(bytes32(mmrHashes[i].toUint()));\n        }\n    }\n\n    function addTree(bytes32[] memory itemHashes, uint256 width) public {\n        for (uint256 i = 0; i < itemHashes.length; i++) {\n            mTree.updateTree(itemHashes[i]);\n        }\n        mTree.updateRoot(width);\n    }\n}\n"
    },
    "contracts/lib/MMR.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @author Wanseob Lim <email@wanseob.com>\n * @title Merkle Mountain Range solidity library\n *\n * @dev The index of this MMR implementation starts from 1 not 0.\n *      And it uses keccak256 for its hash function instead of blake2b\n */\nlibrary MMR {\n    struct Tree {\n        bytes32 root;\n        uint256 size;\n        uint256 width;\n        mapping(uint256 => bytes32) hashes;\n        mapping(bytes32 => bytes) data;\n    }\n\n    /**\n     * @dev This only stores the hashed value of the leaf.\n     *      If you need to retrieve the detail data later, use a map to store them.\n     */\n    function append(Tree storage tree, bytes memory data) public {\n        // Hash the leaf node first\n        bytes32 dataHash = keccak256(data);\n        if (keccak256(tree.data[dataHash]) != dataHash) {\n            tree.data[dataHash] = data;\n        }\n        bytes32 leaf = hashLeaf(tree.size + 1, dataHash);\n        // Put the hashed leaf to the map\n        tree.hashes[tree.size + 1] = leaf;\n        tree.width += 1;\n        // Find peaks for the enlarged tree\n        uint256[] memory peakIndexes = getPeakIndexes(tree.width);\n        // The right most peak's value is the new size of the updated tree\n        tree.size = getSize(tree.width);\n        // Starting from the left-most peak, get all peak hashes using _getOrCreateNode() function.\n        bytes32[] memory peaks = new bytes32[](peakIndexes.length);\n        for (uint256 i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = _getOrCreateNode(tree, peakIndexes[i]);\n        }\n        // Create the root hash and update the tree\n        tree.root = peakBagging(tree.width, peaks);\n    }\n\n    function hashOf(Tree storage tree, uint256 index)\n        public\n        view\n        returns (bytes32)\n    {\n        return tree.hashes[index];\n    }\n\n    /**\n     * @dev This only stores the hashed value of the leaf.\n     *      If you need to retrieve the detail data later, use a map to store them.\n     */\n    function appendHash(Tree storage tree, bytes32 dataHash) public {\n        // Put the hashed leaf to the map\n        tree.hashes[tree.size + 1] = dataHash;\n        tree.width += 1;\n        // Find peaks for the enlarged tree\n        uint256[] memory peakIndexes = getPeakIndexes(tree.width);\n        // The right most peak's value is the new size of the updated tree\n        tree.size = getSize(tree.width);\n        // Starting from the left-most peak, get all peak hashes using _getOrCreateNode() function.\n        bytes32[] memory peaks = new bytes32[](peakIndexes.length);\n        for (uint256 i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = _getOrCreateNode(tree, peakIndexes[i]);\n        }\n        // Create the root hash and update the tree\n        tree.root = peakBagging(tree.width, peaks);\n    }\n\n    /**\n     * @dev This only stores the hashed value of the leaf.\n     *      If you need to retrieve the detail data later, use a map to store them.\n     */\n    function updateTree(Tree storage tree, bytes32 dataHash) public {\n        tree.size = tree.size + 1;\n        tree.hashes[tree.size] = dataHash;\n    }\n\n    function updateRoot(Tree storage tree, uint256 width) public {\n        tree.width = width;\n        // Find peaks for the enlarged tree\n        uint256[] memory peakIndexes = getPeakIndexes(tree.width);\n        // The right most peak's value is the new size of the updated tree\n        tree.size = getSize(tree.width);\n        // Starting from the left-most peak, get all peak hashes using _getOrCreateNode() function.\n        bytes32[] memory peaks = new bytes32[](peakIndexes.length);\n        for (uint256 i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = _getOrCreateNode(tree, peakIndexes[i]);\n        }\n        // Create the root hash and update the tree\n        tree.root = peakBagging(tree.width, peaks);\n    }\n\n    function getPeaks(Tree storage tree)\n        public\n        view\n        returns (bytes32[] memory peaks)\n    {\n        // Find peaks for the enlarged tree\n        uint256[] memory peakNodeIndexes = getPeakIndexes(tree.width);\n        // Starting from the left-most peak, get all peak hashes using _getOrCreateNode() function.\n        peaks = new bytes32[](peakNodeIndexes.length);\n        for (uint256 i = 0; i < peakNodeIndexes.length; i++) {\n            peaks[i] = tree.hashes[peakNodeIndexes[i]];\n        }\n        return peaks;\n    }\n\n    function getLeafIndex(uint256 width) public pure returns (uint256) {\n        if (width % 2 == 1) {\n            return getSize(width);\n        } else {\n            return getSize(width - 1) + 1;\n        }\n    }\n\n    function getSize(uint256 width) public pure returns (uint256) {\n        return (width << 1) - numOfPeaks(width);\n    }\n\n    /**\n     * @dev It returns the root value of the tree\n     */\n    function getRoot(Tree storage tree) public view returns (bytes32) {\n        return tree.root;\n    }\n\n    /**\n     * @dev It returns the size of the tree\n     */\n    function getSize(Tree storage tree) public view returns (uint256) {\n        return tree.size;\n    }\n\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1\n     */\n    function getNode(Tree storage tree, uint256 index)\n        public\n        view\n        returns (bytes32)\n    {\n        return tree.hashes[index];\n    }\n\n    /**\n     * @dev It returns a merkle proof for a leaf. Note that the index starts from 1\n     */\n    function getMerkleProof(Tree storage tree, uint256 index)\n        public\n        view\n        returns (\n            bytes32 root,\n            uint256 width,\n            bytes32[] memory peakBagging,\n            bytes32[] memory siblings\n        )\n    {\n        require(index < tree.size, \"Out of range\");\n        require(isLeaf(index), \"Not a leaf\");\n\n        root = tree.root;\n        width = tree.width;\n        // Find all peaks for bagging\n        uint256[] memory peaks = getPeakIndexes(tree.width);\n\n        peakBagging = new bytes32[](peaks.length);\n        uint256 cursor;\n        for (uint256 i = 0; i < peaks.length; i++) {\n            // Collect the hash of all peaks\n            peakBagging[i] = tree.hashes[peaks[i]];\n            // Find the peak which includes the target index\n            if (peaks[i] >= index && cursor == 0) {\n                cursor = peaks[i];\n            }\n        }\n        uint256 left;\n        uint256 right;\n\n        // Get hashes of the siblings in the mountain which the index belongs to.\n        // It moves the cursor from the summit of the mountain down to the target index\n        uint8 height = heightAt(cursor);\n        siblings = new bytes32[](height - 1);\n        while (cursor != index) {\n            height--;\n            (left, right) = getChildren(cursor);\n            // Move the cursor down to the left side or right side\n            cursor = index <= left ? left : right;\n            // Remaining node is the sibling\n            siblings[height - 1] = tree.hashes[index <= left ? right : left];\n        }\n    }\n\n    function rollUp(\n        bytes32 root,\n        uint256 width,\n        bytes32[] memory peaks,\n        bytes32[] memory itemHashes\n    ) public pure returns (bytes32 newRoot) {\n        // Check the root equals the peak bagging hash\n        require(\n            root == peakBagging(width, peaks),\n            \"Invalid root hash from the peaks\"\n        );\n        uint256 tmpWidth = width;\n        bytes32[255] memory tmpPeakMap = peaksToPeakMap(width, peaks);\n        for (uint256 i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return peakBagging(tmpWidth, peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n\n    function peakBagging(uint256 width, bytes32[] memory peaks)\n        public\n        pure\n        returns (bytes32)\n    {\n        uint256 size = getSize(width);\n        require(\n            numOfPeaks(width) == peaks.length,\n            \"Received invalid number of peaks\"\n        );\n        return\n            // keccak256(\n            //     abi.encodePacked(size, keccak256(abi.encodePacked(size, peaks)))\n            // );\n            keccak256(\n                abi.encodePacked(peaks)\n            );\n    }\n\n    function peaksToPeakMap(uint256 width, bytes32[] memory peaks)\n        public\n        pure\n        returns (bytes32[255] memory peakMap)\n    {\n        uint256 bitIndex;\n        uint256 peakRef;\n        uint256 count = peaks.length;\n        for (uint256 height = 1; height <= 255; height++) {\n            // Index starts from the right most bit\n            bitIndex = 255 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) != 0) {\n                peakMap[bitIndex] = peaks[--count];\n            } else {\n                peakMap[bitIndex] = bytes32(0);\n            }\n        }\n        require(count == 0, \"Invalid number of peaks\");\n    }\n\n    function peakMapToPeaks(uint256 width, bytes32[255] memory peakMap)\n        public\n        pure\n        returns (bytes32[] memory peaks)\n    {\n        uint256 arrLength = numOfPeaks(width);\n        peaks = new bytes32[](arrLength);\n        uint256 count = 0;\n        for (uint256 i = 0; i < 255; i++) {\n            if (peakMap[i] != bytes32(0)) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        require(count == arrLength, \"Invalid number of peaks\");\n    }\n\n    function peakUpdate(\n        uint256 width,\n        bytes32[255] memory prevPeakMap,\n        bytes32 itemHash\n    ) public pure returns (bytes32[255] memory nextPeakMap) {\n        uint256 newWidth = width + 1;\n        uint256 cursorIndex = getLeafIndex(newWidth);\n        bytes32 cursorNode = itemHash; //hashLeaf(cursorIndex, itemHash);\n        uint256 bitIndex;\n        uint256 peakRef;\n        bool prevPeakExist;\n        bool nextPeakExist;\n        bool obtained;\n\n        for (uint256 height = 1; height <= 255; height++) {\n            // Index starts from the right most bit\n            bitIndex = 255 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) != 0;\n                nextPeakExist = (newWidth & peakRef) != 0;\n\n                // Get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = hashBranch(prevPeakMap[bitIndex], cursorNode);\n                }\n                // If new peak exists for the bit index\n                if (nextPeakExist) {\n                    // If prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    } else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                } else {\n                    nextPeakMap[bitIndex] = bytes32(0);\n                }\n            }\n        }\n    }\n\n    /** Pure functions */\n\n    /**\n     * @dev It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    function inclusionProof(\n        bytes32 root,\n        uint256 width,\n        uint256 index,\n        bytes memory value,\n        bytes32[] memory peaks,\n        bytes32[] memory siblings\n    ) public pure returns (bool) {\n        bytes32 value32;\n\n        assembly {\n            value32 := mload(add(value, 32))\n        }\n        uint256 size = getSize(width);\n        require(size >= index, \"Index is out of range\");\n        // Check the root equals the peak bagging hash\n        require(\n            root ==\n                // keccak256(\n                //     abi.encodePacked(\n                //         size,\n                //         keccak256(abi.encodePacked(size, peaks))\n                //     )\n                // ),\n                keccak256(\n                    abi.encodePacked(\n                        peaks\n                    )\n                ),\n            \"Invalid root hash from the peaks\"\n        );\n\n        // Find the mountain where the target index belongs to\n        uint256 cursor;\n        bytes32 targetPeak;\n        uint256[] memory peakIndexes = getPeakIndexes(width);\n        for (uint256 i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i]-1 >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i]-1;\n                break;\n            }\n        }\n        require(targetPeak != bytes32(0), \"Target is not found\");\n\n        // Find the path climbing down\n        uint256[] memory path = new uint256[](siblings.length + 1);\n        uint256 left;\n        uint256 right;\n        uint8 height = uint8(siblings.length) + 1;\n        while (height > 0) {\n            // Record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor == index) {\n                // On the leaf node. Stop climbing down\n                break;\n            } else {\n                // On the parent node. Go left or right\n                (left, right) = getChildren(cursor+1);\n                cursor = index > (left-1) ? (right-1) : (left-1);\n                continue;\n            }\n        }\n\n        // Calculate the summit hash climbing up again\n        bytes32 node;\n        while (height < path.length) {\n            // Move cursor\n            cursor = path[height];\n            if (height == 0) {\n                // cursor is on the leaf\n                node = value32;//hashLeaf(cursor, keccak256(value));\n            } else if (cursor - 1 == path[height - 1]) {\n                // cursor is on a parent and a sibling is on the left\n                node = hashBranch(siblings[height - 1], node);\n            } else {\n                // cursor is on a parent and a sibling is on the right\n                node = hashBranch(node, siblings[height - 1]);\n            }\n            // Climb up\n            height++;\n        }\n\n        // Computed hash value of the summit should equal to the target peak hash\n        require(node == targetPeak, \"Hashed peak is invalid\");\n        return true;\n    }\n\n    /**\n     * @dev It returns the hash a parent node with hash(M | Left child | Right child)\n     *      M is the index of the node\n     */\n    function hashBranch(bytes32 left, bytes32 right)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(left, right));\n    }\n\n    /**\n     * @dev it returns the hash of a leaf node with hash(M | DATA )\n     *      M is the index of the node\n     */\n    function hashLeaf(uint256 index, bytes32 dataHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        // return keccak256(abi.encodePacked(index, dataHash));\n        return keccak256(abi.encodePacked(dataHash));\n    }\n\n    /**\n     * @dev It returns the height of the highest peak\n     */\n    function mountainHeight(uint256 size) public pure returns (uint8) {\n        uint8 height = 1;\n        while (uint256(1) << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n\n    /**\n     * @dev It returns the height of the index\n     */\n    function heightAt(uint256 index) public pure returns (uint8 height) {\n        uint256 reducedIndex = index;\n        uint256 peakIndex;\n        // If an index has a left mountain subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (uint256(1) << height) - 1;\n            height = mountainHeight(reducedIndex);\n            peakIndex = (uint256(1) << height) - 1;\n        }\n        // Index is on the right slope\n        height = height - uint8((peakIndex - reducedIndex));\n    }\n\n    /**\n     * @dev It returns whether the index is the leaf node or not\n     */\n    function isLeaf(uint256 index) public pure returns (bool) {\n        return heightAt(index) == 1;\n    }\n\n    /**\n     * @dev It returns the children when it is a parent node\n     */\n    function getChildren(uint256 index)\n        public\n        pure\n        returns (uint256 left, uint256 right)\n    {\n        left = index - (uint256(1) << (heightAt(index) - 1));\n        right = index - 1;\n        require(left != right, \"Not a parent\");\n    }\n\n    /**\n     * @dev It returns all peaks of the smallest merkle mountain range tree which includes\n     *      the given index(size)\n     */\n    function getPeakIndexes(uint256 width)\n        public\n        pure\n        returns (uint256[] memory peakIndexes)\n    {\n        peakIndexes = new uint256[](numOfPeaks(width));\n        uint256 count;\n        uint256 size;\n        for (uint256 i = 255; i > 0; i--) {\n            if (width & (1 << (i - 1)) != 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n            }\n        }\n        require(count == peakIndexes.length, \"Invalid bit calculation\");\n    }\n\n    function numOfPeaks(uint256 width) public pure returns (uint256 num) {\n        uint256 bits = width;\n        while (bits > 0) {\n            if (bits % 2 == 1) num++;\n            bits = bits >> 1;\n        }\n        return num;\n    }\n\n    /**\n     * @dev It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function\n     */\n    function _getOrCreateNode(Tree storage tree, uint256 index)\n        private\n        returns (bytes32)\n    {\n        require(index <= tree.size, \"Out of range\");\n        if (tree.hashes[index] == bytes32(0)) {\n            (uint256 leftIndex, uint256 rightIndex) = getChildren(index);\n            bytes32 leftHash = _getOrCreateNode(tree, leftIndex);\n            bytes32 rightHash = _getOrCreateNode(tree, rightIndex);\n            tree.hashes[index] = hashBranch(leftHash, rightHash);\n        }\n        return tree.hashes[index];\n    }\n}\n"
    },
    "contracts/mocks/HarmonyProverTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HarmonyProver.sol\";\n\ncontract HarmonyProverTest {\n    function validateProof(\n        bytes32 hashRoot,\n        uint256 paths,\n        bytes calldata proofs\n    ) external pure returns (bytes memory) {\n        HarmonyProver.MerkleProof memory proof = HarmonyProver.MerkleProof(\n            hashRoot,\n            paths,\n            proofs\n        );\n        return HarmonyProver.verifyTrieProof(proof);\n    }\n\n    function validateHeader(\n        HarmonyParser.BlockHeader memory header,\n        MMRVerifier.MMRProof memory proof\n    ) external pure returns (bool valid, string memory reason) {\n        return HarmonyProver.verifyHeader(header, proof);\n    }\n}\n"
    },
    "contracts/test_contracts/TestEthLightClient.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"../EthereumLightClient.sol\";\n\n/// @title Ethereum light client\ncontract TesterEthereumLightClient is EthereumLightClient {\n    using SafeMathUpgradeable for uint256;\n\n    function dummmyAddBlockHeader(\n        uint256 parentHash,\n        uint256 difficulty,\n        uint256 blockHash\n    ) external returns (bool) {\n        StoredBlockHeader memory storedBlock = StoredBlockHeader({\n            parentHash: parentHash,\n            stateRoot: 0,\n            transactionsRoot: 0,\n            receiptsRoot: 0,\n            number: 0,\n            difficulty: difficulty,\n            totalDifficulty: blocks[parentHash].totalDifficulty.add(difficulty),\n            time: 0,\n            hash: blockHash\n        });\n\n        blocks[blockHash] = storedBlock;\n        blockExisting[blockHash] = true;\n        // verifiedBlocks[blockHash] = true;\n\n        //Check if this block is ahead of the canonical head\n        if (parentHash == canonicalHead) {\n            canonicalHead = blockHash;\n            canonicalBlocks[blockHash] = true;\n        }\n        //Check if the canonical chain needs to be replaced by another fork\n        else if (\n            blocks[canonicalHead].totalDifficulty <\n            blocks[blockHash].totalDifficulty\n        ) {\n            _updateCanonicalChain(blockHash);\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/EthereumProver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./lib/RLPReader.sol\";\n\nlibrary EthereumProver {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    function isEmpty(RLPReader.RLPItem memory item)\n        internal\n        pure\n        returns (bool)\n    {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return\n            b == 0x80 || /* empty byte string */\n            b == 0xc0; /* empty list */\n    }\n\n    function isEmptyBytesequence(RLPReader.RLPItem memory item)\n        internal\n        pure\n        returns (bool)\n    {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return b == 0x80; /* empty byte string */\n    }\n\n    function decodeNibbles(\n        bytes memory compact,\n        uint256 skipNibbles,\n        uint256 append16\n    ) internal pure returns (bytes memory nibbles) {\n        require(compact.length > 0);\n\n        uint256 length = compact.length * 2;\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length + append16);\n        if (append16 == 1) nibbles[nibbles.length - 1] = bytes1(uint8(0x10));\n        uint256 nibblesLength = 0;\n\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1(\n                    (uint8(compact[i / 2]) >> 4) & 0xF\n                );\n            } else {\n                nibbles[nibblesLength] = bytes1(\n                    (uint8(compact[i / 2]) >> 0) & 0xF\n                );\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength + append16 == nibbles.length);\n    }\n\n    function merklePatriciaCompactDecode(bytes memory compact)\n        internal\n        pure\n        returns (bool isLeaf, bytes memory nibbles)\n    {\n        require(compact.length > 0);\n        uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\n        uint256 skipNibbles;\n        if (first_nibble == 0) {\n            skipNibbles = 2;\n            isLeaf = false;\n        } else if (first_nibble == 1) {\n            skipNibbles = 1;\n            isLeaf = false;\n        } else if (first_nibble == 2) {\n            skipNibbles = 2;\n            isLeaf = true;\n        } else if (first_nibble == 3) {\n            skipNibbles = 1;\n            isLeaf = true;\n        } else {\n            // Not supposed to happen!\n            revert();\n        }\n        return (isLeaf, decodeNibbles(compact, skipNibbles, isLeaf ? 1 : 0));\n    }\n\n    function sharedPrefixLength(\n        uint256 xsOffset,\n        bytes memory xs,\n        bytes memory ys\n    ) internal pure returns (uint256) {\n        uint256 i;\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n            if (xs[i + xsOffset] != ys[i]) {\n                return i;\n            }\n        }\n        return i;\n    }\n\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the input.\n    ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\n    ///      *variable-length* hashes: If the input is shorter than 32 bytes,\n    ///      the MPT hash is the input. Otherwise, the MPT hash is the\n    ///      Keccak-256 hash of the input.\n    ///      The easiest way to compare variable-length byte sequences is\n    ///      to compare their Keccak-256 hashes.\n    /// @param input The byte sequence to be hashed.\n    /// @return Keccak-256(MPT-hash(input))\n    function mptHashHash(bytes memory input) internal pure returns (bytes32) {\n        if (input.length < 32) {\n            return keccak256(input);\n        } else {\n            return\n                keccak256(abi.encodePacked(keccak256(abi.encodePacked(input))));\n        }\n    }\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of some key-value pair in the\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n    ///      the exclusion of a key from the trie, an empty byte array is\n    ///      returned.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n    /// @param mptKey is the key (consisting of nibbles) of the node whose\n    ///        inclusion/exclusion we are proving.\n    /// @param proof is decoded to stack of MPT nodes (starting with the root) that\n    ///        need to be traversed during verification.\n    /// @return value whose inclusion is proved or an empty byte array for\n    ///         a proof of exclusion\n    function validateMPTProof(\n        bytes32 rootHash,\n        bytes memory mptKey,\n        bytes memory proof\n    ) internal pure returns (bytes memory value) {\n        RLPReader.RLPItem[] memory stack = proof.toRlpItem().toList();\n        mptKey = decodeNibbles(mptKey, 0, 1);\n        uint256 mptKeyOffset = 0;\n\n        bytes32 nodeHashHash;\n        bytes memory rlpNode;\n        RLPReader.RLPItem[] memory node;\n\n        RLPReader.RLPItem memory rlpValue;\n\n        if (stack.length == 0) {\n            // Root hash of empty Merkle-Patricia-Trie\n            require(\n                rootHash ==\n                    0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\n            );\n            return new bytes(0);\n        }\n\n        // Traverse stack of nodes starting at root.\n        for (uint256 i = 0; i < stack.length; i++) {\n            // We use the fact that an rlp encoded list consists of some\n            // encoding of its length plus the concatenation of its\n            // *rlp-encoded* items.\n            rlpNode = stack[i].toRlpBytes();\n            // The root node is hashed with Keccak-256 ...\n            if (i == 0 && rootHash != keccak256(rlpNode)) {\n                revert();\n            }\n            // ... whereas all other nodes are hashed with the MPT\n            // hash function.\n            if (i != 0 && nodeHashHash != mptHashHash(rlpNode)) {\n                revert();\n            }\n            // We verified that stack[i] has the correct hash, so we\n            // may safely decode it.\n            node = stack[i].toList();\n\n            if (node.length == 2) {\n                // Extension or Leaf node\n\n                bool isLeaf;\n                bytes memory nodeKey;\n                (isLeaf, nodeKey) = merklePatriciaCompactDecode(\n                    node[0].toBytes()\n                );\n\n                uint256 prefixLength = sharedPrefixLength(\n                    mptKeyOffset,\n                    mptKey,\n                    nodeKey\n                );\n                mptKeyOffset += prefixLength;\n\n                if (prefixLength < nodeKey.length) {\n                    // Proof claims divergent extension or leaf. (Only\n                    // relevant for proofs of exclusion.)\n                    // An Extension/Leaf node is divergent iff it \"skips\" over\n                    // the point at which a Branch node should have been had the\n                    // excluded key been included in the trie.\n                    // Example: Imagine a proof of exclusion for path [1, 4],\n                    // where the current node is a Leaf node with\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\n                    // should have been a Branch node at [1] with a child\n                    // at 3 and a child at 4.\n\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // divergent node must come last in proof\n                        revert();\n                    }\n\n                    return new bytes(0);\n                }\n\n                if (isLeaf) {\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // leaf node must come last in proof\n                        revert();\n                    }\n\n                    if (mptKeyOffset < mptKey.length) {\n                        return new bytes(0);\n                    }\n\n                    rlpValue = node[1];\n                    return rlpValue.toBytes();\n                } else {\n                    // extension\n                    // Sanity check\n                    if (i == stack.length - 1) {\n                        // shouldn't be at last level\n                        revert();\n                    }\n\n                    if (!node[1].isList()) {\n                        // rlp(child) was at least 32 bytes. node[1] contains\n                        // Keccak256(rlp(child)).\n                        nodeHashHash = keccak256(node[1].toBytes());\n                    } else {\n                        // rlp(child) was at less than 32 bytes. node[1] contains\n                        // rlp(child).\n                        nodeHashHash = keccak256(node[1].toRlpBytes());\n                    }\n                }\n            } else if (node.length == 17) {\n                // Branch node\n\n                if (mptKeyOffset != mptKey.length) {\n                    // we haven't consumed the entire path, so we need to look at a child\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\n                    mptKeyOffset += 1;\n                    if (nibble >= 16) {\n                        // each element of the path has to be a nibble\n                        revert();\n                    }\n\n                    if (isEmptyBytesequence(node[nibble])) {\n                        // Sanity\n                        if (i != stack.length - 1) {\n                            // leaf node should be at last level\n                            revert();\n                        }\n\n                        return new bytes(0);\n                    } else if (!node[nibble].isList()) {\n                        nodeHashHash = keccak256(node[nibble].toBytes());\n                    } else {\n                        nodeHashHash = keccak256(node[nibble].toRlpBytes());\n                    }\n                } else {\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n                    // Sanity\n                    if (i != stack.length - 1) {\n                        // should be at last level\n                        revert();\n                    }\n\n                    return node[16].toBytes();\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/FaucetToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract FaucetToken is ERC20Upgradeable {\n    function initialize(\n        string memory name,\n        string memory symbol\n        // uint8 decimals\n    ) external initializer {\n        __ERC20_init(name, symbol);\n        // _setupDecimals(decimals);\n    }\n\n    function mint() public returns (bool) {\n        uint256 UNIT = 10**uint256(decimals());\n        _mint(msg.sender, 10000 * UNIT);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}