"use strict";
/**
 * @packageDocumentation
 * @module harmony-contract
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractMethod = void 0;
var tslib_1 = require("tslib");
var transaction_1 = require("@harmony-js/transaction");
var network_1 = require("@harmony-js/network");
var utils_1 = require("@harmony-js/utils");
var crypto_1 = require("@harmony-js/crypto");
var encoder_1 = require("../utils/encoder");
var status_1 = require("../utils/status");
// todo: have to judge if it is contractConstructor
var ContractMethod = /** @class */ (function () {
    function ContractMethod(methodKey, params, abiItem, contract) {
        this.methodKey = methodKey;
        this.contract = contract;
        this.wallet = contract.wallet;
        this.params = params;
        this.abiItem = abiItem;
        this.transaction = this.createTransaction();
        this.callPayload = undefined;
        this.callResponse = undefined;
    }
    ContractMethod.prototype.send = function (params) {
        var _this = this;
        try {
            var gasLimit_1;
            var signTxs_1 = function () {
                _this.transaction = _this.transaction.map(function (tx) {
                    return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, tx), params), { gasLimit: gasLimit_1 });
                });
                var updateNonce = params && params.nonce !== undefined ? false : true;
                _this.signTransaction(updateNonce).then(function (signed) {
                    _this.sendTransaction(signed).then(function (sent) {
                        var _a = tslib_1.__read(sent, 2), txn = _a[0], id = _a[1];
                        _this.transaction = txn;
                        _this.contract.transaction = _this.transaction;
                        _this.confirm(id).then(function () {
                            _this.transaction.emitter.resolve(_this.contract);
                        });
                    });
                });
            };
            // tslint:disable-next-line: prefer-conditional-expression
            if (params !== undefined) {
                gasLimit_1 = params.gas || params.gasLimit;
            }
            if (gasLimit_1 === undefined) {
                this.estimateGas().then(function (gas) {
                    gasLimit_1 = utils_1.hexToBN(gas);
                    signTxs_1();
                });
            }
            else {
                signTxs_1();
            }
            return this.transaction.emitter;
        }
        catch (error) {
            throw error;
        }
    };
    ContractMethod.prototype.call = function (options, blockNumber) {
        if (blockNumber === void 0) { blockNumber = 'latest'; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var shardID, nonce_1, gasLimit_2, from_1, keys, txPayload, sendPayload, keys_1, keys_1_1, key, result, error_1;
            var e_1, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        options = tslib_1.__assign(tslib_1.__assign({}, this.contract.options), options);
                        shardID = options !== undefined && options.shardID !== undefined
                            ? options.shardID
                            : this.contract.shardID;
                        nonce_1 = '0x0';
                        // tslint:disable-next-line: prefer-conditional-expression
                        if (options !== undefined) {
                            gasLimit_2 = options.gas || options.gasLimit;
                        }
                        else {
                            gasLimit_2 = '21000000';
                        }
                        // tslint:disable-next-line: prefer-conditional-expression
                        if (this.wallet.signer) {
                            from_1 = options && options.from ? options.from : this.wallet.signer.address;
                        }
                        else {
                            from_1 =
                                options && options.from ? options.from : '0x0000000000000000000000000000000000000000';
                        }
                        this.transaction = this.transaction.map(function (tx) {
                            return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, tx), options), { from: from_1 || tx.from, gasPrice: options ? options.gasPrice : tx.gasPrice, gasLimit: gasLimit_2 || tx.gasLimit, nonce: Number.parseInt(utils_1.hexToNumber(nonce_1), 10) });
                        });
                        keys = Object.keys(this.transaction.txPayload);
                        txPayload = this.transaction.txPayload;
                        sendPayload = {};
                        try {
                            for (keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                                key = keys_1_1.value;
                                // tslint:disable-next-line: no-unused-expression
                                if (txPayload[key] !== '0x') {
                                    sendPayload[key] = txPayload[key];
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        // tslint:disable-line
                        return [4 /*yield*/, this.wallet.messenger.send("hmy_call" /* Call */, [sendPayload, blockNumber], 
                            // tslint:disable-line
                            this.wallet.messenger.chainPrefix, shardID)];
                    case 1:
                        result = 
                        // tslint:disable-line
                        _b.sent();
                        this.callPayload = sendPayload;
                        this.callResponse = result;
                        if (result.isError()) {
                            throw result.message;
                        }
                        else if (result.isResult()) {
                            if (result.result === null) {
                                return [2 /*return*/, this.afterCall(undefined)];
                            }
                            else {
                                return [2 /*return*/, this.afterCall(result.result)];
                            }
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _b.sent();
                        throw error_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ContractMethod.prototype.estimateGas = function (params) {
        if (params === void 0) { params = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, _a, error_2;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        if (params.from === undefined && this.contract.options.from !== undefined) {
                            params.from = this.contract.options.from;
                        }
                        if (params.to === undefined && this.transaction.txParams.to !== undefined) {
                            params.to = this.transaction.txParams.to;
                        }
                        if (params.data === undefined) {
                            params.data = this.transaction.txParams.data;
                        }
                        if (params.gasPrice === undefined && this.contract.options.gasPrice !== undefined) {
                            params.gasPrice = this.contract.options.gasPrice;
                        }
                        if (this.methodKey === 'contractConstructor') {
                            delete params.to;
                        }
                        _a = network_1.getResultForData;
                        // tslint:disable-line
                        return [4 /*yield*/, this.wallet.messenger.send("hmy_estimateGas" /* EstimateGas */, [params])];
                    case 1:
                        result = _a.apply(void 0, [
                            // tslint:disable-line
                            _b.sent()]);
                        if (result.responseType === 'error') {
                            throw result.message;
                        }
                        else if (result.responseType === 'raw') {
                            throw new Error('Get estimateGas fail');
                        }
                        else {
                            return [2 /*return*/, result];
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_2 = _b.sent();
                        throw error_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ContractMethod.prototype.encodeABI = function () {
        return encoder_1.methodEncoder(this.contract.abiCoder, this.abiItem, this.contract.data);
    };
    ContractMethod.prototype.debug = function () {
        return {
            callResponse: this.callResponse,
            callPayload: this.callPayload,
        };
    };
    ContractMethod.prototype.signTransaction = function (updateNonce) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var signed, _a, error_3;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, , 6]);
                        signed = void 0;
                        if (!this.wallet.signer) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.wallet.signTransaction(this.transaction, this.wallet.signer, undefined, updateNonce, 'rlp', 'latest')];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.wallet.signTransaction(this.transaction, updateNonce, 'rlp', 'latest')];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        signed = _a;
                        if (this.methodKey === 'contractConstructor') {
                            this.contract.address = transaction_1.TransactionFactory.getContractAddress(signed);
                        }
                        this.contract.setStatus(status_1.ContractStatus.SIGNED);
                        return [2 /*return*/, signed];
                    case 5:
                        error_3 = _b.sent();
                        throw error_3;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    ContractMethod.prototype.sendTransaction = function (signed) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, error_4;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, signed.sendTransaction()];
                    case 1:
                        result = _a.sent();
                        this.contract.setStatus(status_1.ContractStatus.SENT);
                        return [2 /*return*/, result];
                    case 2:
                        error_4 = _a.sent();
                        throw error_4;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ContractMethod.prototype.confirm = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, error_5;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.transaction.confirm(id, 20, 1000, this.transaction ? this.transaction.txParams.shardID : this.contract.shardID)];
                    case 1:
                        result = _a.sent();
                        if (result.receipt && result.txStatus === "CONFIRMED" /* CONFIRMED */) {
                            if (this.methodKey === 'contractConstructor') {
                                this.contract.setStatus(status_1.ContractStatus.DEPLOYED);
                            }
                            else {
                                this.contract.setStatus(status_1.ContractStatus.CALLED);
                            }
                        }
                        else {
                            this.contract.setStatus(status_1.ContractStatus.REJECTED);
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_5 = _a.sent();
                        throw error_5;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ContractMethod.prototype.createTransaction = function () {
        if (this.wallet.messenger) {
            if (this.methodKey === 'contractConstructor') {
                // tslint:disable-next-line: no-string-literal
                this.contract.data = this.params[0]['data'] || '0x';
                this.abiItem.contractMethodParameters =
                    // tslint:disable-next-line: no-string-literal
                    this.params[0]['arguments'] || [];
            }
            else {
                this.abiItem.contractMethodParameters = this.params || [];
            }
            var txObject = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.contract.options), this.params[0]), { to: this.methodKey === 'contractConstructor'
                    ? '0x'
                    : crypto_1.getAddress(this.contract.address).checksum, data: this.encodeABI() });
            // tslint:disable-line
            var result = new transaction_1.TransactionFactory(this.wallet.messenger).newTx(txObject);
            return result;
        }
        else {
            throw new Error('Messenger is not found');
        }
    };
    ContractMethod.prototype.afterCall = function (response) {
        if (!response || response === '0x') {
            return null;
        }
        var outputs = this.abiItem.getOutputs();
        if (outputs.length > 1) {
            return this.contract.abiCoder.decodeParameters(outputs, response);
        }
        return this.contract.abiCoder.decodeParameter(outputs[0], response);
        // return outputs;
    };
    return ContractMethod;
}());
exports.ContractMethod = ContractMethod;
//# sourceMappingURL=method.js.map