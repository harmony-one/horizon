/**
 * Test Banner
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@harmony-js/utils');
var crypto = require('@harmony-js/crypto');
var network = require('@harmony-js/network');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/**
 * @packageDocumentation
 * @module harmony-transaction
 * @hidden
 */
var transactionFields = [
    { name: 'nonce', length: 32, fix: false },
    { name: 'gasPrice', length: 32, fix: false, transform: 'hex' },
    { name: 'gasLimit', length: 32, fix: false, transform: 'hex' },
    { name: 'shardID', length: 16, fix: false },
    // recover it after main repo fix
    { name: 'toShardID', length: 16, fix: false },
    { name: 'to', length: 20, fix: true },
    { name: 'value', length: 32, fix: false, transform: 'hex' },
    { name: 'data', fix: false },
];
var transactionFieldsETH = [
    { name: 'nonce', length: 32, fix: false },
    { name: 'gasPrice', length: 32, fix: false, transform: 'hex' },
    { name: 'gasLimit', length: 32, fix: false, transform: 'hex' },
    { name: 'to', length: 20, fix: true },
    { name: 'value', length: 32, fix: false, transform: 'hex' },
    { name: 'data', fix: false },
];
var handleNumber = function (value) {
    if (utils.isHex(value) && value === '0x') {
        return utils.hexToNumber('0x00');
    }
    else if (utils.isHex(value) && value !== '0x') {
        return utils.hexToNumber(value);
    }
    else {
        return value;
    }
};
var handleAddress = function (value) {
    if (value === '0x') {
        return '0x';
    }
    else if (utils.isAddress(value)) {
        return value;
    }
    else {
        return '0x';
    }
};
var recover = function (rawTransaction) {
    var transaction = crypto.decode(rawTransaction);
    if (transaction.length !== 11 && transaction.length !== 8) {
        throw new Error('invalid rawTransaction');
    }
    var tx = {
        id: '0x',
        from: '0x',
        rawTransaction: '0x',
        unsignedRawTransaction: '0x',
        nonce: new crypto.BN(utils.strip0x(handleNumber(transaction[0]))).toNumber(),
        gasPrice: new crypto.BN(utils.strip0x(handleNumber(transaction[1]))),
        gasLimit: new crypto.BN(utils.strip0x(handleNumber(transaction[2]))),
        shardID: new crypto.BN(utils.strip0x(handleNumber(transaction[3]))).toNumber(),
        toShardID: new crypto.BN(utils.strip0x(handleNumber(transaction[4]))).toNumber(),
        to: handleAddress(transaction[5]) !== '0x'
            ? crypto.getAddress(handleAddress(transaction[5])).checksum
            : '0x',
        value: new crypto.BN(utils.strip0x(handleNumber(transaction[6]))),
        data: transaction[7],
        chainId: 0,
        signature: {
            r: '',
            s: '',
            recoveryParam: 0,
            v: 0,
        },
    };
    // Legacy unsigned transaction
    if (transaction.length === 8) {
        tx.unsignedRawTransaction = rawTransaction;
        return tx;
    }
    try {
        tx.signature.v = new crypto.BN(utils.strip0x(handleNumber(transaction[8]))).toNumber();
    }
    catch (error) {
        throw error;
    }
    tx.signature.r = crypto.hexZeroPad(transaction[9], 32);
    tx.signature.s = crypto.hexZeroPad(transaction[10], 32);
    if (new crypto.BN(utils.strip0x(handleNumber(tx.signature.r))).isZero() &&
        new crypto.BN(utils.strip0x(handleNumber(tx.signature.s))).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.signature.v;
        tx.signature.v = 0;
    }
    else {
        // Signed Tranasaction
        tx.chainId = Math.floor((tx.signature.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        var recoveryParam = tx.signature.v - 27;
        var raw = transaction.slice(0, 8);
        if (tx.chainId !== 0) {
            raw.push(crypto.hexlify(tx.chainId));
            raw.push('0x');
            raw.push('0x');
            recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest = crypto.keccak256(crypto.encode(raw));
        try {
            var recoveredFrom = crypto.recoverAddress(digest, {
                r: crypto.hexlify(tx.signature.r),
                s: crypto.hexlify(tx.signature.s),
                recoveryParam: recoveryParam,
            });
            tx.from = recoveredFrom === '0x' ? '0x' : crypto.getAddress(recoveredFrom).checksum;
        }
        catch (error) {
            throw error;
        }
        tx.rawTransaction = rawTransaction;
        tx.id = crypto.keccak256(rawTransaction);
    }
    return tx;
};
var recoverETH = function (rawTransaction) {
    var transaction = crypto.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        throw new Error('invalid rawTransaction');
    }
    var tx = {
        id: '0x',
        from: '0x',
        rawTransaction: '0x',
        unsignedRawTransaction: '0x',
        nonce: new crypto.BN(utils.strip0x(handleNumber(transaction[0]))).toNumber(),
        gasPrice: new crypto.BN(utils.strip0x(handleNumber(transaction[1]))),
        gasLimit: new crypto.BN(utils.strip0x(handleNumber(transaction[2]))),
        shardID: 0,
        toShardID: 0,
        to: handleAddress(transaction[3]) !== '0x'
            ? crypto.getAddress(handleAddress(transaction[3])).checksum
            : '0x',
        value: new crypto.BN(utils.strip0x(handleNumber(transaction[4]))),
        data: transaction[5],
        chainId: 0,
        signature: {
            r: '',
            s: '',
            recoveryParam: 0,
            v: 0,
        },
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        tx.unsignedRawTransaction = rawTransaction;
        return tx;
    }
    try {
        tx.signature.v = new crypto.BN(utils.strip0x(handleNumber(transaction[6]))).toNumber();
    }
    catch (error) {
        throw error;
    }
    tx.signature.r = crypto.hexZeroPad(transaction[7], 32);
    tx.signature.s = crypto.hexZeroPad(transaction[8], 32);
    if (new crypto.BN(utils.strip0x(handleNumber(tx.signature.r))).isZero() &&
        new crypto.BN(utils.strip0x(handleNumber(tx.signature.s))).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.signature.v;
        tx.signature.v = 0;
    }
    else {
        // Signed Tranasaction
        tx.chainId = Math.floor((tx.signature.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        var recoveryParam = tx.signature.v - 27;
        var raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push(crypto.hexlify(tx.chainId));
            raw.push('0x');
            raw.push('0x');
            recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest = crypto.keccak256(crypto.encode(raw));
        try {
            var recoveredFrom = crypto.recoverAddress(digest, {
                r: crypto.hexlify(tx.signature.r),
                s: crypto.hexlify(tx.signature.s),
                recoveryParam: recoveryParam,
            });
            tx.from = recoveredFrom === '0x' ? '0x' : crypto.getAddress(recoveredFrom).checksum;
        }
        catch (error) {
            throw error;
        }
        tx.rawTransaction = rawTransaction;
        tx.id = crypto.keccak256(rawTransaction);
    }
    return tx;
};
var sleep = function (ms) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve) {
                setTimeout(function () { return resolve(); }, ms);
            })];
    });
}); };
(function (TransactionEvents) {
    TransactionEvents["transactionHash"] = "transactionHash";
    TransactionEvents["error"] = "error";
    TransactionEvents["confirmation"] = "confirmation";
    TransactionEvents["receipt"] = "receipt";
    TransactionEvents["track"] = "track";
    TransactionEvents["cxConfirmation"] = "cxConfirmation";
    TransactionEvents["cxReceipt"] = "cxReceipt";
    TransactionEvents["cxTrack"] = "cxTrack";
})(exports.TransactionEvents || (exports.TransactionEvents = {}));
var defaultMessenger = new network.Messenger(new network.HttpProvider('http://localhost:9500'), "hmy" /* Harmony */);
var RLPSign = function (transaction, prv) {
    var _a = __read(transaction.getRLPUnsigned(), 2), unsignedRawTransaction = _a[0], raw = _a[1];
    var regroup = __assign(__assign({}, transaction.txParams), { unsignedRawTransaction: unsignedRawTransaction });
    transaction.setParams(regroup);
    var signature = crypto.sign(crypto.keccak256(unsignedRawTransaction), prv);
    var signed = transaction.getRLPSigned(raw, signature);
    return [signature, signed];
};

/**
 * @packageDocumentation
 * @module harmony-transaction
 * @hidden
 */
var TransactionBase = /** @class */ (function () {
    function TransactionBase(messenger, txStatus) {
        this.blockNumbers = [];
        this.confirmations = 0;
        this.confirmationCheck = 0;
        this.cxStatus = "INITIALIZED" /* INTIALIZED */;
        this.cxBlockNumbers = [];
        this.cxConfirmations = 0;
        this.cxConfirmationCheck = 0;
        this.messenger = messenger;
        this.txStatus = txStatus;
        this.emitter = new network.Emitter();
        this.id = '0x';
        this.shardID = this.messenger.currentShard;
    }
    TransactionBase.normalizeAddress = function (address) {
        if (address === '0x') {
            return '0x';
        }
        else if (crypto.HarmonyAddress.isValidChecksum(address) ||
            crypto.HarmonyAddress.isValidBech32(address) ||
            crypto.HarmonyAddress.isValidBech32TestNet(address)) {
            return crypto.getAddress(address).checksum;
        }
        else {
            throw new Error("Address format is not supported");
        }
    };
    TransactionBase.prototype.setMessenger = function (messenger) {
        this.messenger = messenger;
    };
    TransactionBase.prototype.setTxStatus = function (txStatus) {
        this.txStatus = txStatus;
    };
    TransactionBase.prototype.getTxStatus = function () {
        return this.txStatus;
    };
    TransactionBase.prototype.setCxStatus = function (cxStatus) {
        this.cxStatus = cxStatus;
    };
    TransactionBase.prototype.getCxStatus = function () {
        return this.cxStatus;
    };
    // get status
    TransactionBase.prototype.isInitialized = function () {
        return this.getTxStatus() === "INITIALIZED" /* INTIALIZED */;
    };
    TransactionBase.prototype.isSigned = function () {
        return this.getTxStatus() === "SIGNED" /* SIGNED */;
    };
    TransactionBase.prototype.isPending = function () {
        return this.getTxStatus() === "PENDING" /* PENDING */;
    };
    TransactionBase.prototype.isRejected = function () {
        return this.getTxStatus() === "REJECTED" /* REJECTED */;
    };
    TransactionBase.prototype.isConfirmed = function () {
        return this.getTxStatus() === "CONFIRMED" /* CONFIRMED */;
    };
    TransactionBase.prototype.isCxPending = function () {
        return this.getCxStatus() === "PENDING" /* PENDING */;
    };
    TransactionBase.prototype.isCxRejected = function () {
        return this.getCxStatus() === "REJECTED" /* REJECTED */;
    };
    TransactionBase.prototype.isCxConfirmed = function () {
        return this.getCxStatus() === "CONFIRMED" /* CONFIRMED */;
    };
    TransactionBase.prototype.observed = function () {
        return this.emitter;
    };
    TransactionBase.prototype.trackTx = function (txHash, shardID) {
        return __awaiter(this, void 0, void 0, function () {
            var res, currentBlock, currentBlock;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.messenger) {
                            throw new Error('Messenger not found');
                        }
                        return [4 /*yield*/, this.messenger.send("hmy_getTransactionReceipt" /* GetTransactionReceipt */, txHash, this.messenger.chainType, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID)];
                    case 1:
                        res = _a.sent();
                        if (!(res.isResult() && res.result !== null)) return [3 /*break*/, 5];
                        this.receipt = res.result;
                        this.emitReceipt(this.receipt);
                        this.id = res.result.transactionHash;
                        this.confirmations += 1;
                        if (!this.receipt) return [3 /*break*/, 2];
                        if (this.receipt.status && this.receipt.status === '0x1') {
                            this.receipt.byzantium = true;
                            this.txStatus = "CONFIRMED" /* CONFIRMED */;
                        }
                        else if (this.receipt.status && this.receipt.status === '0x0') {
                            this.receipt.byzantium = true;
                            this.txStatus = "REJECTED" /* REJECTED */;
                        }
                        else if (this.receipt.status === undefined && this.receipt.root) {
                            this.receipt.byzantium = false;
                            this.txStatus = "CONFIRMED" /* CONFIRMED */;
                        }
                        return [2 /*return*/, true];
                    case 2:
                        this.txStatus = "PENDING" /* PENDING */;
                        return [4 /*yield*/, this.getBlockNumber(shardID)];
                    case 3:
                        currentBlock = _a.sent();
                        this.blockNumbers.push('0x' + currentBlock.toString('hex'));
                        this.confirmationCheck += 1;
                        return [2 /*return*/, false];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        this.txStatus = "PENDING" /* PENDING */;
                        return [4 /*yield*/, this.getBlockNumber(shardID)];
                    case 6:
                        currentBlock = _a.sent();
                        this.blockNumbers.push('0x' + currentBlock.toString('hex'));
                        this.confirmationCheck += 1;
                        return [2 /*return*/, false];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    TransactionBase.prototype.txConfirm = function (txHash, maxAttempts, interval, shardID) {
        if (maxAttempts === void 0) { maxAttempts = 20; }
        if (interval === void 0) { interval = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var oldBlock, checkBlock, attempt, newBlock, nextBlock, err_1, result, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.messenger.provider instanceof network.HttpProvider)) return [3 /*break*/, 13];
                        this.txStatus = "PENDING" /* PENDING */;
                        return [4 /*yield*/, this.getBlockNumber(shardID)];
                    case 1:
                        oldBlock = _a.sent();
                        checkBlock = oldBlock;
                        attempt = 0;
                        _a.label = 2;
                    case 2:
                        if (!(attempt < maxAttempts)) return [3 /*break*/, 12];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 8, , 9]);
                        return [4 /*yield*/, this.getBlockNumber(shardID)];
                    case 4:
                        newBlock = _a.sent();
                        nextBlock = checkBlock.add(new crypto.BN(attempt === 0 ? attempt : 1));
                        if (!newBlock.gte(nextBlock)) return [3 /*break*/, 6];
                        checkBlock = newBlock;
                        this.emitTrack({
                            txHash: txHash,
                            attempt: attempt,
                            currentBlock: checkBlock.toString(),
                            shardID: shardID,
                        });
                        return [4 /*yield*/, this.trackTx(txHash, shardID)];
                    case 5:
                        if (_a.sent()) {
                            this.emitConfirm(this.txStatus);
                            return [2 /*return*/, this];
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        attempt = attempt - 1 >= 0 ? attempt - 1 : 0;
                        _a.label = 7;
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        err_1 = _a.sent();
                        this.txStatus = "REJECTED" /* REJECTED */;
                        this.emitConfirm(this.txStatus);
                        throw err_1;
                    case 9:
                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 11];
                        // await sleep(interval * attempt);
                        return [4 /*yield*/, sleep(interval)];
                    case 10:
                        // await sleep(interval * attempt);
                        _a.sent();
                        _a.label = 11;
                    case 11:
                        attempt += 1;
                        return [3 /*break*/, 2];
                    case 12:
                        this.txStatus = "REJECTED" /* REJECTED */;
                        this.emitConfirm(this.txStatus);
                        throw new Error("The transaction is still not confirmed after " + maxAttempts + " attempts.");
                    case 13:
                        _a.trys.push([13, 18, , 19]);
                        return [4 /*yield*/, this.trackTx(txHash, shardID)];
                    case 14:
                        if (!_a.sent()) return [3 /*break*/, 15];
                        this.emitConfirm(this.txStatus);
                        return [2 /*return*/, this];
                    case 15: return [4 /*yield*/, this.socketConfirm(txHash, maxAttempts, shardID)];
                    case 16:
                        result = _a.sent();
                        return [2 /*return*/, result];
                    case 17: return [3 /*break*/, 19];
                    case 18:
                        error_1 = _a.sent();
                        this.txStatus = "REJECTED" /* REJECTED */;
                        this.emitConfirm(this.txStatus);
                        throw new Error("The transaction is still not confirmed after " + maxAttempts * interval + " mil seconds.");
                    case 19: return [2 /*return*/];
                }
            });
        });
    };
    TransactionBase.prototype.socketConfirm = function (txHash, maxAttempts, shardID) {
        var _this = this;
        if (maxAttempts === void 0) { maxAttempts = 20; }
        return new Promise(function (resolve, reject) {
            var newHeads = Promise.resolve(new network.NewHeaders(_this.messenger, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID));
            newHeads.then(function (p) {
                p.onData(function (data) { return __awaiter(_this, void 0, void 0, function () {
                    var blockNumber;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                blockNumber = this.messenger.chainPrefix === 'hmy'
                                    ? data.params.result.Header.number
                                    : data.params.result.number;
                                this.emitTrack({
                                    txHash: txHash,
                                    attempt: this.confirmationCheck,
                                    currentBlock: utils.hexToNumber(blockNumber),
                                    shardID: shardID,
                                });
                                if (!!this.blockNumbers.includes(blockNumber)) return [3 /*break*/, 5];
                                return [4 /*yield*/, this.trackTx(txHash, shardID)];
                            case 1:
                                if (!_a.sent()) return [3 /*break*/, 3];
                                this.emitConfirm(this.txStatus);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 2:
                                _a.sent();
                                resolve(this);
                                return [3 /*break*/, 5];
                            case 3:
                                if (!(this.confirmationCheck === maxAttempts)) return [3 /*break*/, 5];
                                this.txStatus = "REJECTED" /* REJECTED */;
                                this.emitConfirm(this.txStatus);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 4:
                                _a.sent();
                                resolve(this);
                                _a.label = 5;
                            case 5: return [2 /*return*/];
                        }
                    });
                }); }).onError(function (error) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.txStatus = "REJECTED" /* REJECTED */;
                                this.emitConfirm(this.txStatus);
                                this.emitError(error);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 1:
                                _a.sent();
                                reject(error);
                                return [2 /*return*/];
                        }
                    });
                }); });
            });
        });
    };
    TransactionBase.prototype.emitTransactionHash = function (transactionHash) {
        this.emitter.emit(exports.TransactionEvents.transactionHash, transactionHash);
    };
    TransactionBase.prototype.emitReceipt = function (receipt) {
        this.emitter.emit(exports.TransactionEvents.receipt, receipt);
    };
    TransactionBase.prototype.emitError = function (error) {
        this.emitter.emit(exports.TransactionEvents.error, error);
    };
    TransactionBase.prototype.emitConfirm = function (data) {
        this.emitter.emit(exports.TransactionEvents.confirmation, data);
    };
    TransactionBase.prototype.emitTrack = function (data) {
        this.emitter.emit(exports.TransactionEvents.track, data);
    };
    TransactionBase.prototype.emitCxReceipt = function (receipt) {
        this.emitter.emit(exports.TransactionEvents.cxReceipt, receipt);
    };
    TransactionBase.prototype.emitCxConfirm = function (data) {
        this.emitter.emit(exports.TransactionEvents.cxConfirmation, data);
    };
    TransactionBase.prototype.emitCxTrack = function (data) {
        this.emitter.emit(exports.TransactionEvents.cxTrack, data);
    };
    TransactionBase.prototype.getBlockNumber = function (shardID) {
        return __awaiter(this, void 0, void 0, function () {
            var currentBlock, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.messenger.send("hmy_blockNumber" /* BlockNumber */, [], this.messenger.chainPrefix, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID)];
                    case 1:
                        currentBlock = _a.sent();
                        if (currentBlock.isError()) {
                            throw currentBlock.message;
                        }
                        return [2 /*return*/, new crypto.BN(currentBlock.result.replace('0x', ''), 'hex')];
                    case 2:
                        error_2 = _a.sent();
                        throw error_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TransactionBase.prototype.getBlockByNumber = function (blockNumber) {
        return __awaiter(this, void 0, void 0, function () {
            var block, error_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.messenger.send("hmy_getBlockByNumber" /* GetBlockByNumber */, [blockNumber, true], this.messenger.chainPrefix, typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID)];
                    case 1:
                        block = _a.sent();
                        if (block.isError()) {
                            throw block.message;
                        }
                        return [2 /*return*/, block.result];
                    case 2:
                        error_3 = _a.sent();
                        throw error_3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TransactionBase.prototype.cxConfirm = function (txHash, maxAttempts, interval, toShardID) {
        if (maxAttempts === void 0) { maxAttempts = 20; }
        if (interval === void 0) { interval = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var oldBlock, checkBlock, attempt, newBlock, nextBlock, err_2, result, error_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.messenger.provider instanceof network.HttpProvider)) return [3 /*break*/, 13];
                        return [4 /*yield*/, this.getBlockNumber(toShardID)];
                    case 1:
                        oldBlock = _a.sent();
                        checkBlock = oldBlock;
                        attempt = 0;
                        _a.label = 2;
                    case 2:
                        if (!(attempt < maxAttempts)) return [3 /*break*/, 12];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 8, , 9]);
                        return [4 /*yield*/, this.getBlockNumber(toShardID)];
                    case 4:
                        newBlock = _a.sent();
                        nextBlock = checkBlock.add(new crypto.BN(attempt === 0 ? attempt : 1));
                        if (!newBlock.gte(nextBlock)) return [3 /*break*/, 6];
                        checkBlock = newBlock;
                        this.emitCxTrack({
                            txHash: txHash,
                            attempt: attempt,
                            currentBlock: checkBlock.toString(),
                            toShardID: toShardID,
                        });
                        return [4 /*yield*/, this.trackCx(txHash, toShardID)];
                    case 5:
                        if (_a.sent()) {
                            this.emitCxConfirm(this.cxStatus);
                            return [2 /*return*/, this];
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        attempt = attempt - 1 >= 0 ? attempt - 1 : 0;
                        _a.label = 7;
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        err_2 = _a.sent();
                        this.cxStatus = "REJECTED" /* REJECTED */;
                        this.emitCxConfirm(this.cxStatus);
                        throw err_2;
                    case 9:
                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 11];
                        return [4 /*yield*/, sleep(interval)];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11:
                        attempt += 1;
                        return [3 /*break*/, 2];
                    case 12:
                        this.cxStatus = "REJECTED" /* REJECTED */;
                        this.emitCxConfirm(this.cxStatus);
                        throw new Error("The transaction is still not confirmed after " + maxAttempts + " attempts.");
                    case 13:
                        _a.trys.push([13, 18, , 19]);
                        return [4 /*yield*/, this.trackCx(txHash, toShardID)];
                    case 14:
                        if (!_a.sent()) return [3 /*break*/, 15];
                        this.emitCxConfirm(this.cxStatus);
                        return [2 /*return*/, this];
                    case 15: return [4 /*yield*/, this.socketCxConfirm(txHash, maxAttempts, toShardID)];
                    case 16:
                        result = _a.sent();
                        return [2 /*return*/, result];
                    case 17: return [3 /*break*/, 19];
                    case 18:
                        error_4 = _a.sent();
                        this.cxStatus = "REJECTED" /* REJECTED */;
                        this.emitCxConfirm(this.cxStatus);
                        throw new Error("The transaction is still not confirmed after " + maxAttempts * interval + " mil seconds.");
                    case 19: return [2 /*return*/];
                }
            });
        });
    };
    TransactionBase.prototype.trackCx = function (txHash, toShardID) {
        return __awaiter(this, void 0, void 0, function () {
            var res, currentBlock;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.messenger) {
                            throw new Error('Messenger not found');
                        }
                        return [4 /*yield*/, this.messenger.send("hmy_getCXReceiptByHash" /* GetCXReceiptByHash */, txHash, this.messenger.chainPrefix, typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID)];
                    case 1:
                        res = _a.sent();
                        if (!(res.isResult() && res.result !== null)) return [3 /*break*/, 2];
                        this.emitCxReceipt(res.result);
                        this.cxStatus = "CONFIRMED" /* CONFIRMED */;
                        return [2 /*return*/, true];
                    case 2: return [4 /*yield*/, this.getBlockNumber(toShardID)];
                    case 3:
                        currentBlock = _a.sent();
                        this.cxBlockNumbers.push('0x' + currentBlock.toString('hex'));
                        this.cxConfirmationCheck += 1;
                        this.cxStatus = "PENDING" /* PENDING */;
                        return [2 /*return*/, false];
                }
            });
        });
    };
    TransactionBase.prototype.socketCxConfirm = function (txHash, maxAttempts, toShardID) {
        var _this = this;
        if (maxAttempts === void 0) { maxAttempts = 20; }
        return new Promise(function (resolve, reject) {
            var newHeads = Promise.resolve(new network.NewHeaders(_this.messenger, typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID));
            newHeads.then(function (p) {
                p.onData(function (data) { return __awaiter(_this, void 0, void 0, function () {
                    var blockNumber;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                blockNumber = this.messenger.chainPrefix === 'hmy'
                                    ? data.params.result.Header.number
                                    : data.params.result.number;
                                this.emitCxTrack({
                                    txHash: txHash,
                                    attempt: this.cxConfirmationCheck,
                                    currentBlock: utils.hexToNumber(blockNumber),
                                    toShardID: toShardID,
                                });
                                if (!!this.blockNumbers.includes(blockNumber)) return [3 /*break*/, 5];
                                return [4 /*yield*/, this.trackCx(txHash, toShardID)];
                            case 1:
                                if (!_a.sent()) return [3 /*break*/, 3];
                                this.emitCxConfirm(this.cxStatus);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 2:
                                _a.sent();
                                resolve(this);
                                return [3 /*break*/, 5];
                            case 3:
                                if (!(this.cxConfirmationCheck === maxAttempts)) return [3 /*break*/, 5];
                                this.cxStatus = "REJECTED" /* REJECTED */;
                                this.emitCxConfirm(this.cxStatus);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 4:
                                _a.sent();
                                resolve(this);
                                _a.label = 5;
                            case 5: return [2 /*return*/];
                        }
                    });
                }); }).onError(function (error) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.cxStatus = "REJECTED" /* REJECTED */;
                                this.emitCxConfirm(this.cxStatus);
                                this.emitError(error);
                                return [4 /*yield*/, p.unsubscribe()];
                            case 1:
                                _a.sent();
                                reject(error);
                                return [2 /*return*/];
                        }
                    });
                }); });
            });
        });
    };
    return TransactionBase;
}());

/**
 * @packageDocumentation
 * @module harmony-transaction
 */
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     *
     * @Params
     * ```javascript
     * id:               string;
      from:             string;
      to:               string;
      nonce:            number | string;
      gasLimit:         number | string | BN;
      gasPrice:         number | string | BN;
      shardID:          number | string;
      toShardID:        number | string;
      data:             string;
      value:            number | string | BN;
      chainId:          number;
      rawTransaction:   string;
      unsignedRawTransaction: string;
      signature:        Signature;
      receipt?:         TransasctionReceipt;
     * ```
     */
    function Transaction(params, messenger, txStatus) {
        if (messenger === void 0) { messenger = defaultMessenger; }
        if (txStatus === void 0) { txStatus = "INITIALIZED" /* INTIALIZED */; }
        var _this = _super.call(this, messenger, txStatus) || this;
        // intialize transaction
        _this.id = params && params.id ? params.id : '0x';
        _this.from = params && params.from ? params.from : '0x';
        _this.nonce = params && params.nonce ? params.nonce : 0;
        _this.gasPrice =
            params && params.gasPrice
                ? new utils.Unit(params.gasPrice).asWei().toWei()
                : new utils.Unit(0).asWei().toWei();
        _this.gasLimit =
            params && params.gasLimit
                ? new utils.Unit(params.gasLimit).asWei().toWei()
                : new utils.Unit(0).asWei().toWei();
        _this.shardID =
            params && params.shardID !== undefined ? params.shardID : _this.messenger.currentShard;
        _this.toShardID =
            params && params.toShardID !== undefined ? params.toShardID : _this.messenger.currentShard;
        _this.to = params && params.to ? Transaction.normalizeAddress(params.to) : '0x';
        _this.value =
            params && params.value ? new utils.Unit(params.value).asWei().toWei() : new utils.Unit(0).asWei().toWei();
        _this.data = params && params.data ? params.data : '0x';
        // chainid should change with different network settings
        _this.chainId = params && params.chainId ? params.chainId : _this.messenger.chainId;
        _this.rawTransaction = params && params.rawTransaction ? params.rawTransaction : '0x';
        _this.unsignedRawTransaction =
            params && params.unsignedRawTransaction ? params.unsignedRawTransaction : '0x';
        _this.signature =
            params && params.signature
                ? params.signature
                : {
                    r: '',
                    s: '',
                    recoveryParam: 0,
                    v: 0,
                };
        _this.receipt = params && params.receipt ? params.receipt : undefined;
        _this.cxStatus = _this.isCrossShard() ? "INITIALIZED" /* INTIALIZED */ : "NONE" /* NONE */;
        return _this;
    }
    /**
     *
     * @example
     * ```javascript
     * const unsigned = txn.getRLPUnsigned(txn);
     * console.log(unsigned);
     * ```
     */
    Transaction.prototype.getRLPUnsigned = function () {
        var _this = this;
        var raw = [];
        // temp setting to be compatible with eth
        var fields = this.messenger.chainType === "hmy" /* Harmony */ ? transactionFields : transactionFieldsETH;
        fields.forEach(function (field) {
            var value = _this.txParams[field.name] || [];
            value = crypto.arrayify(crypto.hexlify(field.transform === 'hex' ? utils.add0xToString(value.toString(16)) : value));
            // Fixed-width field
            if (field.fix === true && field.length && value.length !== field.length && value.length > 0) {
                throw new Error("invalid length for " + field.name);
            }
            // Variable-width (with a maximum)
            if (field.fix === false && field.length) {
                value = crypto.stripZeros(value);
                if (value.length > field.length) {
                    throw new Error("invalid length for " + field.name);
                }
            }
            raw.push(crypto.hexlify(value));
        });
        if (this.txParams.chainId != null && this.txParams.chainId !== 0) {
            raw.push(crypto.hexlify(this.txParams.chainId));
            raw.push('0x');
            raw.push('0x');
        }
        return [crypto.encode(raw), raw];
    };
    Transaction.prototype.getRLPSigned = function (raw, signature) {
        // temp setting to be compatible with eth
        var rawLength = this.messenger.chainType === "hmy" /* Harmony */ ? 11 : 9;
        var sig = crypto.splitSignature(signature);
        var v = 27 + (sig.recoveryParam || 0);
        if (raw.length === rawLength) {
            raw.pop();
            raw.pop();
            raw.pop();
            v += this.chainId * 2 + 8;
        }
        raw.push(crypto.hexlify(v));
        raw.push(crypto.stripZeros(crypto.arrayify(sig.r) || []));
        raw.push(crypto.stripZeros(crypto.arrayify(sig.s) || []));
        return crypto.encode(raw);
    };
    /**
     * @example
     * ```javascript
     * console.log(txn.getRawTransaction());
     * ```
     */
    Transaction.prototype.getRawTransaction = function () {
        return this.rawTransaction;
    };
    /** @hidden */
    Transaction.prototype.recover = function (rawTransaction) {
        // temp setting to be compatible with eth
        var recovered = this.messenger.chainType === "hmy" /* Harmony */
            ? recover(rawTransaction)
            : recoverETH(rawTransaction);
        this.setParams(recovered);
        return this;
    };
    Object.defineProperty(Transaction.prototype, "txPayload", {
        /**
         * get the payload of transaction
         *
         * @example
         * ```
         * const payload = txn.txPayload;
         * console.log(payload);
         * ```
         */
        get: function () {
            return {
                from: this.txParams.from || '0x',
                to: this.txParams.to || '0x',
                shardID: this.txParams.shardID ? utils.numberToHex(this.shardID) : '0x',
                toShardID: this.txParams.toShardID ? utils.numberToHex(this.toShardID) : '0x',
                gas: this.txParams.gasLimit ? utils.numberToHex(this.txParams.gasLimit) : '0x',
                gasPrice: this.txParams.gasPrice ? utils.numberToHex(this.txParams.gasPrice) : '0x',
                value: this.txParams.value ? utils.numberToHex(this.txParams.value) : '0x',
                data: this.txParams.data || '0x',
                nonce: this.txParams.nonce ? utils.numberToHex(this.nonce) : '0x',
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "txParams", {
        /**
         * get transaction params
         *
         * @example
         * ```
         * const txParams = txn.txParams;
         * console.log(txParams)
         * ```
         */
        get: function () {
            return {
                id: this.id || '0x',
                from: this.from || '',
                nonce: this.nonce || 0,
                gasPrice: this.gasPrice || new utils.Unit(0).asWei().toWei(),
                gasLimit: this.gasLimit || new utils.Unit(0).asWei().toWei(),
                shardID: this.shardID !== undefined ? this.shardID : this.messenger.currentShard,
                toShardID: this.toShardID !== undefined ? this.toShardID : this.messenger.currentShard,
                to: Transaction.normalizeAddress(this.to) || '0x',
                value: this.value || new utils.Unit(0).asWei().toWei(),
                data: this.data || '0x',
                chainId: this.chainId || 0,
                rawTransaction: this.rawTransaction || '0x',
                unsignedRawTransaction: this.unsignedRawTransaction || '0x',
                signature: this.signature || '0x',
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * set the params to the txn
     *
     * @example
     * ```
     * txn.setParams({
     *   to: 'one1ew56rqrucu6p6n598fmjmnfh8dd4xpg6atne9c',
     *   value: '1200',
     *   gasLimit: '230000',
     *   shardID: 1,
     *   toShardID: 0,
     *   gasPrice: new hmy.utils.Unit('101').asGwei().toWei(),
     *   signature: {
     *     r: '0xd693b532a80fed6392b428604171fb32fdbf953728a3a7ecc7d4062b1652c042',
     *     s: '0x24e9c602ac800b983b035700a14b23f78a253ab762deab5dc27e3555a750b354',
     *     v: 0
     *   },
     * });
     * console.log(txn);
     * ```
     */
    Transaction.prototype.setParams = function (params) {
        this.id = params && params.id ? params.id : '0x';
        this.from = params && params.from ? params.from : '0x';
        this.nonce = params && params.nonce ? params.nonce : 0;
        this.gasPrice =
            params && params.gasPrice
                ? new utils.Unit(params.gasPrice).asWei().toWei()
                : new utils.Unit(0).asWei().toWei();
        this.gasLimit =
            params && params.gasLimit
                ? new utils.Unit(params.gasLimit).asWei().toWei()
                : new utils.Unit(0).asWei().toWei();
        this.shardID =
            params && params.shardID !== undefined ? params.shardID : this.messenger.currentShard;
        this.toShardID =
            params && params.toShardID !== undefined ? params.toShardID : this.messenger.currentShard;
        this.to = params && params.to ? Transaction.normalizeAddress(params.to) : '0x';
        this.value =
            params && params.value ? new utils.Unit(params.value).asWei().toWei() : new utils.Unit(0).asWei().toWei();
        this.data = params && params.data ? params.data : '0x';
        this.chainId = params && params.chainId ? params.chainId : 0;
        this.rawTransaction = params && params.rawTransaction ? params.rawTransaction : '0x';
        this.unsignedRawTransaction =
            params && params.unsignedRawTransaction ? params.unsignedRawTransaction : '0x';
        this.signature =
            params && params.signature
                ? params.signature
                : {
                    r: '',
                    s: '',
                    recoveryParam: 0,
                    v: 0,
                };
        if (this.rawTransaction !== '0x') {
            this.setTxStatus("SIGNED" /* SIGNED */);
        }
        else {
            this.setTxStatus("INITIALIZED" /* INTIALIZED */);
        }
    };
    /** @hidden */
    Transaction.prototype.map = function (fn) {
        var newParams = fn(this.txParams);
        this.setParams(newParams);
        return this;
    };
    /**
     * Check whether the transaction is cross shard
     *
     * @example
     * ```javascript
     * console.log(txn.isCrossShard());
     * ```
     */
    Transaction.prototype.isCrossShard = function () {
        return new crypto.BN(this.txParams.shardID).toString() !== new crypto.BN(this.txParams.toShardID).toString();
    };
    /**
     *
     * @example
     * ```
     * txn.sendTransaction().then((value) => {
     *   console.log(value);
     * });
     * ```
     */
    Transaction.prototype.sendTransaction = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.rawTransaction === 'tx' || this.rawTransaction === undefined) {
                            throw new Error('Transaction not signed');
                        }
                        if (!this.messenger) {
                            throw new Error('Messenger not found');
                        }
                        return [4 /*yield*/, this.messenger.send("hmy_sendRawTransaction" /* SendRawTransaction */, this.rawTransaction, this.messenger.chainType, typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID)];
                    case 1:
                        res = _a.sent();
                        // temporarilly hard coded
                        if (res.isResult()) {
                            this.id = res.result;
                            this.emitTransactionHash(this.id);
                            this.setTxStatus("PENDING" /* PENDING */);
                            // await this.confirm(this.id, 20, 1000);
                            return [2 /*return*/, [this, res.result]];
                        }
                        else if (res.isError()) {
                            this.emitConfirm("transaction failed:" + res.error.message);
                            this.setTxStatus("REJECTED" /* REJECTED */);
                            return [2 /*return*/, [this, "transaction failed:" + res.error.message]];
                        }
                        else {
                            this.emitError('transaction failed');
                            throw new Error('transaction failed');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Transaction.prototype.confirm = function (txHash, maxAttempts, interval, shardID, toShardID) {
        if (maxAttempts === void 0) { maxAttempts = 20; }
        if (interval === void 0) { interval = 1000; }
        if (shardID === void 0) { shardID = this.txParams.shardID; }
        if (toShardID === void 0) { toShardID = this.txParams.toShardID; }
        return __awaiter(this, void 0, void 0, function () {
            var txConfirmed, cxConfirmed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.txConfirm(txHash, maxAttempts, interval, shardID)];
                    case 1:
                        txConfirmed = _a.sent();
                        if (!this.isCrossShard()) {
                            return [2 /*return*/, txConfirmed];
                        }
                        if (!txConfirmed.isConfirmed()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.cxConfirm(txHash, maxAttempts, interval, toShardID)];
                    case 2:
                        cxConfirmed = _a.sent();
                        return [2 /*return*/, cxConfirmed];
                    case 3: return [2 /*return*/, txConfirmed];
                }
            });
        });
    };
    return Transaction;
}(TransactionBase));

/**
 * @packageDocumentation
 * @module harmony-transaction
 * @hidden
 */
var ShardingTransaction = /** @class */ (function (_super) {
    __extends(ShardingTransaction, _super);
    function ShardingTransaction(params, messenger, txStatus) {
        if (messenger === void 0) { messenger = defaultMessenger; }
        if (txStatus === void 0) { txStatus = "INITIALIZED" /* INTIALIZED */; }
        var _this = this;
        var fromAddress = params.from;
        var toAddress = params.to;
        var fromExtraction = fromAddress !== undefined ? fromAddress.split(utils.AddressSuffix) : ['0x', undefined];
        var toExtraction = toAddress !== undefined ? toAddress.split(utils.AddressSuffix) : ['0x', undefined];
        var from = fromExtraction[0];
        var shardID = fromExtraction[1] !== undefined
            ? Number.parseInt(fromExtraction[1], 10)
            : params.shardID !== undefined
                ? params.shardID
                : 0;
        var to = toExtraction[0];
        var toShardID = toExtraction[1] !== undefined
            ? Number.parseInt(toExtraction[1], 10)
            : params.toShardID !== undefined
                ? params.toShardID
                : 0;
        var reParams = __assign(__assign({}, params), { from: from,
            to: to,
            shardID: shardID,
            toShardID: toShardID });
        _this = _super.call(this, reParams, messenger, txStatus) || this;
        return _this;
    }
    return ShardingTransaction;
}(Transaction));

/**
 * ## hhahaha
 *
 * @packageDocumentation
 * @module harmony-transaction
 */
var TransactionFactory = /** @class */ (function () {
    function TransactionFactory(messenger) {
        this.messenger = messenger;
    }
    TransactionFactory.getContractAddress = function (tx) {
        var _a = tx.txParams, from = _a.from, nonce = _a.nonce;
        return crypto.getAddress(crypto.getContractAddress(crypto.getAddress(from).checksum, Number.parseInt("" + nonce, 10))).checksum;
    };
    TransactionFactory.prototype.setMessenger = function (messenger) {
        this.messenger = messenger;
    };
    /**
     * Create a new Transaction
     * @params
     * ```
     * // to: Address of the receiver
     * // value: value transferred in wei
     * // gasLimit: the maximum gas would pay, can use string
     * // shardID: send token from shardID
     * // toShardId: send token to shardID
     * // gasPrice: you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN
     * ```
     *
     * @example
     * ```javascript
     * const txn = hmy.transactions.newTx({
     *   to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',
     *   value: '10000',
     *   gasLimit: '210000',
     *   shardID: 0,
     *   toShardID: 0,
     *   gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),
     * });
     * ```
     */
    TransactionFactory.prototype.newTx = function (txParams, sharding) {
        if (sharding === void 0) { sharding = false; }
        if (!sharding) {
            return new Transaction(txParams, this.messenger, "INITIALIZED" /* INTIALIZED */);
        }
        return new ShardingTransaction(txParams, this.messenger, "INITIALIZED" /* INTIALIZED */);
    };
    /**
     * clone the transaction
     *
     * @param transaction
     *
     * @example
     * ```javascript
     * const cloneTxn = hmy.transactions.clone(txn);
     * console.log(cloneTxn)
     * ```
     */
    TransactionFactory.prototype.clone = function (transaction) {
        return new Transaction(transaction.txParams, this.messenger, "INITIALIZED" /* INTIALIZED */);
    };
    /**
     *
     * @example
     * ```javascript
     * txHash = '0xf8698085174876e8008252088080949d72989b68777a1f3ffd6f1db079f1928373ee52830186a08027a0ab8229ff5d5240948098f26372eaed9ab2e9be23e8594b08e358ca56a47f8ae9a0084e5c4d1fec496af444423d8a714f65c079260ff01a1be1de7005dd424adf44'
     *
     * const recoverTx = hmy.transactions.recover(txHash);
     * console.log(recoverTx);
     * ```
     */
    TransactionFactory.prototype.recover = function (txHash) {
        var newTxn = new Transaction({}, this.messenger, "INITIALIZED" /* INTIALIZED */);
        newTxn.recover(txHash);
        return newTxn;
    };
    return TransactionFactory;
}());

/**
 * ## About this package
 *
 * `@harmony-js/transaction` provides the functions to build transactions
 *
 * Develop can use this package to:
 * - build a transaction offline!
 * - set params of transaction
 * -
 *
 * ## How to use this package
 * ### Step 1: create a Harmony Instance
 * ```javascript
 * const { Harmony } = require('@harmony-js/core');
 * const { ChainID, ChainType } = require('@harmony-js/utils');
 * const { BN } = require('@harmony-js/crypto');
 *
 * const hmy = new Harmony(
 *   'http://localhost:9500',
 *   {
 *     chainType: ChainType.Harmony,
 *     chainId: ChainID.HmyLocal,
 *   },
 * );
 * ```
 *
 * ### Step 2: build a transaction
 * ```javascript
 * const txn = hmy.transactions.newTx({
 *   to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',
 *   value: '10000',
 *   gasLimit: '210000',
 *   shardID: 0,
 *   toShardID: 0,
 *   gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),
 * });
 * ```
 *
 * ## some important information
 * Transaction Parameters
 * ```java
 * // interface TxParams
 * id:               string;
 * from:             string;
 * to:               string;
 * nonce:            number | string;
 * gasLimit:         number | string | BN;
 * gasPrice:         number | string | BN;
 * shardID:          number | string;
 * toShardID:        number | string;
 * data:             string;
 * value:            number | string | BN;
 * chainId:          number;
 * rawTransaction:   string;
 * unsignedRawTransaction: string;
 * signature:        Signature;
 * receipt?:         TransasctionReceipt;
 * ```
 *
 * Transaction Receipt
 * ```java
 * // interface TransasctionReceipt
 * transactionHash:   string;
 * transactionIndex:  string;
 * blockHash:         string;
 * blockNumber:       string; // 11
 * from:              string;
 * to:                string;
 * gasUsed:           string;
 * cumulativeGasUsed: string; // 13244
 * contractAddress?:  string | null; // or null, if none was created
 * logs:              any[];
 * logsBloom:         string; // 256 byte bloom filter
 * v:                 string;
 * r:                 string;
 * s:                 string;
 * responseType?:     string;
 * byzantium?:        boolean;
 * status?:           string; // post Byzantium will return `0x0` or `0x1`
 * root?:             string; // pre Byzantium will return `root`
 * ```
 *
 * @packageDocumentation
 * @module harmony-transaction
 */
(function (TxStatus) {
    TxStatus["NONE"] = "NONE";
    TxStatus["INTIALIZED"] = "INITIALIZED";
    TxStatus["SIGNED"] = "SIGNED";
    TxStatus["PENDING"] = "PENDING";
    TxStatus["CONFIRMED"] = "CONFIRMED";
    TxStatus["REJECTED"] = "REJECTED";
})(exports.TxStatus || (exports.TxStatus = {}));

/**
 * @packageDocumentation
 * @module harmony-transaction
 * @hidden
 */
var AbstractTransaction = /** @class */ (function () {
    function AbstractTransaction() {
    }
    return AbstractTransaction;
}());

/**
 * @packageDocumentation
 * @module harmony-transaction
 * @hidden
 */

exports.TransactionFactory = TransactionFactory;
exports.Transaction = Transaction;
exports.ShardingTransaction = ShardingTransaction;
exports.transactionFields = transactionFields;
exports.transactionFieldsETH = transactionFieldsETH;
exports.handleNumber = handleNumber;
exports.handleAddress = handleAddress;
exports.recover = recover;
exports.recoverETH = recoverETH;
exports.sleep = sleep;
exports.defaultMessenger = defaultMessenger;
exports.RLPSign = RLPSign;
exports.TransactionBase = TransactionBase;
exports.AbstractTransaction = AbstractTransaction;
//# sourceMappingURL=index.cjs.js.map
