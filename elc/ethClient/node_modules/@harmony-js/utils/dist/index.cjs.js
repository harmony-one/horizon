/**
 * Test Banner
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var BN = _interopDefault(require('bn.js'));

/**
 * @packageDocumentation
 * @module harmony-utils
 */
var isKeyString = function (keyString, lengh) {
    return !!keyString.replace('0x', '').match("^[0-9a-fA-F]{" + lengh + "}$");
};
isKeyString.validator = 'isKeyString';
var isAddress = function (address) {
    return isKeyString(address, 40);
};
isAddress.validator = 'isAddress';
var isPrivateKey = function (privateKey) {
    return isKeyString(privateKey, 64);
};
isPrivateKey.validator = 'isPrivateKey';
var isPublicKey = function (publicKey) {
    return isKeyString(publicKey, 66);
};
isPublicKey.validator = 'isPublicKey';
var isHash = function (hash) {
    return isKeyString(hash, 64);
};
isHash.validator = 'isHash';
/**
 * [isNumber verify param is a Number]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isNumber = function (obj) {
    return obj === +obj;
};
isNumber.validator = 'isNumber';
/**
 * [isNumber verify param is a Number]
 * @param  {any}  obj [value]
 * @return {boolean}     [boolean]
 */
var isInt = function (obj) {
    return isNumber(obj) && Number.isInteger(obj);
};
isInt.validator = 'isInt';
/**
 * [isString verify param is a String]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isString = function (obj) {
    return obj === "" + obj;
};
isString.validator = 'isString';
/**
 * [isBoolean verify param is a Boolean]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isBoolean = function (obj) {
    return obj === !!obj;
};
isBoolean.validator = 'isBoolean';
/**
 * [isArray verify param input is an Array]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isArray = function (obj) {
    return Array.isArray(obj);
};
isArray.validator = 'isArray';
/**
 * [isJson verify param input is a Json]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isJsonString = function (obj) {
    try {
        return !!JSON.parse(obj) && isObject(JSON.parse(obj));
    }
    catch (e) {
        return false;
    }
};
isJsonString.validator = 'isJsonString';
/**
 * [isObject verify param is an Object]
 * @param  {any}  obj [value]
 * @return {Boolean}     [boolean]
 */
var isObject = function (obj) {
    return obj !== null && !Array.isArray(obj) && typeof obj === 'object';
};
isObject.validator = 'isObject';
/**
 * [isFunction verify param is a Function]
 * @param  {any}  obj [value]
 * @return {Boolean}     [description]
 */
var isFunction = function (obj) {
    return typeof obj === 'function';
};
isFunction.validator = 'isFunction';
var isHex = function (obj) {
    if (!isString(obj)) {
        throw new Error(obj + " is not string");
    }
    return ((obj.startsWith('0x') || obj.startsWith('-0x')) &&
        isNumber(Number.parseInt(("" + obj).toLowerCase().replace('0x', ''), 16)));
};
isHex.validator = 'isHex';
var isHttp = function (obj) {
    if (!isString(obj)) {
        throw new Error(obj + " is not valid url");
    }
    else {
        return obj.startsWith('http://') || obj.startsWith('https://');
    }
};
isHttp.validator = 'isHttp';
var isWs = function (obj) {
    if (!isString(obj)) {
        throw new Error(obj + " is not valid url");
    }
    else {
        return obj.startsWith('ws://') || obj.startsWith('wss://');
    }
};
isWs.validator = 'isWs';
(function (DefaultBlockParams) {
    DefaultBlockParams["earliest"] = "earliest";
    DefaultBlockParams["pending"] = "pending";
    DefaultBlockParams["latest"] = "latest";
})(exports.DefaultBlockParams || (exports.DefaultBlockParams = {}));
var isBlockNumber = function (obj) {
    var blockParams = [
        "earliest" /* earliest */,
        "pending" /* pending */,
        "latest" /* latest */,
    ];
    if (!isString(obj)) {
        throw new Error(obj + " is not valid blockNumber");
    }
    return isHex(obj) || blockParams.some(function (val) { return val === obj; });
};
isBlockNumber.validator = 'isBlockNumber';
var isBech32Address = function (raw) {
    return !!raw.match(/^one1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}/);
};
isBech32Address.validator = 'isBech32Address';
var isBech32TestNetAddress = function (raw) {
    return !!raw.match(/^tone1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}/);
};
isBech32TestNetAddress.validator = 'isBech32TestNetAddress';
var isValidAddress = function (address) {
    if (!isString(address)) {
        throw new Error(address + " is not string");
    }
    if (isAddress(address) || isBech32Address(address) || isBech32TestNetAddress(address)) {
        return true;
    }
    else {
        return false;
    }
};
isValidAddress.validator = 'isValidAddress';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/**
 * @packageDocumentation
 * @module harmony-utils
 */
(function (Units) {
    Units["wei"] = "wei";
    Units["Kwei"] = "Kwei";
    Units["Mwei"] = "Mwei";
    Units["Gwei"] = "Gwei";
    Units["szabo"] = "szabo";
    Units["finney"] = "finney";
    Units["ether"] = "ether";
    Units["one"] = "one";
    Units["Kether"] = "Kether";
    Units["Mether"] = "Mether";
    Units["Gether"] = "Gether";
    Units["Tether"] = "Tether";
})(exports.Units || (exports.Units = {}));
/** @hidden */
var unitMap = new Map([
    ["wei" /* wei */, '1'],
    ["Kwei" /* Kwei */, '1000'],
    ["Mwei" /* Mwei */, '1000000'],
    ["Gwei" /* Gwei */, '1000000000'],
    ["szabo" /* szabo */, '1000000000000'],
    ["finney" /* finney */, '1000000000000000'],
    ["ether" /* ether */, '1000000000000000000'],
    ["one" /* one */, '1000000000000000000'],
    ["Kether" /* Kether */, '1000000000000000000000'],
    ["Mether" /* Mether */, '1000000000000000000000000'],
    ["Gether" /* Gether */, '1000000000000000000000000000'],
    ["Tether" /* Tether */, '1000000000000000000000000000000'],
]);
/** @hidden */
var DEFAULT_OPTIONS = {
    pad: false,
};
/**
 * Convert Number to String
 */
var numberToString = function (obj, radix) {
    if (radix === void 0) { radix = 10; }
    if (BN.isBN(obj)) {
        return obj.toString(radix);
    }
    else if (isNumber(obj)) {
        return new BN(obj).toString(radix);
    }
    else if (isString(obj) && isNumber(Number(obj))) {
        return new BN(obj).toString(radix);
    }
    else {
        throw new Error("cannot parse number:" + obj + " to string");
    }
};
/**
 * Convert Number to String
 */
var numToStr = function (input) {
    if (typeof input === 'string') {
        if (!input.match(/^-?[0-9.]+$/)) {
            throw new Error("while converting number to string, invalid number value '" + input + "', should be a number matching (^-?[0-9.]+).");
        }
        return input;
    }
    else if (typeof input === 'number') {
        return String(input);
    }
    else if (BN.isBN(input)) {
        return input.toString(10);
    }
    throw new Error("while converting number to string, invalid number value '" + input + "' type " + typeof input + ".");
};
var add0xToString = function (obj) {
    if (isString(obj) && !obj.startsWith('-')) {
        return '0x' + obj.replace('0x', '');
    }
    else if (isString(obj) && obj.startsWith('-')) {
        return '-0x' + obj.replace('-', '');
    }
    else {
        throw new Error(obj + " is not String");
    }
};
var strip0x = function (obj) {
    return obj.toLowerCase().replace('0x', '');
};
/**
 * Convert number to hex
 */
var numberToHex = function (obj) {
    try {
        return add0xToString(numberToString(obj, 16));
    }
    catch (error) {
        throw error;
    }
};
/**
 * Convert hex to Decimal number
 */
var hexToNumber = function (hex) {
    if (isHex(hex) && hex[0] !== '-') {
        return new BN(strip0x(hex), 'hex').toString();
    }
    else if (isHex(hex) && hex[0] === '-') {
        var result = new BN(hex.substring(3), 16);
        return result.mul(new BN(-1)).toString();
    }
    else {
        throw new Error(hex + " is not hex number");
    }
};
/**
 * Convert hex to Big Number
 */
var hexToBN = function (hex) {
    if (isHex(hex) && hex[0] !== '-') {
        return new BN(strip0x(hex), 'hex');
    }
    else if (isHex(hex) && hex[0] === '-') {
        var result = new BN(hex.substring(3), 16);
        return result.mul(new BN(-1));
    }
    else {
        throw new Error(hex + " is not hex number");
    }
};
/**
 * Converts any ONE value into wei
 */
var toWei = function (input, unit) {
    try {
        var inputStr = numToStr(input);
        var baseStr = unitMap.get(unit);
        if (!baseStr) {
            throw new Error("No unit of type " + unit + " exists.");
        }
        var baseNumDecimals = baseStr.length - 1;
        var base = new BN(baseStr, 10);
        // Is it negative?
        var isNegative = inputStr.substring(0, 1) === '-';
        if (isNegative) {
            inputStr = inputStr.substring(1);
        }
        if (inputStr === '.') {
            throw new Error("Cannot convert " + inputStr + " to wei.");
        }
        // Split it into a whole and fractional part
        var comps = inputStr.split('.'); // eslint-disable-line
        if (comps.length > 2) {
            throw new Error("Cannot convert " + inputStr + " to wei.");
        }
        var _a = __read(comps, 2), whole = _a[0], fraction = _a[1];
        if (!whole) {
            whole = '0';
        }
        if (!fraction) {
            fraction = '0';
        }
        if (fraction.length > baseNumDecimals) {
            throw new Error("Cannot convert " + inputStr + " to wei.");
        }
        while (fraction.length < baseNumDecimals) {
            fraction += '0';
        }
        var wholeBN = new BN(whole);
        var fractionBN = new BN(fraction);
        var wei = wholeBN.mul(base).add(fractionBN);
        if (isNegative) {
            wei = wei.neg();
        }
        return new BN(wei.toString(10), 10);
    }
    catch (error) {
        throw error;
    }
};
/**
 * Converts any wei value into a ONE value.
 */
var fromWei = function (wei, unit, options) {
    if (options === void 0) { options = DEFAULT_OPTIONS; }
    try {
        var weiBN = !BN.isBN(wei) ? new BN(wei) : wei;
        if (unit === 'wei') {
            return weiBN.toString(10);
        }
        var baseStr = unitMap.get(unit);
        if (!baseStr) {
            throw new Error("No unit of type " + unit + " exists.");
        }
        var base = new BN(baseStr, 10);
        var baseNumDecimals = baseStr.length - 1;
        var fraction = weiBN
            .abs()
            .mod(base)
            .toString(10);
        // prepend 0s to the fraction half
        while (fraction.length < baseNumDecimals) {
            fraction = "0" + fraction;
        }
        if (!options.pad) {
            /* eslint-disable prefer-destructuring */
            var matchFraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/);
            fraction = matchFraction ? matchFraction[1] : '0';
        }
        var whole = weiBN.div(base).toString(10);
        return fraction === '0' ? "" + whole : whole + "." + fraction;
    }
    catch (error) {
        throw error;
    }
};
var Unit = /** @class */ (function () {
    function Unit(str) {
        if (!BN.isBN(str) && typeof str !== 'number' && isHex(str)) {
            this.unit = hexToNumber(str);
        }
        else if (!BN.isBN(str) && typeof str === 'number') {
            this.unit = str.toString();
        }
        else if (str === '0x') {
            this.unit = hexToNumber('0x0');
        }
        else {
            this.unit = str;
        }
        this.wei = new BN(this.unit);
    }
    Unit.from = function (str) {
        return new Unit(str);
    };
    Unit.Wei = function (str) {
        return new Unit(str).asWei();
    };
    Unit.Kwei = function (str) {
        return new Unit(str).asKwei();
    };
    Unit.Mwei = function (str) {
        return new Unit(str).asMwei();
    };
    Unit.Gwei = function (str) {
        return new Unit(str).asGwei();
    };
    Unit.Szabo = function (str) {
        return new Unit(str).asSzabo();
    };
    Unit.Finney = function (str) {
        return new Unit(str).asFinney();
    };
    Unit.Ether = function (str) {
        return new Unit(str).asEther();
    };
    Unit.One = function (str) {
        return new Unit(str).asOne();
    };
    Unit.Kether = function (str) {
        return new Unit(str).asKether();
    };
    Unit.Mether = function (str) {
        return new Unit(str).asMether();
    };
    Unit.Gether = function (str) {
        return new Unit(str).asGether();
    };
    Unit.Tether = function (str) {
        return new Unit(str).asTether();
    };
    Unit.prototype.asWei = function () {
        this.wei = new BN(this.unit);
        return this;
    };
    Unit.prototype.asKwei = function () {
        this.wei = toWei(this.unit, "Kwei" /* Kwei */);
        return this;
    };
    Unit.prototype.asMwei = function () {
        this.wei = toWei(this.unit, "Mwei" /* Mwei */);
        return this;
    };
    Unit.prototype.asGwei = function () {
        this.wei = toWei(this.unit, "Gwei" /* Gwei */);
        return this;
    };
    Unit.prototype.asSzabo = function () {
        this.wei = toWei(this.unit, "szabo" /* szabo */);
        return this;
    };
    Unit.prototype.asFinney = function () {
        this.wei = toWei(this.unit, "finney" /* finney */);
        return this;
    };
    Unit.prototype.asEther = function () {
        this.wei = toWei(this.unit, "ether" /* ether */);
        return this;
    };
    Unit.prototype.asOne = function () {
        this.wei = toWei(this.unit, "one" /* one */);
        return this;
    };
    Unit.prototype.asKether = function () {
        this.wei = toWei(this.unit, "Kether" /* Kether */);
        return this;
    };
    Unit.prototype.asMether = function () {
        this.wei = toWei(this.unit, "Mether" /* Mether */);
        return this;
    };
    Unit.prototype.asGether = function () {
        this.wei = toWei(this.unit, "Gether" /* Gether */);
        return this;
    };
    Unit.prototype.asTether = function () {
        this.wei = toWei(this.unit, "Tether" /* Tether */);
        return this;
    };
    Unit.prototype.toWei = function () {
        if (this.wei) {
            return this.wei;
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toKwei = function () {
        if (this.wei) {
            return fromWei(this.wei, "Kwei" /* Kwei */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toGwei = function () {
        if (this.wei) {
            return fromWei(this.wei, "Gwei" /* Gwei */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toMwei = function () {
        if (this.wei) {
            return fromWei(this.wei, "Mwei" /* Mwei */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toSzabo = function () {
        if (this.wei) {
            return fromWei(this.wei, "szabo" /* szabo */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toFinney = function () {
        if (this.wei) {
            return fromWei(this.wei, "finney" /* finney */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toEther = function () {
        if (this.wei) {
            return fromWei(this.wei, "ether" /* ether */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toOne = function () {
        if (this.wei) {
            return fromWei(this.wei, "one" /* one */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toKether = function () {
        if (this.wei) {
            return fromWei(this.wei, "Kether" /* Kether */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toMether = function () {
        if (this.wei) {
            return fromWei(this.wei, "Mether" /* Mether */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toGether = function () {
        if (this.wei) {
            return fromWei(this.wei, "Gether" /* Gether */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toTether = function () {
        if (this.wei) {
            return fromWei(this.wei, "Tether" /* Tether */);
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toWeiString = function () {
        if (this.wei) {
            return this.wei.toString();
        }
        else {
            throw new Error('error transforming');
        }
    };
    Unit.prototype.toHex = function () {
        if (this.wei) {
            return numberToHex(this.wei);
        }
        else {
            throw new Error('error transforming');
        }
    };
    return Unit;
}());

/**
 * @packageDocumentation
 * @module harmony-utils
 */
(function (AssertType) {
    AssertType["required"] = "required";
    AssertType["optional"] = "optional";
})(exports.AssertType || (exports.AssertType = {}));
/** @hidden */
var validatorArray = {
    isNumber: [isNumber],
    isString: [isString],
    isBoolean: [isBoolean],
    isArray: [isArray],
    isJsonString: [isJsonString],
    isObject: [isObject],
    isFunction: [isFunction],
    isHex: [isHex],
    isPublicKey: [isPublicKey],
    isPrivateKey: [isPrivateKey],
    isAddress: [isAddress],
    isHash: [isHash],
    isBlockNumber: [isBlockNumber],
    isBech32Address: [isBech32Address],
    isBech32TestNetAddress: [isBech32TestNetAddress],
    isValidAddress: [isValidAddress],
};
function validateArgs(args, requiredArgs, optionalArgs) {
    for (var key in requiredArgs) {
        if (args[key] !== undefined) {
            // tslint:disable-next-line: prefer-for-of
            for (var i = 0; i < requiredArgs[key].length; i += 1) {
                if (typeof requiredArgs[key][i] !== 'function') {
                    throw new Error('Validator is not a function');
                }
                if (!requiredArgs[key][i](args[key])) {
                    throw new Error("Validation failed for " + key + ",should be validated by " + requiredArgs[key][i].validator);
                }
            }
        }
        else {
            throw new Error("Key not found: " + key);
        }
    }
    for (var key in optionalArgs) {
        if (args[key]) {
            // tslint:disable-next-line: prefer-for-of
            for (var i = 0; i < optionalArgs[key].length; i += 1) {
                if (typeof optionalArgs[key][i] !== 'function') {
                    throw new Error('Validator is not a function');
                }
                if (!optionalArgs[key][i](args[key])) {
                    throw new Error("Validation failed for " + key + ",should be validated by " + optionalArgs[key][i].validator);
                }
            }
        }
    }
    return true;
}
function generateValidateObjects(validatorObject) {
    var requiredArgs = {};
    var optionalArgs = {};
    for (var index in validatorObject) {
        if (index !== undefined) {
            var newObjectKey = index;
            var newObjectValid = validatorObject[index][0];
            var isRequired = validatorObject[index][1];
            if (isRequired === "required" /* required */) {
                requiredArgs[newObjectKey] = validatorArray[newObjectValid];
            }
            else {
                optionalArgs[newObjectKey] = validatorArray[newObjectValid];
            }
        }
    }
    return { requiredArgs: requiredArgs, optionalArgs: optionalArgs };
}
var assertObject = function (input) { return function (target, key, descriptor) {
    var _a = generateValidateObjects(input), requiredArgs = _a.requiredArgs, optionalArgs = _a.optionalArgs;
    var original = descriptor.value;
    function interceptor() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        validateArgs(args[0], requiredArgs, optionalArgs);
        return original.apply(this, args);
    }
    descriptor.value = interceptor;
    return descriptor;
}; };

/**
 * ## About this package
 *
 * `@harmony-js/util` provides utility functions for Harmony dapps and other `harmony-js` packages
 *
 * Develop can use this package to:
 * - Transform the unit of token (fromWei, toWei...)
 * - Convert variable to different type (hexToBN, numberToHex...)
 * - Check validators information (isAddress, isPublicKey, isBlockNumber...)
 *
 * ## How to use this package
 *
 * ### Step 1: create a Harmony Instance
 * ```javascript
 * const { Harmony } = require('@harmony-js/core');
 * const { ChainID, ChainType } = require('@harmony-js/utils');
 * const { BN } = require('@harmony-js/crypto');
 *
 * const hmy = new Harmony(
 *   'http://localhost:9500',
 *   {
 *     chainType: ChainType.Harmony,
 *     chainId: ChainID.HmyLocal,
 *   },
 * );
 * ```
 *
 * ### Step 2: Select and call functions
 * Here are some examples:
 *
 * ```javascript
 * // numberToString
 * const num = 123;
 * const str = hmy.utils.numberToString(num)
 * console.log(str);
 *
 * // add0xToString
 * const str = '12345';
 * const expected = hmy.utils.add0xToString(str)
 * console.log(expected);
 *
 * // fromWei
 * const Wei = new BN('1000000000000000000');
 * const expected = hmy.utils.fromWei(Wei, hmy.utils.Units.one);
 * console.log(expected);
 *
 * // toWei
 * const one = new BN('1');
 * const expected = hmy.utils.toWei(one, hmy.utils.Units.one);
 * const num = hmy.utils.numToStr(expected);
 * console.log(num);
 * ```
 *
 * ### Step 3: Using unit class to convet the token unit
 * ```javascript
 * // convert one to Gwei
 * const one = new hmy.utils.Unit('1').asOne();
 * const oneToGwei = one.toGwei();
 * console.log(oneToGwei);
 * ```
 *
 * ## Some Important consts and Enums
 * ### Chain Type
 * ```javascript
 * Harmony = 'hmy',
 * Ethereum = 'eth',
 * ```
 *
 * ### Chain ID
 * ```javascript
 * Default = 0,
  EthMainnet = 1,
  Morden = 2,
  Ropsten = 3,
  Rinkeby = 4,
  RootstockMainnet = 30,
  RootstockTestnet = 31,
  Kovan = 42,
  EtcMainnet = 61,
  EtcTestnet = 62,
  Geth = 1337,
  Ganache = 0,
  HmyMainnet = 1,
  HmyTestnet = 2,
  HmyLocal = 2,
  HmyPangaea = 3,
 * ```
 *
 * ### Default Config
 * ```javascript
 * export const defaultConfig = {
 *   Default: {
 *     Chain_ID: ChainID.HmyLocal,
 *     Chain_Type: ChainType.Harmony,
 *     Chain_URL: 'http://localhost:9500',
 *     Network_ID: 'Local',
 * },
 *   DefaultWS: {
 *     Chain_ID: ChainID.HmyLocal,
 *     Chain_Type: ChainType.Harmony,
 *     Chain_URL: 'ws://localhost:9800',
 *     Network_ID: 'LocalWS',
 *   },
 * };
 * ```
 *
 * ### Unit Map
 * ```
 * [Units.wei, '1'], // 1 wei
 * [Units.Kwei, '1000'], // 1e3 wei
 * [Units.Mwei, '1000000'], // 1e6 wei
 * [Units.Gwei, '1000000000'], // 1e9 wei
 * [Units.szabo, '1000000000000'], // 1e12 wei
 * [Units.finney, '1000000000000000'], // 1e15 wei
 * [Units.ether, '1000000000000000000'], // 1e18 wei
 * [Units.one, '1000000000000000000'], // 1e18 wei
 * [Units.Kether, '1000000000000000000000'], // 1e21 wei
 * [Units.Mether, '1000000000000000000000000'], // 1e24 wei
 * [Units.Gether, '1000000000000000000000000000'], // 1e27 wei
 * [Units.Tether, '1000000000000000000000000000000'], // 1e30 wei
 * ```
 *
 * @packageDocumentation
 * @module harmony-utils
 */
(function (ChainType) {
    ChainType["Harmony"] = "hmy";
    ChainType["Ethereum"] = "eth";
})(exports.ChainType || (exports.ChainType = {}));
(function (ChainID) {
    ChainID[ChainID["Default"] = 0] = "Default";
    ChainID[ChainID["EthMainnet"] = 1] = "EthMainnet";
    ChainID[ChainID["Morden"] = 2] = "Morden";
    ChainID[ChainID["Ropsten"] = 3] = "Ropsten";
    ChainID[ChainID["Rinkeby"] = 4] = "Rinkeby";
    ChainID[ChainID["RootstockMainnet"] = 30] = "RootstockMainnet";
    ChainID[ChainID["RootstockTestnet"] = 31] = "RootstockTestnet";
    ChainID[ChainID["Kovan"] = 42] = "Kovan";
    ChainID[ChainID["EtcMainnet"] = 61] = "EtcMainnet";
    ChainID[ChainID["EtcTestnet"] = 62] = "EtcTestnet";
    ChainID[ChainID["Geth"] = 1337] = "Geth";
    ChainID[ChainID["Ganache"] = 0] = "Ganache";
    ChainID[ChainID["HmyMainnet"] = 1] = "HmyMainnet";
    ChainID[ChainID["HmyTestnet"] = 2] = "HmyTestnet";
    ChainID[ChainID["HmyLocal"] = 2] = "HmyLocal";
    ChainID[ChainID["HmyPangaea"] = 3] = "HmyPangaea";
})(exports.ChainID || (exports.ChainID = {}));
/** @hidden */
var defaultConfig = {
    Default: {
        Chain_ID: 2 /* HmyLocal */,
        Chain_Type: "hmy" /* Harmony */,
        Chain_URL: 'http://localhost:9500',
        Network_ID: 'Local',
    },
    DefaultWS: {
        Chain_ID: 2 /* HmyLocal */,
        Chain_Type: "hmy" /* Harmony */,
        Chain_URL: 'ws://localhost:9800',
        Network_ID: 'LocalWS',
    },
};
/** @hidden */
var HarmonyCore = /** @class */ (function () {
    function HarmonyCore(chainType, chainId) {
        if (chainId === void 0) { chainId = defaultConfig.Default.Chain_ID; }
        this.chainType = chainType;
        this.chainId = chainId;
    }
    Object.defineProperty(HarmonyCore.prototype, "chainPrefix", {
        get: function () {
            switch (this.chainType) {
                case "eth" /* Ethereum */: {
                    return 'eth';
                }
                case "hmy" /* Harmony */: {
                    return 'hmy';
                }
                default: {
                    return 'hmy';
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HarmonyCore.prototype, "getChainId", {
        get: function () {
            return this.chainId;
        },
        enumerable: false,
        configurable: true
    });
    HarmonyCore.prototype.setChainId = function (chainId) {
        this.chainId = chainId;
    };
    HarmonyCore.prototype.setChainType = function (chainType) {
        this.chainType = chainType;
    };
    return HarmonyCore;
}());
/** @hidden */
var HDPath = "m/44'/1023'/0'/0/";
/** @hidden */
var AddressSuffix = '-';

/**
 * @packageDocumentation
 * @module harmony-utils
 * @hidden
 */
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}

/**
 * @packageDocumentation
 * @module harmony-utils
 * @ignore
 */

exports.isKeyString = isKeyString;
exports.isAddress = isAddress;
exports.isPrivateKey = isPrivateKey;
exports.isPublicKey = isPublicKey;
exports.isHash = isHash;
exports.isNumber = isNumber;
exports.isInt = isInt;
exports.isString = isString;
exports.isBoolean = isBoolean;
exports.isArray = isArray;
exports.isJsonString = isJsonString;
exports.isObject = isObject;
exports.isFunction = isFunction;
exports.isHex = isHex;
exports.isHttp = isHttp;
exports.isWs = isWs;
exports.isBlockNumber = isBlockNumber;
exports.isBech32Address = isBech32Address;
exports.isBech32TestNetAddress = isBech32TestNetAddress;
exports.isValidAddress = isValidAddress;
exports.unitMap = unitMap;
exports.numberToString = numberToString;
exports.numToStr = numToStr;
exports.add0xToString = add0xToString;
exports.strip0x = strip0x;
exports.numberToHex = numberToHex;
exports.hexToNumber = hexToNumber;
exports.hexToBN = hexToBN;
exports.toWei = toWei;
exports.fromWei = fromWei;
exports.Unit = Unit;
exports.validatorArray = validatorArray;
exports.validateArgs = validateArgs;
exports.generateValidateObjects = generateValidateObjects;
exports.assertObject = assertObject;
exports.defaultConfig = defaultConfig;
exports.HarmonyCore = HarmonyCore;
exports.HDPath = HDPath;
exports.AddressSuffix = AddressSuffix;
exports.defineReadOnly = defineReadOnly;
//# sourceMappingURL=index.cjs.js.map
