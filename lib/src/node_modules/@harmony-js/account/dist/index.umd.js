/**
 * Test Banner
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@harmony-js/network'), require('@harmony-js/crypto'), require('@harmony-js/utils'), require('@harmony-js/transaction')) :
    typeof define === 'function' && define.amd ? define(['exports', '@harmony-js/network', '@harmony-js/crypto', '@harmony-js/utils', '@harmony-js/transaction'], factory) :
    (factory((global.harmonyAccount = {}),global['@harmony-js/network'],global['@harmony-js/crypto'],global['@harmony-js/utils'],global['@harmony-js/transaction']));
}(this, (function (exports,network,crypto,utils,transaction) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @packageDocumentation
     * @module harmony-account
     * @hidden
     */
    var defaultMessenger = new network.Messenger(new network.HttpProvider('http://localhost:9500'), "hmy" /* Harmony */, 2 /* HmyLocal */);

    /**
     * @packageDocumentation
     * @module harmony-account
     *
     */
    var Account = /** @class */ (function () {
        /**
         * Generate an account object
         *
         * @param key import an existing privateKey, or create a random one
         * @param messenger you can setMessage later, or set message on `new`
         *
         * @example
         * ```javascript
         * // import the Account class
         * const { Account } = require('@harmony-js/account');
         *
         * // Messenger is optional, by default, we have a defaultMessenger
         * // If you like to change, you will import related package here.
         * const { HttpProvider, Messenger } = require('@harmony-js/network');
         * const { ChainType, ChainID } = require('@harmony-js/utils');
         *
         * // create a custom messenger
         * const customMessenger = new Messenger(
         *   new HttpProvider('http://localhost:9500'),
         *   ChainType.Harmony, // if you are connected to Harmony's blockchain
         *   ChainID.HmyLocal, // check if the chainId is correct
         * )
         *
         * // setMessenger later
         * const randomAccount = new Account()
         * randomAccount.setMessenger(customMessenger)
         *
         * // or you can set messenger on `new`
         * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)
         *
         * // NOTED: Key with or without `0x` are accepted, makes no different
         * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead
         * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'
         * const myAccountWithMyPrivateKey = new Account(myPrivateKey)
         * ```
         */
        function Account(key, messenger) {
            if (messenger === void 0) { messenger = defaultMessenger; }
            /**@hidden */
            this.balance = '0';
            /**@hidden */
            this.nonce = 0;
            /**@hidden */
            this.encrypted = false;
            this.messenger = messenger;
            if (!key) {
                this._new();
            }
            else {
                this._import(key);
            }
            this.shardID = this.messenger.currentShard || 0;
            this.shards = new Map();
            this.shards.set(this.shardID, {
                address: "" + this.bech32Address + utils.AddressSuffix + "0",
                balance: this.balance || '0',
                nonce: this.nonce || 0,
            });
        }
        /**
         * static method create account
         *
         * @example
         * ```javascript
         * const account = new Account();
         * console.log(account);
         * ```
         */
        Account.new = function () {
            var newAcc = new Account()._new();
            return newAcc;
        };
        /**
         * Static Method: add a private key to Account
         * @param  {string} key - private Key
         *
         * @example
         * ```javascript
         * const account = new Account.add(key_1);
         * console.log(account);
         * ```
         */
        Account.add = function (key) {
            var newAcc = new Account()._import(key);
            return newAcc;
        };
        Object.defineProperty(Account.prototype, "checksumAddress", {
            /**
             * check sum address
             *
             * @example
             * ```javascript
             * console.log(account.checksumAddress);
             * ```
             */
            get: function () {
                return this.address ? crypto.getAddress(this.address).checksum : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Account.prototype, "bech32Address", {
            /**
             * Get bech32 Address
             *
             * @example
             * ```javascript
             * console.log(account.bech32Address);
             * ```
             */
            get: function () {
                return this.address ? crypto.getAddress(this.address).bech32 : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Account.prototype, "bech32TestNetAddress", {
            /**
             * get Bech32 TestNet Address
             *
             * @example
             * ```javascript
             * console.log(account.bech32TestNetAddress);
             * ```
             */
            get: function () {
                return this.address ? crypto.getAddress(this.address).bech32TestNet : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Account.prototype, "getShardsCount", {
            /**
             * get Shards number with this Account
             *
             * @example
             * ```javascript
             * console.log(account.getShardsCount);
             * ```
             */
            get: function () {
                return this.shards.size;
            },
            enumerable: false,
            configurable: true
        });
        Account.prototype.toFile = function (password, options) {
            return __awaiter(this, void 0, void 0, function () {
                var file;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.privateKey && utils.isPrivateKey(this.privateKey))) return [3 /*break*/, 2];
                            return [4 /*yield*/, crypto.encrypt(this.privateKey, password, options)];
                        case 1:
                            file = _a.sent();
                            this.privateKey = file;
                            this.encrypted = true;
                            return [2 /*return*/, file];
                        case 2: throw new Error('Encryption failed because PrivateKey is not correct');
                    }
                });
            });
        };
        Account.prototype.fromFile = function (keyStore, password) {
            return __awaiter(this, void 0, void 0, function () {
                var file, decyptedPrivateKey, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            if (typeof password !== 'string') {
                                throw new Error('you must provide password');
                            }
                            file = JSON.parse(keyStore.toLowerCase());
                            return [4 /*yield*/, crypto.decrypt(file, password)];
                        case 1:
                            decyptedPrivateKey = _a.sent();
                            if (utils.isPrivateKey(decyptedPrivateKey)) {
                                return [2 /*return*/, this._import(decyptedPrivateKey)];
                            }
                            else {
                                throw new Error('decrypted failed');
                            }
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Get the account balance
         *
         * @param blockNumber by default, it's `latest`
         *
         * @example
         * ```javascript
         * account.getBalance().then((value) => {
         *   console.log(value);
         * });
         * ```
         */
        Account.prototype.getBalance = function (blockNumber) {
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            return __awaiter(this, void 0, void 0, function () {
                var balance, nonce, error_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 5, , 6]);
                            if (!this.messenger) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.messenger.send("hmy_getBalance" /* GetBalance */, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];
                        case 1:
                            balance = _a.sent();
                            return [4 /*yield*/, this.messenger.send("hmy_getTransactionCount" /* GetTransactionCount */, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];
                        case 2:
                            nonce = _a.sent();
                            if (balance.isError()) {
                                throw balance.error.message;
                            }
                            if (nonce.isError()) {
                                throw nonce.error.message;
                            }
                            this.balance = utils.hexToNumber(balance.result);
                            this.nonce = Number.parseInt(utils.hexToNumber(nonce.result), 10);
                            this.shardID = this.messenger.currentShard || 0;
                            return [3 /*break*/, 4];
                        case 3: throw new Error('No Messenger found');
                        case 4: return [2 /*return*/, {
                                balance: this.balance,
                                nonce: this.nonce,
                                shardID: this.shardID,
                            }];
                        case 5:
                            error_2 = _a.sent();
                            throw error_2;
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @function updateShards
         */
        Account.prototype.updateBalances = function (blockNumber) {
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            return __awaiter(this, void 0, void 0, function () {
                var shardProviders, shardProviders_1, shardProviders_1_1, _a, name_1, val, balanceObject, e_1_1, currentShard;
                var e_1, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            shardProviders = this.messenger.shardProviders;
                            if (!(shardProviders.size > 1)) return [3 /*break*/, 10];
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 7, 8, 9]);
                            shardProviders_1 = __values(shardProviders), shardProviders_1_1 = shardProviders_1.next();
                            _c.label = 2;
                        case 2:
                            if (!!shardProviders_1_1.done) return [3 /*break*/, 6];
                            _a = __read(shardProviders_1_1.value, 2), name_1 = _a[0], val = _a[1];
                            return [4 /*yield*/, this.getShardBalance(val.shardID, blockNumber)];
                        case 3:
                            balanceObject = _c.sent();
                            return [4 /*yield*/, this.shards.set(name_1 === val.shardID ? name_1 : val.shardID, balanceObject)];
                        case 4:
                            _c.sent();
                            _c.label = 5;
                        case 5:
                            shardProviders_1_1 = shardProviders_1.next();
                            return [3 /*break*/, 2];
                        case 6: return [3 /*break*/, 9];
                        case 7:
                            e_1_1 = _c.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 9];
                        case 8:
                            try {
                                if (shardProviders_1_1 && !shardProviders_1_1.done && (_b = shardProviders_1.return)) _b.call(shardProviders_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 9: return [3 /*break*/, 12];
                        case 10: return [4 /*yield*/, this.getShardBalance(this.messenger.currentShard || 0, blockNumber)];
                        case 11:
                            currentShard = _c.sent();
                            this.shards.set(this.messenger.currentShard || 0, currentShard);
                            _c.label = 12;
                        case 12: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @function signTransaction
         */
        Account.prototype.signTransaction = function (transaction$$1, updateNonce, encodeMode, blockNumber) {
            if (updateNonce === void 0) { updateNonce = true; }
            if (encodeMode === void 0) { encodeMode = 'rlp'; }
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            return __awaiter(this, void 0, void 0, function () {
                var txShardID, shardBalanceObject, shardNonce, _a, signature_1, rawTransaction_1;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.privateKey || !utils.isPrivateKey(this.privateKey)) {
                                throw new Error(this.privateKey + " is not found or not correct");
                            }
                            if (!updateNonce) return [3 /*break*/, 2];
                            txShardID = transaction$$1.txParams.shardID;
                            return [4 /*yield*/, this.getShardBalance(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];
                        case 1:
                            shardBalanceObject = _b.sent();
                            if (shardBalanceObject !== undefined) {
                                shardNonce = shardBalanceObject.nonce;
                                transaction$$1.setParams(__assign(__assign({}, transaction$$1.txParams), { from: this.messenger.chainPrefix === "hmy" /* Harmony */
                                        ? this.bech32Address
                                        : this.checksumAddress || '0x', nonce: shardNonce }));
                            }
                            else {
                                transaction$$1.setParams(__assign(__assign({}, transaction$$1.txParams), { from: this.messenger.chainPrefix === "hmy" /* Harmony */
                                        ? this.bech32Address
                                        : this.checksumAddress || '0x', nonce: 0 }));
                            }
                            _b.label = 2;
                        case 2:
                            if (encodeMode === 'rlp') {
                                _a = __read(transaction.RLPSign(transaction$$1, this.privateKey), 2), signature_1 = _a[0], rawTransaction_1 = _a[1];
                                return [2 /*return*/, transaction$$1.map(function (obj) {
                                        return __assign(__assign({}, obj), { signature: signature_1,
                                            rawTransaction: rawTransaction_1, from: _this.messenger.chainPrefix === "hmy" /* Harmony */
                                                ? _this.bech32Address
                                                : _this.checksumAddress || '0x' });
                                    })];
                            }
                            else {
                                // TODO: if we use other encode method, eg. protobuf, we should implement this
                                return [2 /*return*/, transaction$$1];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * This function is still in development, coming soon!
         *
         * @param staking
         * @param updateNonce
         * @param encodeMode
         * @param blockNumber
         * @param shardID
         */
        Account.prototype.signStaking = function (staking, updateNonce, encodeMode, blockNumber, shardID) {
            if (updateNonce === void 0) { updateNonce = true; }
            if (encodeMode === void 0) { encodeMode = 'rlp'; }
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            if (shardID === void 0) { shardID = this.messenger.currentShard; }
            return __awaiter(this, void 0, void 0, function () {
                var txShardID, shardBalanceObject, shardNonce, _a, signature, rawTransaction;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.privateKey || !utils.isPrivateKey(this.privateKey)) {
                                throw new Error(this.privateKey + " is not found or not correct");
                            }
                            if (!updateNonce) return [3 /*break*/, 2];
                            txShardID = shardID;
                            return [4 /*yield*/, this.getShardBalance(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];
                        case 1:
                            shardBalanceObject = _b.sent();
                            if (shardBalanceObject !== undefined) {
                                shardNonce = shardBalanceObject.nonce;
                                staking.setFromAddress(this.messenger.chainPrefix === "hmy" /* Harmony */
                                    ? this.bech32Address
                                    : this.checksumAddress || '0x');
                                staking.setNonce(shardNonce);
                            }
                            else {
                                staking.setFromAddress(this.messenger.chainPrefix === "hmy" /* Harmony */
                                    ? this.bech32Address
                                    : this.checksumAddress || '0x');
                                staking.setNonce(0);
                            }
                            _b.label = 2;
                        case 2:
                            if (encodeMode === 'rlp') {
                                _a = __read(staking.rlpSign(this.privateKey), 2), signature = _a[0], rawTransaction = _a[1];
                                staking.setRawTransaction(rawTransaction);
                                staking.setSignature(signature);
                                staking.setFromAddress(this.messenger.chainPrefix === "hmy" /* Harmony */
                                    ? this.bech32Address
                                    : this.checksumAddress || '0x');
                                return [2 /*return*/, staking];
                            }
                            else {
                                // TODO: if we use other encode method, eg. protobuf, we should implement this
                                return [2 /*return*/, staking];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @param messenger
         *
         * @example
         * ```javascript
         * // create a custom messenger
         * const customMessenger = new Messenger(
         *   new HttpProvider('http://localhost:9500'),
         *   ChainType.Harmony, // if you are connected to Harmony's blockchain
         *   ChainID.HmyLocal, // check if the chainId is correct
         * )
         *
         * // to create an Account with random privateKey
         * // and you can setMessenger later
         * const randomAccount = new Account()
         * randomAccount.setMessenger(customMessenger)
         * ```
         */
        Account.prototype.setMessenger = function (messenger) {
            this.messenger = messenger;
        };
        /**
         * Get account address from shard ID
         * @param shardID
         *
         * @example
         * ```javascript
         * console.log(account.getAddressFromShardID(0));
         *
         * > one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0
         * ```
         */
        Account.prototype.getAddressFromShardID = function (shardID) {
            var shardObject = this.shards.get(shardID);
            if (shardObject) {
                return shardObject.address;
            }
            else {
                return undefined;
            }
        };
        /**
         * Get all shards' addresses from the account
         *
         * @example
         * ```javascript
         * console.log(account.getAddresses());
         * ```
         */
        Account.prototype.getAddresses = function () {
            var e_2, _a;
            var addressArray = [];
            try {
                for (var _b = __values(this.shards), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_2 = _d[0], val = _d[1];
                    var index = typeof name_2 === 'string' ? Number.parseInt(name_2, 10) : name_2;
                    addressArray[index] = val.address;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return addressArray;
        };
        /**
         * Get the specific shard's balance
         *
         * @param shardID `shardID` is binding with the endpoint, IGNORE it!
         * @param blockNumber by default, it's `latest`
         *
         * @example
         * ```
         * account.getShardBalance().then((value) => {
         *   console.log(value);
         * });
         * ```
         */
        Account.prototype.getShardBalance = function (shardID, blockNumber) {
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            return __awaiter(this, void 0, void 0, function () {
                var balance, nonce;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.messenger.send("hmy_getBalance" /* GetBalance */, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];
                        case 1:
                            balance = _a.sent();
                            return [4 /*yield*/, this.messenger.send("hmy_getTransactionCount" /* GetTransactionCount */, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];
                        case 2:
                            nonce = _a.sent();
                            if (balance.isError()) {
                                throw balance.error.message;
                            }
                            if (nonce.isError()) {
                                throw nonce.error.message;
                            }
                            return [2 /*return*/, {
                                    address: "" + this.bech32Address + utils.AddressSuffix + shardID,
                                    balance: utils.hexToNumber(balance.result),
                                    nonce: Number.parseInt(utils.hexToNumber(nonce.result), 10),
                                }];
                    }
                });
            });
        };
        /**
         * @function _new private method create Account
         * @return {Account} Account instance
         * @ignore
         */
        Account.prototype._new = function () {
            var prv = crypto.generatePrivateKey();
            if (!utils.isPrivateKey(prv)) {
                throw new Error('key gen failed');
            }
            return this._import(prv);
        };
        /**
         * @function _import private method import a private Key
         * @param  {string} key - private key
         * @return {Account} Account instance
         * @ignore
         */
        Account.prototype._import = function (key) {
            if (!utils.isPrivateKey(key)) {
                throw new Error(key + " is not PrivateKey");
            }
            this.privateKey = utils.add0xToString(key);
            this.publicKey = crypto.getPubkeyFromPrivateKey(this.privateKey);
            this.address = crypto.getAddressFromPrivateKey(this.privateKey);
            this.shardID = this.messenger.currentShard || 0;
            this.shards = new Map();
            this.shards.set(this.shardID, {
                address: "" + this.bech32Address + utils.AddressSuffix + "0",
                balance: this.balance || '0',
                nonce: this.nonce || 0,
            });
            this.encrypted = false;
            return this;
        };
        return Account;
    }());

    /**
     * @packageDocumentation
     * @module harmony-account
     */
    var Wallet = /** @class */ (function () {
        /**
         * @example
         * ```
         * const { Wallet } = require('@harmony-js/account');
         * const { HttpProvider, Messenger } = require('@harmony-js/network');
         * const { ChainType, ChainID } = require('@harmony-js/utils');
         *
         * // create a custom messenger
         * const customMessenger = new Messenger(
         *   new HttpProvider('http://localhost:9500'),
         *   ChainType.Harmony, // if you are connected to Harmony's blockchain
         *   ChainID.HmyLocal, // check if the chainId is correct
         * )
         *
         * const wallet = new Wallet(customMessenger);
         * ```
         */
        function Wallet(messenger) {
            if (messenger === void 0) { messenger = defaultMessenger; }
            /**
             * @hidden
             */
            this.accountMap = new Map();
            this.messenger = messenger;
        }
        // static method generate Mnemonic
        Wallet.generateMnemonic = function () {
            return crypto.bip39.generateMnemonic();
        };
        Object.defineProperty(Wallet.prototype, "accounts", {
            /**
             * get acounts addresses
             *
             * @return {string[]} accounts addresses
             *
             * @example
             * ```javascript
             * const wallet = new Wallet(customMessenger);
             * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
             * wallet.addByPrivateKey(key_1);
             *
             * console.log(wallet.accounts);
             * ```
             */
            get: function () {
                return __spread(this.accountMap.keys());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Wallet.prototype, "signer", {
            /**
             * get the signer of the account, by default, using the first account
             *
             * @example
             * ```javascript
             * const wallet = new Wallet(customMessenger);
             * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
             * wallet.addByPrivateKey(key_1);
             *
             * console.log(wallet.signer)
             * ```
             */
            get: function () {
                if (this.defaultSigner) {
                    return this.getAccount(this.defaultSigner);
                }
                else if (!this.defaultSigner && this.accounts.length > 0) {
                    this.setSigner(this.accounts[0]);
                    return this.getAccount(this.accounts[0]);
                }
                else {
                    return undefined;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @function newMnemonic
         * @memberof Wallet
         * @return {string} Mnemonics
         */
        Wallet.prototype.newMnemonic = function () {
            return Wallet.generateMnemonic();
        };
        /**
         * Add account using Mnemonic phrases
         * @param  {string} phrase - Mnemonic phrase
         * @param  {index} index - index to hdKey root
         *
         * @example
         * ```javascript
         * const mnemonic_1 = 'urge clog right example dish drill card maximum mix bachelor section select';
         * const wallet = new Wallet(customMessenger);
         * wallet.addByMnemonic(mnemonic_1);
         *
         * console.log(wallet.accounts);
         * ```
         */
        Wallet.prototype.addByMnemonic = function (phrase, index) {
            if (index === void 0) { index = 0; }
            if (!this.isValidMnemonic(phrase)) {
                throw new Error("Invalid mnemonic phrase: " + phrase);
            }
            var seed = crypto.bip39.mnemonicToSeed(phrase);
            var hdKey = crypto.hdkey.fromMasterSeed(seed);
            // TODO:hdkey should apply to Harmony's settings
            var path = this.messenger.chainType === "hmy" /* Harmony */ ? '1023' : '60';
            var childKey = hdKey.derive("m/44'/" + path + "'/0'/0/" + index);
            var privateKey = childKey.privateKey.toString('hex');
            return this.addByPrivateKey(privateKey);
        };
        /**
         * Add an account using privateKey
         *
         * @param  {string} privateKey - privateKey to add
         * @return {Account} return added Account
         *
         * @example
         * ```javascript
         * const wallet = new Wallet(customMessenger);
         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
         * console.log(wallet.addByPrivateKey(key_1));
         * ```
         */
        Wallet.prototype.addByPrivateKey = function (privateKey) {
            try {
                var newAcc = Account.add(privateKey);
                newAcc.setMessenger(this.messenger);
                if (newAcc.address) {
                    this.accountMap.set(newAcc.address, newAcc);
                    if (!this.defaultSigner) {
                        this.setSigner(newAcc.address);
                    }
                    return newAcc;
                }
                else {
                    throw new Error('add account failed');
                }
            }
            catch (error) {
                throw error;
            }
        };
        /**
         * Add an account using privateKey
         * @param  {string} keyStore - keystore jsonString to add
         * @param  {string} password - password to decrypt the file
         * @return {Account} return added Account
         */
        Wallet.prototype.addByKeyStore = function (keyStore, password) {
            return __awaiter(this, void 0, void 0, function () {
                var newAcc, result, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            newAcc = new Account(undefined);
                            return [4 /*yield*/, newAcc.fromFile(keyStore, password)];
                        case 1:
                            result = _a.sent();
                            result.setMessenger(this.messenger);
                            if (result.address) {
                                this.accountMap.set(result.address, result);
                                if (!this.defaultSigner) {
                                    this.setSigner(result.address);
                                }
                                return [2 /*return*/, result];
                            }
                            else {
                                throw new Error('add account failed');
                            }
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * create a new account using Mnemonic
         * @return {Account} {description}
         *
         * @example
         * ```javascript
         * console.log(wallet.accounts);
         * wallet.createAccount();
         * wallet.createAccount();
         *
         * console.log(wallet.accounts);
         * ````
         */
        Wallet.prototype.createAccount = function (password, options) {
            return __awaiter(this, void 0, void 0, function () {
                var prv, acc, encrypted;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            prv = crypto.generatePrivateKey();
                            acc = this.addByPrivateKey(prv);
                            if (!(acc.address && password)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.encryptAccount(acc.address, password, options)];
                        case 1:
                            encrypted = _a.sent();
                            return [2 /*return*/, encrypted];
                        case 2:
                            if (acc.address && !password) {
                                return [2 /*return*/, acc];
                            }
                            else {
                                throw new Error('create acount failed');
                            }
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * To encrypt an account that lives in the wallet.
         * if encrypted, returns original one, if not found, throw error
         * @param {string} address - address in accounts
         * @param {string} password - string that used to encrypt
         * @param {EncryptOptions} options - encryption options
         * @return {Promise<Account>}
         *
         * @example
         * ```javascript
         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
         * wallet.addByPrivateKey(key_1);
         * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345').then((value) => {
         *   console.log(value);
         * })
         * ```
         */
        Wallet.prototype.encryptAccount = function (address, password, options) {
            return __awaiter(this, void 0, void 0, function () {
                var foundAcc, error_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            foundAcc = this.getAccount(address);
                            if (!(foundAcc && foundAcc.privateKey && utils.isPrivateKey(foundAcc.privateKey))) return [3 /*break*/, 2];
                            return [4 /*yield*/, foundAcc.toFile(password, options)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, foundAcc];
                        case 2:
                            if (foundAcc && foundAcc.privateKey && !utils.isPrivateKey(foundAcc.privateKey)) {
                                return [2 /*return*/, foundAcc];
                            }
                            else {
                                throw new Error('encrypt account failed');
                            }
                            _a.label = 3;
                        case 3: return [3 /*break*/, 5];
                        case 4:
                            error_2 = _a.sent();
                            throw error_2;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * To decrypt an account that lives in the wallet,if not encrypted, return original,
         * if not found, throw error
         * @param {string} address - address in accounts
         * @param {string} password - string that used to encrypt
         * @return {Promise<Account>}
         *
         * @example
         * ```javascript
         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
         * wallet.addByPrivateKey(key_1);
         * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')
         * .then(() => {
         *   wallet.decryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')
         *   .then((value) =>{
         *      console.log(value);
         *   });
         * });
         * ```
         */
        Wallet.prototype.decryptAccount = function (address, password) {
            return __awaiter(this, void 0, void 0, function () {
                var foundAcc, error_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            foundAcc = this.getAccount(address);
                            if (!(foundAcc && foundAcc.privateKey && !utils.isPrivateKey(foundAcc.privateKey))) return [3 /*break*/, 2];
                            return [4 /*yield*/, foundAcc.fromFile(foundAcc.privateKey, password)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, foundAcc];
                        case 2:
                            if (foundAcc && foundAcc.privateKey && utils.isPrivateKey(foundAcc.privateKey)) {
                                foundAcc.encrypted = false;
                                return [2 /*return*/, foundAcc];
                            }
                            else {
                                throw new Error('decrypt account failed');
                            }
                            _a.label = 3;
                        case 3: return [3 /*break*/, 5];
                        case 4:
                            error_3 = _a.sent();
                            throw error_3;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Get Account instance using address as param
         * @param  {string} address - address hex
         * @return {Account} Account instance which lives in Wallet
         *
         * @example
         * ```
         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';
         * wallet.addByPrivateKey(key_1);
         * console.log(wallet.getAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'));
         * ```
         */
        Wallet.prototype.getAccount = function (address) {
            return this.accountMap.get(crypto.getAddress(address).basicHex);
        };
        /**
         * @function removeAccount
         * @memberof Wallet
         * @description remove Account using address as param
         * @param  {string} address: - address hex
         */
        Wallet.prototype.removeAccount = function (address) {
            this.accountMap.delete(crypto.getAddress(address).basicHex);
            if (this.defaultSigner === address) {
                this.defaultSigner = undefined;
            }
        };
        /**
         * Set Customer Messenage
         * @param messenger
         *
         * @example
         * ```javascript
         * const customMessenger = new Messenger(
         *   new HttpProvider('https://api.s0.b.hmny.io'),
         *   ChainType.Harmony, // if you are connected to Harmony's blockchain
         *   ChainID.HmyLocal, // check if the chainId is correct
         * )
         * const wallet = new Wallet();
         * wallet.setMessenger(customMessenger);
         * console.log(wallet.messenger);
         * ```
         */
        Wallet.prototype.setMessenger = function (messenger) {
            this.messenger = messenger;
        };
        /**
         * Set signer
         *
         * @param address one of the address in the accounts
         */
        Wallet.prototype.setSigner = function (address) {
            if (!utils.isAddress(address) && !this.getAccount(address)) {
                throw new Error('could not set signer');
            }
            this.defaultSigner = address;
        };
        Wallet.prototype.signTransaction = function (transaction$$1, account, 
        // tslint:disable-next-line: no-unnecessary-initializer
        password, updateNonce, encodeMode, blockNumber) {
            if (account === void 0) { account = this.signer; }
            if (password === void 0) { password = undefined; }
            if (updateNonce === void 0) { updateNonce = true; }
            if (encodeMode === void 0) { encodeMode = 'rlp'; }
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            return __awaiter(this, void 0, void 0, function () {
                var toSignWith, decrypted, signed, error_4, signed, error_5;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            toSignWith = account || this.signer;
                            if (!toSignWith) {
                                throw new Error('no signer found or did not provide correct account');
                            }
                            if (!(toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 7];
                            if (!password) {
                                throw new Error('must provide password to further execution');
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 5, , 6]);
                            return [4 /*yield*/, this.decryptAccount(toSignWith.address, password)];
                        case 2:
                            decrypted = _a.sent();
                            return [4 /*yield*/, decrypted.signTransaction(transaction$$1, updateNonce, encodeMode, blockNumber)];
                        case 3:
                            signed = _a.sent();
                            return [4 /*yield*/, this.encryptAccount(toSignWith.address, password)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/, signed];
                        case 5:
                            error_4 = _a.sent();
                            throw error_4;
                        case 6: return [3 /*break*/, 13];
                        case 7:
                            if (!(toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 12];
                            _a.label = 8;
                        case 8:
                            _a.trys.push([8, 10, , 11]);
                            return [4 /*yield*/, toSignWith.signTransaction(transaction$$1, updateNonce, encodeMode, blockNumber)];
                        case 9:
                            signed = _a.sent();
                            return [2 /*return*/, signed];
                        case 10:
                            error_5 = _a.sent();
                            throw error_5;
                        case 11: return [3 /*break*/, 13];
                        case 12: throw new Error('sign transaction failed');
                        case 13: return [2 /*return*/];
                    }
                });
            });
        };
        Wallet.prototype.signStaking = function (staking, account, 
        // tslint:disable-next-line: no-unnecessary-initializer
        password, updateNonce, encodeMode, blockNumber, shardID) {
            if (account === void 0) { account = this.signer; }
            if (password === void 0) { password = undefined; }
            if (updateNonce === void 0) { updateNonce = true; }
            if (encodeMode === void 0) { encodeMode = 'rlp'; }
            if (blockNumber === void 0) { blockNumber = 'latest'; }
            if (shardID === void 0) { shardID = this.messenger.currentShard; }
            return __awaiter(this, void 0, void 0, function () {
                var toSignWith, decrypted, signed, error_6, signed, error_7;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            toSignWith = account || this.signer;
                            if (!toSignWith) {
                                throw new Error('no signer found or did not provide correct account');
                            }
                            if (!(toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 7];
                            if (!password) {
                                throw new Error('must provide password to further execution');
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 5, , 6]);
                            return [4 /*yield*/, this.decryptAccount(toSignWith.address, password)];
                        case 2:
                            decrypted = _a.sent();
                            return [4 /*yield*/, decrypted.signStaking(staking, updateNonce, encodeMode, blockNumber, shardID)];
                        case 3:
                            signed = _a.sent();
                            return [4 /*yield*/, this.encryptAccount(toSignWith.address, password)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/, signed];
                        case 5:
                            error_6 = _a.sent();
                            throw error_6;
                        case 6: return [3 /*break*/, 13];
                        case 7:
                            if (!(toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 12];
                            _a.label = 8;
                        case 8:
                            _a.trys.push([8, 10, , 11]);
                            return [4 /*yield*/, toSignWith.signStaking(staking, updateNonce, encodeMode, blockNumber, shardID)];
                        case 9:
                            signed = _a.sent();
                            return [2 /*return*/, signed];
                        case 10:
                            error_7 = _a.sent();
                            throw error_7;
                        case 11: return [3 /*break*/, 13];
                        case 12: throw new Error('sign transaction failed');
                        case 13: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @function isValidMnemonic
         * @memberof Wallet
         * @description check if Mnemonic is valid
         * @param  {string} phrase - Mnemonic phrase
         * @return {boolean}
         * @ignore
         */
        Wallet.prototype.isValidMnemonic = function (phrase) {
            if (phrase.trim().split(/\s+/g).length < 12) {
                return false;
            }
            return crypto.bip39.validateMnemonic(phrase);
        };
        return Wallet;
    }());

    /**
     * @packageDocumentation
     * @module harmony-account
     * @hidden
     */

    /**
     * @packageDocumentation
     * @module harmony-account
     */
    var HDNode = /** @class */ (function () {
        function HDNode(provider, menmonic, index, addressCount, shardID, chainType, chainId, gasLimit, gasPrice) {
            if (provider === void 0) { provider = 'http://localhost:9500'; }
            if (index === void 0) { index = 0; }
            if (addressCount === void 0) { addressCount = 1; }
            if (shardID === void 0) { shardID = 0; }
            if (chainType === void 0) { chainType = "hmy" /* Harmony */; }
            if (chainId === void 0) { chainId = 0 /* Default */; }
            if (gasLimit === void 0) { gasLimit = '1000000'; }
            if (gasPrice === void 0) { gasPrice = '2000000000'; }
            this.provider = this.setProvider(provider);
            this.shardID = shardID;
            this.messenger = new network.Messenger(this.provider, chainType, chainId);
            this.messenger.setDefaultShardID(this.shardID);
            this.hdwallet = undefined;
            this.addresses = [];
            this.wallets = {};
            this.path = chainType === "hmy" /* Harmony */ ? utils.HDPath : "m/44'/60'/0'/0/";
            this.index = index;
            this.addressCount = addressCount;
            this.getHdWallet(menmonic || HDNode.generateMnemonic());
            this.gasLimit = gasLimit;
            this.gasPrice = gasPrice;
        }
        HDNode.isValidMnemonic = function (phrase) {
            if (phrase.trim().split(/\s+/g).length < 12) {
                return false;
            }
            return crypto.bip39.validateMnemonic(phrase);
        };
        HDNode.generateMnemonic = function () {
            return crypto.bip39.generateMnemonic();
        };
        HDNode.prototype.normalizePrivateKeys = function (mnemonic) {
            if (Array.isArray(mnemonic)) {
                return mnemonic;
            }
            else if (mnemonic && !mnemonic.includes(' ')) {
                return [mnemonic];
            }
            else {
                return false;
            }
        };
        HDNode.prototype.setProvider = function (provider) {
            if (utils.isHttp(provider) && typeof provider === 'string') {
                return new network.HttpProvider(provider);
            }
            else if (provider instanceof network.HttpProvider) {
                return provider;
            }
            else if (utils.isWs(provider) && typeof provider === 'string') {
                return new network.WSProvider(provider);
            }
            else if (provider instanceof network.WSProvider) {
                return provider;
            }
            else {
                throw new Error('provider is not recognized');
            }
        };
        HDNode.prototype.getHdWallet = function (mnemonic) {
            if (!HDNode.isValidMnemonic(mnemonic)) {
                throw new Error('Mnemonic invalid or undefined');
            }
            this.hdwallet = crypto.hdkey.fromMasterSeed(crypto.bip39.mnemonicToSeed(mnemonic));
            for (var i = this.index; i < this.index + this.addressCount; i++) {
                if (!this.hdwallet) {
                    throw new Error('hdwallet is not found');
                }
                var childKey = this.hdwallet.derive("" + this.path + i);
                var prv = childKey.privateKey.toString('hex');
                var account = new Account(prv);
                var addr = account.checksumAddress;
                this.addresses.push(addr);
                this.wallets[addr] = account;
            }
        };
        // tslint:disable-next-line: ban-types
        HDNode.prototype.getAccounts = function (cb) {
            if (cb) {
                cb(null, this.addresses);
            }
            return this.addresses;
        };
        // tslint:disable-next-line: ban-types
        HDNode.prototype.getPrivateKey = function (address, cb) {
            if (!cb) {
                if (!this.wallets[address]) {
                    throw new Error('Account not found');
                }
                else {
                    return this.wallets[address].privateKey;
                }
            }
            if (!this.wallets[address]) {
                return cb('Account not found');
            }
            else {
                cb(null, this.wallets[address].privateKey);
            }
        };
        // tslint:disable-next-line: ban-types
        HDNode.prototype.signTransaction = function (txParams) {
            return __awaiter(this, void 0, void 0, function () {
                var from, accountNonce, to, gasLimit, gasPrice, value, nonce, data, prv, signerAccount, tx, signed;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            from = txParams.from ? crypto.getAddress(txParams.from).checksum : '0x';
                            return [4 /*yield*/, this.messenger.send('hmy_getTransactionCount', [from, 'latest'], 'hmy', this.shardID)];
                        case 1:
                            accountNonce = _a.sent();
                            to = txParams.to ? crypto.getAddress(txParams.to).checksum : '0x';
                            gasLimit = new utils.Unit('0').asWei().toWei();
                            if (txParams.gas !== undefined && utils.isHex(txParams.gas)) {
                                gasLimit = new utils.Unit(txParams.gas)
                                    .asWei()
                                    .toWei()
                                    .lt(new utils.Unit(this.gasLimit).asWei().toWei())
                                    ? new utils.Unit(txParams.gas).asWei().toWei()
                                    : new utils.Unit(this.gasLimit).asWei().toWei();
                            }
                            if (txParams.gasLimit !== undefined && utils.isHex(txParams.gasLimit)) {
                                gasLimit = new utils.Unit(txParams.gasLimit)
                                    .asWei()
                                    .toWei()
                                    .lt(new utils.Unit(this.gasLimit).asWei().toWei())
                                    ? new utils.Unit(txParams.gasLimit).asWei().toWei()
                                    : new utils.Unit(this.gasLimit).asWei().toWei();
                            }
                            gasPrice = new utils.Unit('0').asWei().toWei();
                            if (txParams.gasPrice !== undefined && utils.isHex(txParams.gasPrice)) {
                                gasPrice = new utils.Unit(txParams.gasPrice)
                                    .asWei()
                                    .toWei()
                                    .lt(new utils.Unit(this.gasPrice).asWei().toWei())
                                    ? new utils.Unit(txParams.gasPrice).asWei().toWei()
                                    : new utils.Unit(this.gasPrice).asWei().toWei();
                            }
                            value = txParams.value !== undefined && utils.isHex(txParams.value) ? txParams.value : '0';
                            nonce = txParams.nonce !== undefined && utils.isHex(txParams.nonce)
                                ? Number.parseInt(utils.hexToNumber(txParams.nonce), 10)
                                : Number.parseInt(utils.hexToNumber(accountNonce.result), 10);
                            data = txParams.data !== undefined && utils.isHex(txParams.data) ? txParams.data : '0x';
                            prv = this.wallets[from].privateKey;
                            signerAccount = new Account(prv, this.messenger);
                            tx = new transaction.Transaction(__assign(__assign({}, txParams), { from: from,
                                to: to,
                                gasLimit: gasLimit,
                                gasPrice: gasPrice,
                                value: value,
                                nonce: nonce,
                                data: data, shardID: this.shardID, chainId: this.messenger.chainId }), this.messenger, "INITIALIZED" /* INTIALIZED */);
                            return [4 /*yield*/, signerAccount.signTransaction(tx)];
                        case 2:
                            signed = _a.sent();
                            return [2 /*return*/, signed.getRawTransaction()];
                    }
                });
            });
        };
        HDNode.prototype.getAddress = function (idx) {
            if (!idx) {
                return this.addresses[0];
            }
            else {
                return this.addresses[idx];
            }
        };
        HDNode.prototype.getAddresses = function () {
            return this.addresses;
        };
        HDNode.prototype.addByPrivateKey = function (privateKey) {
            var account = new Account(privateKey);
            var addr = account.checksumAddress;
            this.addresses.push(addr);
            this.wallets[addr] = account;
            return addr;
        };
        HDNode.prototype.setSigner = function (address) {
            var foundIndex = this.addresses.findIndex(function (value) { return value === address; });
            this.addresses.slice(foundIndex, foundIndex + 1);
            this.addresses.unshift(address);
        };
        return HDNode;
    }());

    /**
     * @packageDocumentation
     * @module harmony-account
     * @ignore
     */

    exports.Account = Account;
    exports.Wallet = Wallet;
    exports.defaultMessenger = defaultMessenger;
    exports.HDNode = HDNode;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
