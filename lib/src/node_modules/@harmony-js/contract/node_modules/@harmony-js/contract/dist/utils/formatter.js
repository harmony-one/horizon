"use strict";
/**
 * @packageDocumentation
 * @module harmony-contract
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toTopic = exports.inputAddressFormatter = exports.isPredefinedBlockNumber = exports.inputBlockNumberFormatter = exports.outputLogFormatter = exports.inputLogFormatter = void 0;
var crypto_1 = require("@harmony-js/crypto");
var utils_1 = require("@harmony-js/utils");
var abiCoder_1 = require("../abi/abiCoder");
exports.inputLogFormatter = function (options) {
    if (options.fromBlock) {
        options.fromBlock = exports.inputBlockNumberFormatter(options.fromBlock);
    }
    if (options.toBlock) {
        options.toBlock = exports.inputBlockNumberFormatter(options.toBlock);
    }
    // make sure topics, get converted to hex
    options.topics = options.topics || [];
    options.topics = options.topics.map(function (topic) {
        return utils_1.isArray(topic) ? topic.map(exports.toTopic) : exports.toTopic(topic);
    });
    if (options.address) {
        if (utils_1.isArray(options.address)) {
            options.address = options.address.map(function (addr) {
                return exports.inputAddressFormatter(addr);
            });
        }
        else {
            options.address = exports.inputAddressFormatter(options.address);
        }
    }
    return options;
};
/**
 * Formats the output of a log
 *
 * @method outputLogFormatter
 *
 * @param {Object} log object
 *
 * @returns {Object} log
 */
exports.outputLogFormatter = function (log) {
    // generate a custom log id
    if (typeof log.blockHash === 'string' &&
        typeof log.transactionHash === 'string' &&
        typeof log.logIndex === 'string') {
        var shaId = crypto_1.keccak256('0x' +
            log.blockHash.replace('0x', '') +
            log.transactionHash.replace('0x', '') +
            log.logIndex.replace('0x', ''));
        shaId.replace('0x', '').substr(0, 8);
        log.id = "log_" + shaId;
    }
    else if (!log.id) {
        log.id = null;
    }
    if (log.blockNumber !== null) {
        log.blockNumber = utils_1.hexToBN(log.blockNumber).toNumber();
    }
    if (log.transactionIndex !== null) {
        log.transactionIndex = utils_1.hexToBN(log.transactionIndex).toNumber();
    }
    if (log.logIndex !== null) {
        log.logIndex = utils_1.hexToBN(log.logIndex).toNumber();
    }
    if (log.address) {
        log.address = crypto_1.toChecksumAddress(log.address);
    }
    return log;
};
exports.inputBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined || blockNumber === null || exports.isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    if (crypto_1.isHexString(blockNumber)) {
        if (utils_1.isString(blockNumber)) {
            return blockNumber.toLowerCase();
        }
        return blockNumber;
    }
    return utils_1.numberToHex(blockNumber);
};
exports.isPredefinedBlockNumber = function (blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
};
exports.inputAddressFormatter = function (address) {
    if (utils_1.isAddress(address)) {
        return "0x" + address.toLowerCase().replace('0x', '');
    }
    throw new Error("Provided address \"" + address + "\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.");
};
exports.toTopic = function (value) {
    if (value === null || typeof value === 'undefined') {
        return null;
    }
    value = String(value);
    if (value.indexOf('0x') === 0) {
        return value;
    }
    return crypto_1.hexlify(abiCoder_1.toUtf8Bytes(value));
};
//# sourceMappingURL=formatter.js.map