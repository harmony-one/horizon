"use strict";
/**
 * @packageDocumentation
 * @module harmony-contract
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bnToString = exports.flattenTypes = exports.jsonInterfaceMethodToString = void 0;
var utils_1 = require("@harmony-js/utils");
var crypto_1 = require("@harmony-js/crypto");
exports.jsonInterfaceMethodToString = function (json) {
    if (utils_1.isObject(json) && json.name && json.name.includes('(')) {
        return json.name;
    }
    return json.name + "(" + exports.flattenTypes(false, json.inputs).join(',') + ")";
};
exports.flattenTypes = function (includeTuple, puts) {
    // console.log("entered _flattenTypes. inputs/outputs: " + puts)
    var types = [];
    puts.forEach(function (param) {
        if (typeof param.components === 'object') {
            if (param.type.substring(0, 5) !== 'tuple') {
                throw new Error('components found but type is not tuple; report on GitHub');
            }
            var suffix = '';
            var arrayBracket = param.type.indexOf('[');
            if (arrayBracket >= 0) {
                suffix = param.type.substring(arrayBracket);
            }
            var result = exports.flattenTypes(includeTuple, param.components);
            // console.log("result should have things: " + result)
            if (utils_1.isArray(result) && includeTuple) {
                // console.log("include tuple word, and its an array. joining...: " + result.types)
                types.push("tuple(" + result.join(',') + ")" + suffix);
            }
            else if (!includeTuple) {
                // console.log("don't include tuple, but its an array. joining...: " + result)
                types.push("(" + result.join(',') + ")" + suffix);
            }
            else {
                // console.log("its a single type within a tuple: " + result.types)
                types.push("(" + result + ")");
            }
        }
        else {
            // console.log("its a type and not directly in a tuple: " + param.type)
            types.push(param.type);
        }
    });
    return types;
};
function bnToString(result) {
    if (crypto_1.BN.isBN(result)) {
        return result.toString();
    }
    else {
        return result;
    }
}
exports.bnToString = bnToString;
//# sourceMappingURL=utils.js.map