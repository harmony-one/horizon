/**
 * Test Banner
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@harmony-js/utils'), require('mitt'), require('cross-fetch'), require('websocket')) :
    typeof define === 'function' && define.amd ? define(['exports', '@harmony-js/utils', 'mitt', 'cross-fetch', 'websocket'], factory) :
    (factory((global.harmonyNetwork = {}),global['@harmony-js/utils'],global.mitt,global['cross-fetch'],global.websocket));
}(this, (function (exports,utils,mitt,fetch,websocket) { 'use strict';

    mitt = mitt && mitt.hasOwnProperty('default') ? mitt['default'] : mitt;
    fetch = fetch && fetch.hasOwnProperty('default') ? fetch['default'] : fetch;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var BaseProvider = /** @class */ (function () {
        function BaseProvider(url, reqMiddleware, resMiddleware) {
            var _this = this;
            if (reqMiddleware === void 0) { reqMiddleware = new Map(); }
            if (resMiddleware === void 0) { resMiddleware = new Map(); }
            this.middlewares = {
                request: {
                    use: function (fn, match) {
                        if (match === void 0) { match = '*'; }
                        _this.pushMiddleware(fn, 0 /* REQ */, match);
                    },
                },
                response: {
                    use: function (fn, match) {
                        if (match === void 0) { match = '*'; }
                        _this.pushMiddleware(fn, 1 /* RES */, match);
                    },
                },
            };
            this.reqMiddleware = new Map().set('*', []);
            this.resMiddleware = new Map().set('*', []);
            this.reqMiddleware = reqMiddleware;
            this.resMiddleware = resMiddleware;
            this.url = url;
        }
        BaseProvider.prototype.pushMiddleware = function (fn, type, match) {
            if (type !== 0 /* REQ */ && type !== 1 /* RES */) {
                throw new Error('Please specify the type of middleware being added');
            }
            if (type === 0 /* REQ */) {
                var current = this.reqMiddleware.get(match) || [];
                this.reqMiddleware.set(match, __spread(current, [fn]));
            }
            else {
                var current = this.resMiddleware.get(match) || [];
                this.resMiddleware.set(match, __spread(current, [fn]));
            }
        };
        BaseProvider.prototype.getMiddleware = function (method) {
            var e_1, _a, e_2, _b;
            var requests = [];
            var responses = [];
            try {
                for (var _c = __values(this.reqMiddleware.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), key = _e[0], transformers = _e[1];
                    if (typeof key === 'string' && key !== '*' && key === method) {
                        requests.push.apply(requests, __spread(transformers));
                    }
                    if (key instanceof RegExp && key.test(method)) {
                        requests.push.apply(requests, __spread(transformers));
                    }
                    if (key === '*') {
                        requests.push.apply(requests, __spread(transformers));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _f = __values(this.resMiddleware.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var _h = __read(_g.value, 2), key = _h[0], transformers = _h[1];
                    if (typeof key === 'string' && key !== '*' && key === method) {
                        responses.push.apply(responses, __spread(transformers));
                    }
                    if (key instanceof RegExp && key.test(method)) {
                        responses.push.apply(responses, __spread(transformers));
                    }
                    if (key === '*') {
                        responses.push.apply(responses, __spread(transformers));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return [requests, responses];
        };
        return BaseProvider;
    }());

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    (function (SocketConnection) {
        SocketConnection["READY"] = "ready";
        SocketConnection["CONNECT"] = "connect";
        SocketConnection["ERROR"] = "error";
        SocketConnection["CLOSE"] = "close";
    })(exports.SocketConnection || (exports.SocketConnection = {}));
    (function (SocketState) {
        SocketState["SOCKET_MESSAGE"] = "socket_message";
        SocketState["SOCKET_READY"] = "socket_ready";
        SocketState["SOCKET_CLOSE"] = "socket_close";
        SocketState["SOCKET_ERROR"] = "socket_error";
        SocketState["SOCKET_CONNECT"] = "socket_connect";
        SocketState["SOCKET_NETWORK_CHANGED"] = "socket_networkChanged";
        SocketState["SOCKET_ACCOUNTS_CHANGED"] = "socket_accountsChanged";
    })(exports.SocketState || (exports.SocketState = {}));
    (function (EmittType) {
        EmittType["INSTANCE"] = "instance";
        EmittType["PUBSUB"] = "pubsub";
    })(exports.EmittType || (exports.EmittType = {}));
    var BaseSocket = /** @class */ (function (_super) {
        __extends(BaseSocket, _super);
        function BaseSocket(url) {
            var _this = _super.call(this, url) || this;
            _this.handlers = {};
            if (!utils.isWs(url)) {
                throw new Error(url + " is not websocket");
            }
            _this.url = url;
            _this.emitter = mitt(_this.handlers);
            return _this;
        }
        BaseSocket.prototype.resetHandlers = function () {
            // tslint:disable-next-line: forin
            for (var i in this.handlers) {
                delete this.handlers[i];
            }
        };
        BaseSocket.prototype.once = function (type, handler) {
            this.emitter.on(type, handler);
            this.removeEventListener(type);
        };
        BaseSocket.prototype.addEventListener = function (type, handler) {
            this.emitter.on(type, handler);
        };
        BaseSocket.prototype.removeEventListener = function (type, handler) {
            if (!type) {
                this.handlers = {};
                return;
            }
            if (!handler) {
                delete this.handlers[type];
            }
            else {
                return this.emitter.off(type, handler);
            }
        };
        BaseSocket.prototype.reset = function () {
            this.removeEventListener('*');
            // this.registerEventListeners();
        };
        BaseSocket.prototype.removeAllSocketListeners = function () {
            this.removeEventListener("socket_message" /* SOCKET_MESSAGE */);
            this.removeEventListener("socket_ready" /* SOCKET_READY */);
            this.removeEventListener("socket_close" /* SOCKET_CLOSE */);
            this.removeEventListener("socket_error" /* SOCKET_ERROR */);
            this.removeEventListener("socket_connect" /* SOCKET_CONNECT */);
        };
        BaseSocket.prototype.onReady = function (event) {
            this.emitter.emit("ready" /* READY */, event);
            this.emitter.emit("socket_ready" /* SOCKET_READY */, event);
        };
        BaseSocket.prototype.onError = function (error) {
            this.emitter.emit("error" /* ERROR */, error);
            this.emitter.emit("socket_error" /* SOCKET_ERROR */, error);
            this.removeAllSocketListeners();
            this.removeEventListener('*');
        };
        BaseSocket.prototype.onClose = function (error) {
            if (error === void 0) { error = null; }
            this.emitter.emit("close" /* CLOSE */, error);
            this.emitter.emit("socket_close" /* SOCKET_CLOSE */, error);
            this.removeAllSocketListeners();
            this.removeEventListener('*');
        };
        return BaseSocket;
    }(BaseProvider));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var fetchRPC = {
        requestHandler: function (request, headers) {
            return fetch(request.url, {
                method: request.options && request.options.method ? request.options.method : 'POST',
                cache: 'no-cache',
                mode: 'cors',
                redirect: 'follow',
                referrer: 'no-referrer',
                body: JSON.stringify(request.payload),
                headers: __assign(__assign({}, headers), (request.options && request.options.headers ? request.options.headers : {})),
            });
        },
        responseHandler: function (response, request, handler) {
            return response
                .json()
                .then(function (body) {
                return __assign(__assign({}, body), { req: request });
            })
                .then(handler);
        },
    };

    /**
     * @packageDocumentation
     * @module harmony-network
     * @ignore
     */
    var DEFAULT_TIMEOUT = 120000;
    var DEFAULT_HEADERS = { 'Content-Type': 'application/json' };
    function _fetch(fetchPromise, timeout) {
        var abortFn;
        var abortPromise = new Promise(function (resolve, reject) {
            abortFn = function () { return reject(new Error("request Timeout in " + timeout + " ms")); };
        });
        var abortablePromise = Promise.race([fetchPromise, abortPromise]);
        setTimeout(function () {
            abortFn();
        }, timeout);
        return abortablePromise;
    }
    var performRPC = function (request, handler, fetcher) { return __awaiter(void 0, void 0, void 0, function () {
        var response, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, _fetch(fetcher.requestHandler(request, DEFAULT_HEADERS), request.options && request.options.timeout ? request.options.timeout : DEFAULT_TIMEOUT)];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, fetcher.responseHandler(response, request, handler)];
                case 2:
                    err_1 = _a.sent();
                    throw err_1;
                case 3: return [2 /*return*/];
            }
        });
    }); };
    function composeMiddleware() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        if (fns.length === 0) {
            return function (arg) { return arg; };
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return fns.reduce(function (a, b) { return function (arg) { return a(b(arg)); }; });
    }

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    /** @hidden */
    var defaultOptions = {
        method: 'POST',
        timeout: DEFAULT_TIMEOUT,
        headers: DEFAULT_HEADERS,
        user: null,
        password: null,
    };
    var HttpProvider = /** @class */ (function (_super) {
        __extends(HttpProvider, _super);
        function HttpProvider(url, options, fetcher) {
            var _this = _super.call(this, url) || this;
            _this.url = url || 'http://localhost:9500';
            _this.fetcher = fetcher || fetchRPC;
            if (options) {
                _this.options = {
                    method: options.method || defaultOptions.method,
                    timeout: options.timeout || defaultOptions.timeout,
                    user: options.user || defaultOptions.user,
                    password: options.password || defaultOptions.password,
                    headers: options.headers || defaultOptions.headers,
                };
            }
            else {
                _this.options = defaultOptions;
            }
            return _this;
        }
        /**
         * @function send
         * @memberof HttpProvider.prototype
         * @param  {Object} payload  - payload object
         * @param  {Function} callback - callback function
         * @return {any} - RPC Response
         */
        HttpProvider.prototype.send = function (payload, callback) {
            return this.requestFunc({ payload: payload, callback: callback });
        };
        /**
         * @function sendServer
         * @memberof HttpProvider.prototype
         * @param  {String} endpoint - endpoint to server
         * @param  {Object} payload  - payload object
         * @param  {Function} callback - callback function
         * @return {Function} - RPC Response
         */
        HttpProvider.prototype.sendServer = function (endpoint, payload, callback) {
            return this.requestFunc({ endpoint: endpoint, payload: payload, callback: callback });
        };
        HttpProvider.prototype.requestFunc = function (_a) {
            var _this = this;
            var endpoint = _a.endpoint, payload = _a.payload, callback = _a.callback;
            var _b = __read(this.getMiddleware(payload.method), 2), tReq = _b[0], tRes = _b[1];
            var reqMiddleware = composeMiddleware.apply(void 0, __spread(tReq, [function (obj) { return _this.optionsHandler(obj); },
                function (obj) { return _this.endpointHandler(obj, endpoint); }, this.payloadHandler]));
            var resMiddleware = composeMiddleware.apply(void 0, __spread([function (data) { return _this.callbackHandler(data, callback); }], tRes));
            var req = reqMiddleware(payload);
            return performRPC(req, resMiddleware, this.fetcher);
        };
        /**
         * @function payloadHandler
         * @memberof HttpProvider.prototype
         * @param  {Object} payload - payload object
         * @return {Object} - to payload object
         */
        HttpProvider.prototype.payloadHandler = function (payload) {
            return { payload: payload };
        };
        /**
         * @function endpointHandler
         * @memberof HttpProvider.prototype
         * @param  {Object} obj      - payload object
         * @param  {String} endpoint - add the endpoint to payload object
         * @return {Object} - assign a new object
         */
        HttpProvider.prototype.endpointHandler = function (obj, endpoint) {
            return __assign(__assign({}, obj), { url: endpoint !== null && endpoint !== undefined ? "" + this.url + endpoint : this.url });
        };
        /**
         * @function optionsHandler
         * @memberof HttpProvider.prototype
         * @param  {object} obj - options object
         * @return {object} - assign a new option object
         */
        HttpProvider.prototype.optionsHandler = function (obj) {
            if (this.options.user && this.options.password) {
                var AUTH_TOKEN = "Basic " + Buffer.from(this.options.user + ":" + this.options.password).toString('base64');
                this.options.headers.Authorization = AUTH_TOKEN;
            }
            return __assign(__assign({}, obj), { options: this.options });
        };
        /**
         * @function callbackHandler
         * @memberof HttpProvider.prototype
         * @param  {Object} data - from server
         * @param  {Function} cb   - callback function
         * @return {Object|Function} - return object or callback function
         */
        HttpProvider.prototype.callbackHandler = function (data, cb) {
            if (cb) {
                cb(null, data);
            }
            return data;
        };
        HttpProvider.prototype.subscribe = function () {
            throw new Error('HTTPProvider does not support subscriptions.');
        };
        HttpProvider.prototype.unsubscribe = function () {
            throw new Error('HTTPProvider does not support subscriptions.');
        };
        return HttpProvider;
    }(BaseProvider));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    /**
     * @class JsonRpc
     * @description json rpc instance
     * @return {JsonRpc} Json RPC instance
     */
    var JsonRpc = /** @class */ (function () {
        function JsonRpc() {
            var _this = this;
            /**
             * @function toPayload
             * @memberof JsonRpc.prototype
             * @description convert method and params to payload object
             * @param  {String} method - RPC method
             * @param  {Array<object>} params - params that send to RPC
             * @return {Object} payload object
             */
            this.toPayload = function (method, params) {
                // FIXME: error to be done by shared/errors
                if (!method) {
                    throw new Error('jsonrpc method should be specified!');
                }
                // advance message ID
                _this.messageId += 1;
                var sendParams = params === undefined ? [] : typeof params === 'string' ? [params] : __spread(params);
                return {
                    jsonrpc: '2.0',
                    id: _this.messageId,
                    method: method,
                    params: sendParams,
                };
            };
            /**
             * @var {Number} messageId
             * @memberof JsonRpc.prototype
             * @description message id, default 0
             */
            this.messageId = 0;
        }
        return JsonRpc;
    }());

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    var WSProvider = /** @class */ (function (_super) {
        __extends(WSProvider, _super);
        // ws: w3cwebsocket;
        function WSProvider(url, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, url) || this;
            if (!utils.isWs(url)) {
                throw new Error(url + " is not websocket");
            }
            _this.url = url;
            _this.options = options;
            _this.connection = _this.createWebsocketProvider(_this.url, _this.options);
            _this.jsonRpc = new JsonRpc();
            _this.subscriptions = {};
            _this.registerEventListeners();
            return _this;
            // this.on = this.emitter.on.bind(this);
        }
        Object.defineProperty(WSProvider.prototype, "connected", {
            get: function () {
                return this.connection.readyState === this.connection.OPEN;
            },
            enumerable: false,
            configurable: true
        });
        WSProvider.prototype.on = function (type, handler) {
            this.emitter.on(type, handler);
            return this;
        };
        WSProvider.prototype.onData = function (handler) {
            this.emitter.on('data', handler);
            return this;
        };
        WSProvider.prototype.onError = function (event) {
            if (event.code === 'ECONNREFUSED') {
                this.reconnect();
                return;
            }
            _super.prototype.onError.call(this, event);
        };
        WSProvider.prototype.onClose = function (closeEvent) {
            if (closeEvent.code !== 1000 || closeEvent.wasClean === false) {
                this.reconnect();
                return;
            }
            _super.prototype.onClose.call(this);
        };
        WSProvider.prototype.createWebsocketProvider = function (url, options) {
            if (options === void 0) { options = {}; }
            // tslint:disable-next-line: no-string-literal
            if (typeof window !== 'undefined' && window.WebSocket) {
                // tslint:disable-next-line: no-string-literal
                return new WebSocket(url, options.protocol);
            }
            else {
                var headers_1 = options.headers || {};
                var urlObject = new URL(url);
                if (!headers_1.authorization && urlObject.username && urlObject.password) {
                    var authToken = Buffer.from(urlObject.username + ":" + urlObject.password).toString('base64');
                    headers_1.authorization = "Basic " + authToken;
                }
                return new websocket.w3cwebsocket(url, options.protocol, undefined, headers_1, undefined, options.clientConfig);
            }
        };
        WSProvider.prototype.reconnect = function () {
            var _this = this;
            setTimeout(function () {
                _this.removeAllSocketListeners();
                _this.connection = _this.createWebsocketProvider(_this.url, _this.options);
                _this.registerEventListeners();
            }, 5000);
        };
        WSProvider.prototype.isConnecting = function () {
            return this.connection.readyState === this.connection.CONNECTING;
        };
        WSProvider.prototype.send = function (payload) {
            var _this = this;
            var _a = __read(this.getMiddleware(payload.method), 2), tReq = _a[0], tRes = _a[1];
            var reqMiddleware = composeMiddleware.apply(void 0, __spread(tReq));
            var resMiddleware = composeMiddleware.apply(void 0, __spread(tRes));
            return new Promise(function (resolve, reject) {
                // TODO: test on Error
                if (_this.connected) {
                    try {
                        _this.connection.send(reqMiddleware(JSON.stringify(payload)));
                    }
                    catch (error) {
                        // TODO !isConnecting then reconnect?
                        _this.removeEventListener("error" /* ERROR */);
                        throw error;
                    }
                }
                _this.emitter.on("connect" /* CONNECT */, function () {
                    try {
                        _this.connection.send(reqMiddleware(JSON.stringify(payload)));
                    }
                    catch (error) {
                        // TODO !isConnecting then reconnect?
                        _this.removeEventListener("error" /* ERROR */);
                        throw error;
                    }
                });
                _this.emitter.on("" + payload.id, function (data) {
                    resolve(resMiddleware(data));
                    _this.removeEventListener("" + payload.id);
                });
                _this.emitter.on("error" /* ERROR */, reject);
            });
        };
        WSProvider.prototype.subscribe = function (payload) {
            return __awaiter(this, void 0, void 0, function () {
                var response, responseValidateResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.send(payload)];
                        case 1:
                            response = _a.sent();
                            responseValidateResult = this.validate(response);
                            if (responseValidateResult instanceof Error) {
                                throw responseValidateResult;
                            }
                            this.subscriptions[response.result] = {
                                id: response.result,
                                subscribeMethod: payload.method,
                                parameters: payload.params,
                                payload: payload,
                            };
                            return [2 /*return*/, response.result];
                    }
                });
            });
        };
        WSProvider.prototype.unsubscribe = function (payload) {
            return __awaiter(this, void 0, void 0, function () {
                var subscriptionId;
                var _this = this;
                return __generator(this, function (_a) {
                    subscriptionId = payload.params[0];
                    if (this.hasSubscription(subscriptionId)) {
                        return [2 /*return*/, this.send(payload).then(function (response) {
                                if (response) {
                                    _this.removeEventListener(_this.getSubscriptionEvent(subscriptionId));
                                    delete _this.subscriptions[subscriptionId];
                                }
                                return response;
                            })];
                    }
                    return [2 /*return*/, Promise.reject(new Error("Provider error: Subscription with ID " + subscriptionId + " does not exist."))];
                });
            });
        };
        WSProvider.prototype.clearSubscriptions = function (unsubscribeMethod) {
            return __awaiter(this, void 0, void 0, function () {
                var unsubscribePromises, results;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            unsubscribePromises = [];
                            Object.keys(this.subscriptions).forEach(function (key) {
                                _this.removeEventListener(key);
                                unsubscribePromises.push(_this.unsubscribe(_this.jsonRpc.toPayload(unsubscribeMethod, _this.subscriptions[key].id)));
                            });
                            return [4 /*yield*/, Promise.all(unsubscribePromises)];
                        case 1:
                            results = _a.sent();
                            if (results.includes(false)) {
                                throw new Error("Could not unsubscribe all subscriptions: " + JSON.stringify(results));
                            }
                            return [2 /*return*/, true];
                    }
                });
            });
        };
        WSProvider.prototype.registerEventListeners = function () {
            this.connection.onmessage = this.onMessage.bind(this);
            this.connection.onopen = this.onReady.bind(this);
            this.connection.onopen = this.onConnect.bind(this);
            this.connection.onclose = this.onClose.bind(this);
            this.connection.onerror = this.onError.bind(this);
        };
        WSProvider.prototype.onMessage = function (msg) {
            if (msg && msg.data) {
                var result = void 0;
                var event_1;
                try {
                    result = utils.isObject(msg.data) ? msg.data : JSON.parse(msg.data);
                    if (utils.isArray(result)) {
                        event_1 = result[0].id;
                    }
                    // tslint:disable-next-line: prefer-conditional-expression
                    if (typeof result.id === 'undefined') {
                        event_1 =
                            this.getSubscriptionEvent(result.params.subscription) || result.params.subscription;
                        // result = result.params;
                    }
                    else {
                        event_1 = result.id;
                    }
                }
                catch (error) {
                    throw error;
                }
                this.emitter.emit("socket_message" /* SOCKET_MESSAGE */, result);
                this.emitter.emit("" + event_1, result);
            }
            else {
                throw new Error('provider error');
            }
        };
        WSProvider.prototype.onConnect = function () {
            return __awaiter(this, void 0, void 0, function () {
                var subscriptionKeys, subscriptionKeys_1, subscriptionKeys_1_1, key, subscriptionId, e_1_1;
                var e_1, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.subscriptions) {
                                this.subscriptions = {};
                            }
                            subscriptionKeys = Object.keys(this.subscriptions);
                            if (!(subscriptionKeys.length > 0)) return [3 /*break*/, 8];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 6, 7, 8]);
                            subscriptionKeys_1 = __values(subscriptionKeys), subscriptionKeys_1_1 = subscriptionKeys_1.next();
                            _b.label = 2;
                        case 2:
                            if (!!subscriptionKeys_1_1.done) return [3 /*break*/, 5];
                            key = subscriptionKeys_1_1.value;
                            return [4 /*yield*/, this.subscribe(this.subscriptions[key].payload)];
                        case 3:
                            subscriptionId = _b.sent();
                            delete this.subscriptions[subscriptionId];
                            this.subscriptions[key].id = subscriptionId;
                            _b.label = 4;
                        case 4:
                            subscriptionKeys_1_1 = subscriptionKeys_1.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_1_1 = _b.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (subscriptionKeys_1_1 && !subscriptionKeys_1_1.done && (_a = subscriptionKeys_1.return)) _a.call(subscriptionKeys_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 8:
                            this.emitter.emit("socket_connect" /* SOCKET_CONNECT */);
                            this.emitter.emit("connect" /* CONNECT */);
                            return [2 /*return*/];
                    }
                });
            });
        };
        WSProvider.prototype.getSubscriptionEvent = function (subscriptionId) {
            var _this = this;
            if (this.subscriptions[subscriptionId]) {
                return subscriptionId;
            }
            var event;
            Object.keys(this.subscriptions).forEach(function (key) {
                if (_this.subscriptions[key].id === subscriptionId) {
                    event = key;
                }
            });
            return event;
        };
        WSProvider.prototype.hasSubscription = function (subscriptionId) {
            return typeof this.getSubscriptionEvent(subscriptionId) !== 'undefined';
        };
        WSProvider.prototype.validate = function (response, payload) {
            if (utils.isObject(response)) {
                if (response.error) {
                    if (response.error instanceof Error) {
                        return new Error("Node error: " + response.error.message);
                    }
                    return new Error("Node error: " + JSON.stringify(response.error));
                }
                if (payload && response.id !== payload.id) {
                    return new Error("Validation error: Invalid JSON-RPC response ID (request: " + payload.id + " / response: " + response.id + ")");
                }
                if (response.result === undefined) {
                    return new Error('Validation error: Undefined JSON-RPC result');
                }
                return true;
            }
            return new Error('Validation error: Response should be of type Object');
        };
        return WSProvider;
    }(BaseSocket));

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    var Emitter = /** @class */ (function () {
        function Emitter() {
            var _this = this;
            this.handlers = {};
            this.emitter = mitt(this.handlers);
            this.off = this.emitter.off.bind(this);
            this.emit = this.emitter.emit.bind(this);
            // tslint:disable-next-line: no-empty
            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
            this.then = this.promise.then.bind(this.promise);
        }
        Emitter.prototype.resetHandlers = function () {
            // tslint:disable-next-line: forin
            for (var i in this.handlers) {
                delete this.handlers[i];
            }
        };
        Emitter.prototype.on = function (type, handler) {
            this.emitter.on(type, handler);
            return this;
        };
        Emitter.prototype.once = function (type, handler) {
            var _this = this;
            this.emitter.on(type, function (e) {
                handler(e);
                _this.removeEventListener(type);
            });
        };
        Emitter.prototype.addEventListener = function (type, handler) {
            this.emitter.on(type, handler);
        };
        Emitter.prototype.removeEventListener = function (type, handler) {
            if (!type) {
                this.handlers = {};
                return;
            }
            if (!handler) {
                delete this.handlers[type];
            }
            else {
                return this.emitter.off(type, handler);
            }
        };
        Emitter.prototype.onError = function (error) {
            this.emitter.on('error', error);
            this.removeEventListener('*');
        };
        Emitter.prototype.onData = function (data) {
            this.emitter.on('data', data);
            this.removeEventListener('*');
        };
        Emitter.prototype.listenerCount = function (listenKey) {
            var count = 0;
            Object.keys(this.handlers).forEach(function (val) {
                if (listenKey === val) {
                    count += 1;
                }
            });
            return count;
        };
        return Emitter;
    }());

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    (function (ProviderType) {
        ProviderType["http"] = "http";
        ProviderType["ws"] = "ws";
    })(exports.ProviderType || (exports.ProviderType = {}));
    var Provider = /** @class */ (function () {
        function Provider(url) {
            this.provider = this.onInitSetProvider(url);
            this.providerType = this.getType(this.provider);
        }
        Provider.getProvider = function (provider) {
            try {
                this.getProvider(provider);
                return new Provider(provider);
            }
            catch (error) {
                throw error;
            }
        };
        Provider.prototype.onInitSetProvider = function (providerUrl) {
            if (typeof providerUrl === 'string') {
                return utils.isHttp(providerUrl)
                    ? new HttpProvider(providerUrl)
                    : utils.isWs(providerUrl)
                        ? new WSProvider(providerUrl)
                        : new HttpProvider(utils.defaultConfig.Default.Chain_URL);
            }
            try {
                var providerType = this.getType(providerUrl);
                if (providerType === exports.ProviderType.http || providerType === exports.ProviderType.ws) {
                    return providerUrl;
                }
                else {
                    throw new Error('cannot get provider type');
                }
            }
            catch (error) {
                throw error;
            }
        };
        Provider.prototype.getType = function (provider) {
            if (provider instanceof HttpProvider) {
                return exports.ProviderType.http;
            }
            if (provider instanceof WSProvider) {
                return exports.ProviderType.ws;
            }
            throw new Error('provider is not correct');
        };
        return Provider;
    }());

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    /**
     * @class ResponseMiddleware
     * @description Response middleware of RPC
     * @param  {Object}  ResponseBody - response from rpc
     * @return {ResponseMiddleware} response middleware instance
     */
    var ResponseMiddleware = /** @class */ (function () {
        function ResponseMiddleware(ResponseBody) {
            this.result = ResponseBody.result;
            this.error = ResponseBody.error;
            this.raw = ResponseBody;
            this.responseType = this.getResponseType();
        }
        Object.defineProperty(ResponseMiddleware.prototype, "getResult", {
            get: function () {
                return utils.isObject(this.result) ? __assign(__assign({}, this.result), { responseType: 'result' }) : this.result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ResponseMiddleware.prototype, "getError", {
            get: function () {
                return utils.isObject(this.error) ? __assign(__assign({}, this.error), { responseType: 'error' }) : this.error;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ResponseMiddleware.prototype, "getRaw", {
            get: function () {
                return __assign(__assign({}, this.raw), { responseType: 'raw' });
            },
            enumerable: false,
            configurable: true
        });
        ResponseMiddleware.prototype.getResponseType = function () {
            if (this.error) {
                return 'error';
            }
            else if (this.result || (this.result === null && this.result !== undefined)) {
                return 'result';
            }
            else {
                return 'raw';
            }
        };
        ResponseMiddleware.prototype.isError = function () {
            return this.responseType === 'error';
        };
        ResponseMiddleware.prototype.isResult = function () {
            return this.responseType === 'result';
        };
        ResponseMiddleware.prototype.isRaw = function () {
            return this.responseType === 'raw';
        };
        return ResponseMiddleware;
    }());

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    /**
     * ## How to Create a Massage
     * @example
     * ```
     * const { HttpProvider, Messenger } = require('@harmony-js/network');
     * const { ChainType, ChainID } = require('@harmony-js/utils');
     *
     * // create a custom messenger
     * const customMessenger = new Messenger(
     *   new HttpProvider('http://localhost:9500'),
     *   ChainType.Harmony, // if you are connected to Harmony's blockchain
     *   ChainID.HmyLocal, // check if the chainId is correct
     * )
     * ```
     */
    var Messenger = /** @class */ (function (_super) {
        __extends(Messenger, _super);
        function Messenger(provider, chainType, chainId, config) {
            if (chainType === void 0) { chainType = utils.defaultConfig.Default.Chain_Type; }
            if (chainId === void 0) { chainId = utils.defaultConfig.Default.Chain_ID; }
            if (config === void 0) { config = utils.defaultConfig; }
            var _this = _super.call(this, chainType, chainId) || this;
            // tslint:disable-next-line: variable-name
            _this.Network_ID = 'Default';
            /**
             * @function send
             * @memberof Messenger.prototype
             * @param  {String} method - RPC method
             * @param  {Object} params - RPC method params
             * @return {Object} RPC result
             */
            _this.send = function (method, params, rpcPrefix, shardID) {
                if (shardID === void 0) { shardID = _this.currentShard; }
                return __awaiter(_this, void 0, void 0, function () {
                    var rpcMethod, payload, provider, result, e_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.providerCheck();
                                rpcMethod = method;
                                if (rpcPrefix && utils.isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, rpcPrefix);
                                }
                                else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, this.chainPrefix);
                                }
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                payload = this.JsonRpc.toPayload(rpcMethod, params);
                                provider = this.getShardProvider(shardID);
                                this.setResMiddleware(function (data) {
                                    if (!(data instanceof ResponseMiddleware)) {
                                        return new ResponseMiddleware(data);
                                    }
                                    else {
                                        return data;
                                    }
                                }, '*', provider);
                                return [4 /*yield*/, provider.send(payload)];
                            case 2:
                                result = _a.sent();
                                return [2 /*return*/, result];
                            case 3:
                                e_1 = _a.sent();
                                throw new Error(e_1);
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
            _this.subscribe = function (method, params, returnType, rpcPrefix, shardID) {
                if (returnType === void 0) { returnType = "all" /* all */; }
                if (rpcPrefix === void 0) { rpcPrefix = _this.chainPrefix; }
                if (shardID === void 0) { shardID = _this.currentShard; }
                return __awaiter(_this, void 0, void 0, function () {
                    var rpcMethod, id, provider, reProvider_1, payload, error_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                rpcMethod = method;
                                if (rpcPrefix && utils.isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, rpcPrefix);
                                }
                                else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, this.chainPrefix);
                                }
                                id = null;
                                provider = this.getShardProvider(shardID);
                                if (!(provider instanceof WSProvider)) return [3 /*break*/, 5];
                                reProvider_1 = provider;
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                payload = this.JsonRpc.toPayload(rpcMethod, params);
                                return [4 /*yield*/, reProvider_1.subscribe(payload)];
                            case 2:
                                id = _a.sent();
                                reProvider_1.on(id, function (result) {
                                    reProvider_1.emitter.emit('data', result);
                                });
                                reProvider_1.once('error', function (error) {
                                    reProvider_1.removeEventListener(id);
                                    reProvider_1.emitter.emit('error', error);
                                    reProvider_1.removeEventListener('*');
                                });
                                return [3 /*break*/, 4];
                            case 3:
                                error_1 = _a.sent();
                                reProvider_1.emitter.emit('error', error_1);
                                reProvider_1.removeEventListener('*');
                                return [3 /*break*/, 4];
                            case 4:
                                if (returnType === "all" /* all */) {
                                    return [2 /*return*/, [reProvider_1, id]];
                                }
                                else if (returnType === "method" /* method */) {
                                    return [2 /*return*/, reProvider_1];
                                }
                                else if (returnType === "id" /* id */) {
                                    return [2 /*return*/, id];
                                }
                                else {
                                    throw new Error('Invalid returns');
                                }
                                return [3 /*break*/, 6];
                            case 5: throw new Error('HttpProvider does not support this');
                            case 6: return [2 /*return*/];
                        }
                    });
                });
            };
            _this.unsubscribe = function (method, params, rpcPrefix, shardID) {
                if (shardID === void 0) { shardID = _this.currentShard; }
                return __awaiter(_this, void 0, void 0, function () {
                    var rpcMethod, provider, reProvider, payload, response, error_2;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                rpcMethod = method;
                                if (rpcPrefix && utils.isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, rpcPrefix);
                                }
                                else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {
                                    rpcMethod = this.setRPCPrefix(method, this.chainPrefix);
                                }
                                provider = this.getShardProvider(shardID);
                                if (!(provider instanceof WSProvider)) return [3 /*break*/, 5];
                                reProvider = this.provider;
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                payload = this.JsonRpc.toPayload(rpcMethod, params);
                                return [4 /*yield*/, reProvider.unsubscribe(payload)];
                            case 2:
                                response = _a.sent();
                                return [2 /*return*/, response];
                            case 3:
                                error_2 = _a.sent();
                                throw error_2;
                            case 4: return [3 /*break*/, 6];
                            case 5: throw new Error('HttpProvider does not support this');
                            case 6: return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * @var {Provider} provider
             * @memberof Messenger.prototype
             * @description Provider instance
             */
            _this.provider = provider;
            /**
             * @var {Object} config
             * @memberof Messenger.prototype
             * @description Messenger config
             */
            _this.config = config;
            /**
             * @var {Number} Network_ID
             * @memberof Messenger.prototype
             * @description Network ID for current provider
             */
            /**
             * @var {JsonRpc} JsonRpc
             * @memberof Messenger.prototype
             * @description JsonRpc instance
             */
            _this.JsonRpc = new JsonRpc();
            // set Network ID
            _this.setNetworkID(utils.defaultConfig.Default.Network_ID);
            // set shardingProviders
            _this.shardProviders = new Map();
            return _this;
            // this.setShardingProviders();
        }
        Object.defineProperty(Messenger.prototype, "currentShard", {
            /**
             * @example
             * ```
             * customMessenger.currentShard
             * ```
             */
            get: function () {
                return this.getCurrentShardID() || this.defaultShardID || 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Messenger.prototype, "shardCount", {
            /**
             * @example
             * ```
             * customMessenger.shardCount
             * ```
             */
            get: function () {
                return this.shardProviders.size;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @function setProvider
         * @memberof Messenger
         * @description provider setter
         * @param  {Provider} provider - provider instance
         */
        Messenger.prototype.setProvider = function (provider) {
            this.provider = provider;
        };
        /**
         * @function providerCheck
         * @memberof Messenger
         * @description provider checker
         * @return {Error|null} provider validator
         */
        Messenger.prototype.providerCheck = function () {
            if (!this.provider) {
                throw new Error('provider is not found');
            }
        };
        /**
         * @function setReqMiddleware
         * @description set request middleware
         * @memberof Messenger
         * @param  {any} middleware - middle ware for req
         * @param  {String} method  - method name
         * @hidden
         */
        Messenger.prototype.setReqMiddleware = function (middleware, method, provider) {
            if (method === void 0) { method = '*'; }
            provider.middlewares.request.use(middleware, method);
        };
        /**
         * @function setResMiddleware
         * @description set response middleware
         * @memberof Messenger
         * @param  {any} middleware - middle ware for req
         * @param  {String} method  - method name
         * @hidden
         */
        Messenger.prototype.setResMiddleware = function (middleware, method, provider) {
            if (method === void 0) { method = '*'; }
            provider.middlewares.response.use(middleware, method);
        };
        /**
         * @function setNetworkID
         * @description set network id
         * @memberof Messenger
         * @param  {String} id network id string
         */
        Messenger.prototype.setNetworkID = function (id) {
            this.Network_ID = id;
        };
        Messenger.prototype.setRPCPrefix = function (method, prefix) {
            var stringArray = method.split('_');
            if (stringArray.length !== 2) {
                throw new Error("could not set prefix with " + method);
            }
            stringArray[0] = prefix;
            return stringArray.join('_');
        };
        Messenger.prototype.setShardingProviders = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, shardingStructures, shardingStructures_1, shardingStructures_1_1, shard, shardID, error_3;
                var e_2, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (this.chainPrefix !== "hmy" /* Harmony */) {
                                return [2 /*return*/];
                            }
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.send("hmy_getShardingStructure" /* GetShardingStructure */, [], this.chainPrefix)];
                        case 2:
                            response = _b.sent();
                            if (response.result) {
                                shardingStructures = response.result;
                                try {
                                    for (shardingStructures_1 = __values(shardingStructures), shardingStructures_1_1 = shardingStructures_1.next(); !shardingStructures_1_1.done; shardingStructures_1_1 = shardingStructures_1.next()) {
                                        shard = shardingStructures_1_1.value;
                                        shardID = typeof shard.shardID === 'string' ? Number.parseInt(shard.shardID, 10) : shard.shardID;
                                        this.shardProviders.set(shardID, {
                                            current: shard.current,
                                            shardID: shardID,
                                            http: shard.http,
                                            ws: shard.ws,
                                        });
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (shardingStructures_1_1 && !shardingStructures_1_1.done && (_a = shardingStructures_1.return)) _a.call(shardingStructures_1);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            error_3 = _b.sent();
                            return [2 /*return*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @example
         * ```
         * hmy.messenger.getShardProvider()
         * ```
         */
        Messenger.prototype.getShardProvider = function (shardID) {
            var provider = this.shardProviders.get(shardID);
            if (provider) {
                return this.provider instanceof HttpProvider
                    ? new HttpProvider(provider.http)
                    : new WSProvider(provider.ws);
            }
            return this.provider;
        };
        /**
         * @example
         * ```
         * hmy.messenger.getCurrentShardID()
         * ```
         */
        Messenger.prototype.getCurrentShardID = function () {
            var e_3, _a;
            try {
                for (var _b = __values(this.shardProviders), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var shard = _c.value;
                    if (shard[1].current === true ||
                        shard[1].http === this.provider.url ||
                        shard[1].ws === this.provider.url) {
                        return shard[1].shardID;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        Messenger.prototype.setDefaultShardID = function (shardID) {
            this.defaultShardID = shardID;
        };
        return Messenger;
    }(utils.HarmonyCore));

    /**
     * ## About this package
     *
     * `@harmony-js/network` provides functions to handle messenger, providers and subscriptions...
     *
     * ## How to use this package
     *
     * ### 1. Create a Message
     * ```javascript
     * const { HttpProvider, Messenger } = require('@harmony-js/network');
     * const { ChainType, ChainID } = require('@harmony-js/utils');
     *
     * // create a custom messenger
     * const customMessenger = new Messenger(
     *   new HttpProvider('http://localhost:9500'),
     *   ChainType.Harmony, // if you are connected to Harmony's blockchain
     *   ChainID.HmyLocal, // check if the chainId is correct
     * )
     * ```
     *
     * @packageDocumentation
     * @module harmony-network
     */
    (function (RPCMethod) {
        // 1. hmy_getBlockByHash
        RPCMethod["GetBlockByHash"] = "hmy_getBlockByHash";
        // 2. hmy_getBlockByNumber
        RPCMethod["GetBlockByNumber"] = "hmy_getBlockByNumber";
        // 3. hmy_getBlockTransactionCountByHash
        RPCMethod["GetBlockTransactionCountByHash"] = "hmy_getBlockTransactionCountByHash";
        // 4. hmy_getBlockTransactionCountByNumber
        RPCMethod["GetBlockTransactionCountByNumber"] = "hmy_getBlockTransactionCountByNumber";
        // 5. hmy_getCode
        RPCMethod["GetCode"] = "hmy_getCode";
        // 6. hmy_getTransactionByBlockHashAndIndex
        RPCMethod["GetTransactionByBlockHashAndIndex"] = "hmy_getTransactionByBlockHashAndIndex";
        // 7. hmy_getTransactionByBlockNumberAndIndex
        RPCMethod["GetTransactionByBlockNumberAndIndex"] = "hmy_getTransactionByBlockNumberAndIndex";
        // 8. hmy_getTransactionByHash
        RPCMethod["GetTransactionByHash"] = "hmy_getTransactionByHash";
        RPCMethod["GetTransactionReceipt"] = "hmy_getTransactionReceipt";
        RPCMethod["GetCXReceiptByHash"] = "hmy_getCXReceiptByHash";
        // 9. hmy_syncing
        RPCMethod["Syncing"] = "hmy_syncing";
        // 10. net_peerCount
        RPCMethod["PeerCount"] = "net_peerCount";
        // 11. hmy_getBalance
        RPCMethod["GetBalance"] = "hmy_getBalance";
        // 12. hmy_getStorageAt
        RPCMethod["GetStorageAt"] = "hmy_getStorageAt";
        // 13. hmy_getTransactionCount
        RPCMethod["GetTransactionCount"] = "hmy_getTransactionCount";
        // 14. hmy_sendTransaction
        RPCMethod["SendTransaction"] = "hmy_sendTransaction";
        // 15. hmy_sendRawTransaction
        RPCMethod["SendRawTransaction"] = "hmy_sendRawTransaction";
        // 16. hmy_subscribe
        RPCMethod["Subscribe"] = "hmy_subscribe";
        // 17. hmy_getlogs
        RPCMethod["GetPastLogs"] = "hmy_getLogs";
        // 18. hmy_getWork
        RPCMethod["GetWork"] = "hmy_getWork";
        // 19. hmy_submitWork
        // SubmitWork = 'hmy_submitWork',
        // 20. hmy_getProof
        RPCMethod["GetProof"] = "hmy_getProof";
        // 21, hmy_getFilterChanges
        RPCMethod["GetFilterChanges"] = "hmy_getFilterChanges";
        // 22. hmy_newPendingTransactionFilter
        RPCMethod["NewPendingTransactionFilter"] = "hmy_newPendingTransactionFilter";
        // 23. hmy_newBlockFilter
        RPCMethod["NewBlockFilter"] = "hmy_newBlockFilter";
        // 24. hmy_newFilter
        RPCMethod["NewFilter"] = "hmy_newFilter";
        // 25. hmy_call
        RPCMethod["Call"] = "hmy_call";
        // 26. hmy_estimateGas
        RPCMethod["EstimateGas"] = "hmy_estimateGas";
        // 27. hmy_gasPrice
        RPCMethod["GasPrice"] = "hmy_gasPrice";
        // 28. hmy_blockNumber
        RPCMethod["BlockNumber"] = "hmy_blockNumber";
        // 29. hmy_unsubscribe
        RPCMethod["UnSubscribe"] = "hmy_unsubscribe";
        // 30. net_version
        RPCMethod["NetVersion"] = "net_version";
        // 31. hmy_protocolVersion
        RPCMethod["ProtocolVersion"] = "hmy_protocolVersion";
        // 32. hmy_getShardingStructure
        RPCMethod["GetShardingStructure"] = "hmy_getShardingStructure";
        // 33. hmy_sendRawStakingTransaction
        RPCMethod["SendRawStakingTransaction"] = "hmy_sendRawStakingTransaction";
    })(exports.RPCMethod || (exports.RPCMethod = {}));
    (function (RPCErrorCode) {
        // Standard JSON-RPC 2.0 errors
        // RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
        // It should not be used for application-layer errors.
        RPCErrorCode[RPCErrorCode["RPC_INVALID_REQUEST"] = -32600] = "RPC_INVALID_REQUEST";
        // RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
        // It should not be used for application-layer errors.
        RPCErrorCode[RPCErrorCode["RPC_METHOD_NOT_FOUND"] = -32601] = "RPC_METHOD_NOT_FOUND";
        RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMS"] = -32602] = "RPC_INVALID_PARAMS";
        // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
        // (for example datadir corruption).
        RPCErrorCode[RPCErrorCode["RPC_INTERNAL_ERROR"] = -32603] = "RPC_INTERNAL_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_PARSE_ERROR"] = -32700] = "RPC_PARSE_ERROR";
        // General application defined errors
        RPCErrorCode[RPCErrorCode["RPC_MISC_ERROR"] = -1] = "RPC_MISC_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_TYPE_ERROR"] = -3] = "RPC_TYPE_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_INVALID_ADDRESS_OR_KEY"] = -5] = "RPC_INVALID_ADDRESS_OR_KEY";
        RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMETER"] = -8] = "RPC_INVALID_PARAMETER";
        RPCErrorCode[RPCErrorCode["RPC_DATABASE_ERROR"] = -20] = "RPC_DATABASE_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_DESERIALIZATION_ERROR"] = -22] = "RPC_DESERIALIZATION_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_VERIFY_ERROR"] = -25] = "RPC_VERIFY_ERROR";
        RPCErrorCode[RPCErrorCode["RPC_VERIFY_REJECTED"] = -26] = "RPC_VERIFY_REJECTED";
        RPCErrorCode[RPCErrorCode["RPC_IN_WARMUP"] = -28] = "RPC_IN_WARMUP";
        RPCErrorCode[RPCErrorCode["RPC_METHOD_DEPRECATED"] = -32] = "RPC_METHOD_DEPRECATED";
    })(exports.RPCErrorCode || (exports.RPCErrorCode = {}));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var sec = 1000;
    var calculateSum = function (accumulator, currentValue) { return accumulator + currentValue; };
    var blockTrackerEvents = ['sync', 'latest'];
    var BaseBlockTracker = /** @class */ (function (_super) {
        __extends(BaseBlockTracker, _super);
        function BaseBlockTracker(opts) {
            if (opts === void 0) { opts = {
                blockResetDuration: undefined,
                retryTimeout: undefined,
                keepEventLoopActive: undefined,
                setSkipCacheFlag: false,
            }; }
            var _this = _super.call(this) || this;
            // config
            _this._blockResetDuration = opts.blockResetDuration || 20 * sec;
            // state
            // tslint:disable-next-line: no-unused-expression
            _this._blockResetTimeout;
            _this._currentBlock = null;
            _this._isRunning = false;
            // bind functions for internal use
            // this._onNewListener = this._onNewListener.bind(this);
            // this._onRemoveListener = this._onRemoveListener.bind(this);
            // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
            // listen for handler changes
            // this._setupInternalEvents();
            _this._maybeStart();
            return _this;
        }
        BaseBlockTracker.prototype.isRunning = function () {
            return this._isRunning;
        };
        BaseBlockTracker.prototype.getCurrentBlock = function () {
            return this._currentBlock;
        };
        BaseBlockTracker.prototype.getLatestBlock = function () {
            return __awaiter(this, void 0, void 0, function () {
                var latestBlock;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // return if available
                            if (this._currentBlock) {
                                return [2 /*return*/, this._currentBlock];
                            }
                            return [4 /*yield*/, new Promise(function (resolve) { return _this.once('latest', resolve); })];
                        case 1:
                            latestBlock = _a.sent();
                            // return newly set current block
                            return [2 /*return*/, latestBlock];
                    }
                });
            });
        };
        // dont allow module consumer to remove our internal event listeners
        BaseBlockTracker.prototype.removeAllListeners = function (eventName) {
            // perform default behavior, preserve fn arity
            if (eventName) {
                _super.prototype.removeEventListener.call(this, eventName);
            }
            else {
                _super.prototype.removeEventListener.call(this, '*');
            }
            // re-add internal events
            this._setupInternalEvents();
            // trigger stop check just in case
            this._onRemoveListener('*');
        };
        //
        // to be implemented in subclass
        //
        BaseBlockTracker.prototype._start = function () {
            // default behavior is noop
        };
        BaseBlockTracker.prototype._end = function () {
            // default behavior is noop
        };
        //
        // private
        //
        BaseBlockTracker.prototype._setupInternalEvents = function () {
            // first remove listeners for idempotence
            this.removeEventListener('newListener', this._onNewListener);
            this.removeEventListener('removeListener', this._onRemoveListener);
            // then add them
            this.on('newListener', this._onNewListener);
            this.on('removeListener', this._onRemoveListener);
        };
        BaseBlockTracker.prototype._onNewListener = function (eventName, handler) {
            // `newListener` is called *before* the listener is added
            if (!blockTrackerEvents.includes(eventName)) {
                return;
            }
            this._maybeStart();
        };
        BaseBlockTracker.prototype._onRemoveListener = function (eventName, handler) {
            // `removeListener` is called *after* the listener is removed
            if (this._getBlockTrackerEventCount() > 0) {
                return;
            }
            this._maybeEnd();
        };
        BaseBlockTracker.prototype._maybeStart = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            // cancel setting latest block to stale
            this._cancelBlockResetTimeout();
            this._start();
        };
        BaseBlockTracker.prototype._maybeEnd = function () {
            if (!this._isRunning) {
                return;
            }
            this._isRunning = false;
            this._setupBlockResetTimeout();
            this._end();
        };
        BaseBlockTracker.prototype._getBlockTrackerEventCount = function () {
            var _this = this;
            return blockTrackerEvents
                .map(function (eventName) { return _this.listenerCount(eventName); })
                .reduce(calculateSum);
        };
        BaseBlockTracker.prototype._newPotentialLatest = function (newBlock) {
            var currentBlock = this._currentBlock;
            // only update if blok number is higher
            if (currentBlock &&
                utils.isHex(currentBlock) &&
                utils.isHex(newBlock) &&
                utils.hexToNumber(newBlock) <= utils.hexToNumber(currentBlock)) {
                return;
            }
            this._setCurrentBlock(newBlock);
        };
        BaseBlockTracker.prototype._setCurrentBlock = function (newBlock) {
            var oldBlock = this._currentBlock;
            this._currentBlock = newBlock;
            this.emit('latest', newBlock);
            this.emit('sync', { oldBlock: oldBlock, newBlock: newBlock });
        };
        BaseBlockTracker.prototype._setupBlockResetTimeout = function () {
            // clear any existing timeout
            this._cancelBlockResetTimeout();
            // clear latest block when stale
            this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
            // nodejs - dont hold process open
            if (this._blockResetTimeout.unref) {
                this._blockResetTimeout.unref();
            }
        };
        BaseBlockTracker.prototype._cancelBlockResetTimeout = function () {
            clearTimeout(this._blockResetTimeout);
        };
        BaseBlockTracker.prototype._resetCurrentBlock = function () {
            this._currentBlock = null;
        };
        return BaseBlockTracker;
    }(Emitter));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var sec$1 = 1000;
    function timeout(duration, unref) {
        return new Promise(function (resolve) {
            var timoutRef = setTimeout(resolve, duration);
            // don't keep process open
            if (timoutRef.unref && unref) {
                timoutRef.unref();
            }
        });
    }
    var PollingBlockTracker = /** @class */ (function (_super) {
        __extends(PollingBlockTracker, _super);
        function PollingBlockTracker(messenger, opts) {
            if (opts === void 0) { opts = {
                pollingInterval: undefined,
                retryTimeout: undefined,
                keepEventLoopActive: false,
                setSkipCacheFlag: false,
            }; }
            var _this = this;
            // parse + validate args
            if (!messenger) {
                throw new Error('PollingBlockTracker - no provider specified.');
            }
            var pollingInterval = opts.pollingInterval || 20 * sec$1;
            var retryTimeout = opts.retryTimeout || pollingInterval / 10;
            var keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true;
            var setSkipCacheFlag = opts.setSkipCacheFlag || false;
            // BaseBlockTracker constructor
            _this = _super.call(this, {
                blockResetDuration: pollingInterval,
                retryTimeout: retryTimeout,
                keepEventLoopActive: keepEventLoopActive,
                setSkipCacheFlag: setSkipCacheFlag,
            }) || this;
            // config
            _this.messenger = messenger;
            _this._pollingInterval = pollingInterval;
            _this._retryTimeout = retryTimeout;
            _this._keepEventLoopActive = keepEventLoopActive;
            _this._setSkipCacheFlag = setSkipCacheFlag;
            return _this;
        }
        //
        // public
        //
        // trigger block polling
        PollingBlockTracker.prototype.checkForLatestBlock = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._updateLatestBlock()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.getLatestBlock()];
                        case 2:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        //
        // private
        //
        PollingBlockTracker.prototype._start = function () {
            var _this = this;
            this._performSync().catch(function (err) { return _this.emit('error', err); });
        };
        PollingBlockTracker.prototype._performSync = function () {
            return __awaiter(this, void 0, void 0, function () {
                var err_1, newErr;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._isRunning) return [3 /*break*/, 7];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 4, , 6]);
                            return [4 /*yield*/, this._updateLatestBlock()];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, timeout(this._pollingInterval, !this._keepEventLoopActive)];
                        case 3:
                            _a.sent();
                            return [3 /*break*/, 6];
                        case 4:
                            err_1 = _a.sent();
                            newErr = new Error("PollingBlockTracker - encountered an error while attempting to update latest block:\n" + err_1.stack);
                            try {
                                this.emit('error', newErr);
                            }
                            catch (emitErr) {
                                console.error(newErr);
                            }
                            return [4 /*yield*/, timeout(this._retryTimeout, !this._keepEventLoopActive)];
                        case 5:
                            _a.sent();
                            return [3 /*break*/, 6];
                        case 6: return [3 /*break*/, 0];
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        PollingBlockTracker.prototype._updateLatestBlock = function () {
            return __awaiter(this, void 0, void 0, function () {
                var latestBlock;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._fetchLatestBlock()];
                        case 1:
                            latestBlock = _a.sent();
                            this._newPotentialLatest(latestBlock);
                            return [2 /*return*/];
                    }
                });
            });
        };
        PollingBlockTracker.prototype._fetchLatestBlock = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.messenger.send("hmy_blockNumber" /* BlockNumber */, [])];
                        case 1:
                            result = _a.sent();
                            if (result.isError()) {
                                throw result.message;
                            }
                            else if (result.isResult()) {
                                return [2 /*return*/, result.result];
                            }
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return PollingBlockTracker;
    }(BaseBlockTracker));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var SubscribeBlockTracker = /** @class */ (function (_super) {
        __extends(SubscribeBlockTracker, _super);
        // tslint:disable-next-line: variable-name
        function SubscribeBlockTracker(messenger, opts) {
            if (opts === void 0) { opts = {}; }
            var _this = this;
            // parse + validate args
            if (!messenger) {
                throw new Error('SubscribeBlockTracker - no provider specified.');
            }
            if (!(messenger.provider instanceof WSProvider)) {
                throw new Error('This provider not supported');
            }
            // BaseBlockTracker constructor
            _this = _super.call(this, opts) || this;
            // config
            _this.messenger = messenger;
            _this.subscriptionId = null;
            return _this;
        }
        SubscribeBlockTracker.prototype.checkForLatestBlock = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.getLatestBlock()];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        SubscribeBlockTracker.prototype._start = function () {
            return __awaiter(this, void 0, void 0, function () {
                var blockNumber, subs, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 5, , 6]);
                            return [4 /*yield*/, this.messenger.send("hmy_blockNumber" /* BlockNumber */, [])];
                        case 1:
                            blockNumber = _a.sent();
                            if (!blockNumber.isError()) return [3 /*break*/, 2];
                            throw blockNumber.message;
                        case 2:
                            if (!blockNumber.isResult()) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.messenger.subscribe("hmy_subscribe" /* Subscribe */, ['newHeads'])];
                        case 3:
                            subs = _a.sent();
                            this.subscriptionId = subs;
                            subs[0].onData(this._handleSubData);
                            this._newPotentialLatest(blockNumber);
                            _a.label = 4;
                        case 4: return [3 /*break*/, 6];
                        case 5:
                            error_1 = _a.sent();
                            this.emit('error', error_1);
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        SubscribeBlockTracker.prototype._end = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.subscriptionId != null) {
                        this.messenger.unsubscribe("hmy_unsubscribe" /* UnSubscribe */, [this.subscriptionId]);
                        delete this.subscriptionId;
                    }
                    return [2 /*return*/];
                });
            });
        };
        SubscribeBlockTracker.prototype._handleSubData = function (data) {
            if (
            // data.method === 'eth_subscription' &&
            data.params.subscription === this.subscriptionId) {
                this._newPotentialLatest(data.params.result.number);
            }
        };
        return SubscribeBlockTracker;
    }(BaseBlockTracker));

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    var SubscriptionMethod = /** @class */ (function (_super) {
        __extends(SubscriptionMethod, _super);
        function SubscriptionMethod(param, options, messenger, shardID) {
            if (shardID === void 0) { shardID = 0; }
            var _this = _super.call(this, shardID !== 0 ? messenger.getShardProvider(shardID).url : messenger.provider.url) || this;
            _this.subscriptionId = null;
            _this.shardID = shardID;
            _this.param = param;
            _this.options = options;
            _this.messenger = messenger;
            return _this;
        }
        SubscriptionMethod.prototype.constructPayload = function (method, param, options) {
            var rpcMethod = method;
            var payload = [];
            payload.push(param);
            if (options) {
                payload.push(options);
            }
            rpcMethod = this.messenger.setRPCPrefix(method, this.messenger.chainPrefix);
            return this.jsonRpc.toPayload(rpcMethod, payload);
        };
        SubscriptionMethod.prototype.start = function () {
            return __awaiter(this, void 0, void 0, function () {
                var subscribePayload, id_1, error_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            subscribePayload = this.constructPayload("hmy_subscribe" /* Subscribe */, this.param, this.options);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, _super.prototype.subscribe.call(this, subscribePayload)];
                        case 2:
                            id_1 = _a.sent();
                            this.subscriptionId = id_1;
                            this.on(id_1, function (result) {
                                var output = _this.onNewSubscriptionItem(result);
                                _this.emitter.emit('data', output);
                            });
                            this.once('error', function (error) {
                                _this.removeEventListener(id_1);
                                _this.emitter.emit('error', error);
                                _this.removeEventListener('*');
                            });
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _a.sent();
                            this.emitter.emit('error', error_1);
                            this.removeEventListener('*');
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, this];
                    }
                });
            });
        };
        SubscriptionMethod.prototype.unsubscribe = function () {
            var unsubscribePayload = this.constructPayload("hmy_unsubscribe" /* UnSubscribe */, this.subscriptionId);
            return _super.prototype.unsubscribe.call(this, unsubscribePayload);
        };
        SubscriptionMethod.prototype.onNewSubscriptionItem = function (subscriptionItem) {
            return subscriptionItem;
        };
        return SubscriptionMethod;
    }(WSProvider));

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    var LogSub = /** @class */ (function (_super) {
        __extends(LogSub, _super);
        function LogSub(options, messenger, shardID) {
            if (shardID === void 0) { shardID = 0; }
            var _this = _super.call(this, 'logs', options, messenger, shardID) || this;
            _this.preprocess();
            return _this;
        }
        LogSub.prototype.preprocess = function () {
            return __awaiter(this, void 0, void 0, function () {
                var getPastLogs, logs, error_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!((this.options.fromBlock && this.options.fromBlock !== 'latest') ||
                                this.options.fromBlock === 0 ||
                                this.options.fromBlock === '0x')) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.messenger.send("hmy_getLogs" /* GetPastLogs */, __spread(this.options), this.messenger.chainType, this.shardID)];
                        case 2:
                            getPastLogs = _a.sent();
                            if (getPastLogs.isError()) {
                                this.emitter.emit('error', getPastLogs.error.message);
                            }
                            else {
                                logs = getPastLogs.result;
                                logs.forEach(function (log) {
                                    var formattedLog = _this.onNewSubscriptionItem(log);
                                    _this.emitter.emit('data', formattedLog);
                                });
                            }
                            delete this.options.fromBlock;
                            // const sub = this.start();
                            return [2 /*return*/, this.start()];
                        case 3:
                            error_1 = _a.sent();
                            this.emitter.emit('error', error_1);
                            throw error_1;
                        case 4: return [2 /*return*/, this.start()];
                    }
                });
            });
        };
        LogSub.prototype.onNewSubscriptionItem = function (subscriptionItem) {
            // todo log formatter
            var log = subscriptionItem;
            if (log.removed) {
                this.emitter.emit('changed', log);
            }
            return log;
        };
        return LogSub;
    }(SubscriptionMethod));

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    /**
     * ### Description:
     * Subscribes to incoming block headers. This can be used as timer to check for changes on the blockchain.
     */
    var NewHeaders = /** @class */ (function (_super) {
        __extends(NewHeaders, _super);
        function NewHeaders(messenger, shardID) {
            if (shardID === void 0) { shardID = 0; }
            var _this = _super.call(this, 'newHeads', undefined, messenger, shardID) || this;
            _this.start();
            return _this;
        }
        return NewHeaders;
    }(SubscriptionMethod));

    /**
     * @packageDocumentation
     * @module harmony-network
     */
    /**
     * ### Description:
     * Subscribes to incoming pending transactions
     */
    var NewPendingTransactions = /** @class */ (function (_super) {
        __extends(NewPendingTransactions, _super);
        function NewPendingTransactions(messenger, shardID) {
            if (shardID === void 0) { shardID = 0; }
            var _this = _super.call(this, 'newPendingTransactions', undefined, messenger, shardID) || this;
            _this.start();
            return _this;
        }
        return NewPendingTransactions;
    }(SubscriptionMethod));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    var Syncing = /** @class */ (function (_super) {
        __extends(Syncing, _super);
        function Syncing(messenger, shardID) {
            if (shardID === void 0) { shardID = 0; }
            var _this = _super.call(this, 'syncing', undefined, messenger, shardID) || this;
            _this.isSyncing = null;
            _this.start();
            return _this;
        }
        Syncing.prototype.onNewSubscriptionItem = function (subscriptionItem) {
            var isSyncing = subscriptionItem.params.result.syncing;
            if (this.isSyncing === null) {
                this.isSyncing = isSyncing;
                this.emitter.emit('changed', this.isSyncing);
            }
            if (this.isSyncing === true && isSyncing === false) {
                this.isSyncing = isSyncing;
                this.emitter.emit('changed', this.isSyncing);
            }
            if (this.isSyncing === false && isSyncing === true) {
                this.isSyncing = isSyncing;
                this.emitter.emit('changed', this.isSyncing);
            }
            // todo formatter
            return subscriptionItem;
        };
        return Syncing;
    }(SubscriptionMethod));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @hidden
     */
    /**
     * @function getResultForData
     * @description get result for data by default
     * @param  {any} data - object get from provider
     * @return {any} data result or data
     */
    function getResultForData(data) {
        if (data.result) {
            return data.getResult;
        }
        if (data.error) {
            return data.getError;
        }
        return data.getRaw;
    }
    function getRawForData(data) {
        return data.getRaw;
    }
    function onResponse(response) {
        if (response.responseType === 'result') {
            return response.getResult;
        }
        else if (response.responseType === 'error') {
            return response.getError;
        }
        else {
            return response.raw;
        }
    }

    /**
     * @packageDocumentation
     * @module harmony-network
     * @ignore
     */
    (function (MiddlewareType) {
        MiddlewareType[MiddlewareType["REQ"] = 0] = "REQ";
        MiddlewareType[MiddlewareType["RES"] = 1] = "RES";
    })(exports.MiddlewareType || (exports.MiddlewareType = {}));
    (function (SubscribeReturns) {
        SubscribeReturns["all"] = "all";
        SubscribeReturns["id"] = "id";
        SubscribeReturns["method"] = "method";
    })(exports.SubscribeReturns || (exports.SubscribeReturns = {}));

    /**
     * @packageDocumentation
     * @module harmony-network
     * @ignore
     */

    exports.mitt = mitt;
    exports.BaseProvider = BaseProvider;
    exports.BaseSocket = BaseSocket;
    exports.fetchRPC = fetchRPC;
    exports.HttpProvider = HttpProvider;
    exports.WSProvider = WSProvider;
    exports.Emitter = Emitter;
    exports.Provider = Provider;
    exports.Messenger = Messenger;
    exports.ResponseMiddleware = ResponseMiddleware;
    exports.JsonRpc = JsonRpc;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    exports.DEFAULT_HEADERS = DEFAULT_HEADERS;
    exports.performRPC = performRPC;
    exports.composeMiddleware = composeMiddleware;
    exports.BaseBlockTracker = BaseBlockTracker;
    exports.timeout = timeout;
    exports.PollingBlockTracker = PollingBlockTracker;
    exports.SubscribeBlockTracker = SubscribeBlockTracker;
    exports.SubscriptionMethod = SubscriptionMethod;
    exports.LogSub = LogSub;
    exports.NewHeaders = NewHeaders;
    exports.NewPendingTransactions = NewPendingTransactions;
    exports.Syncing = Syncing;
    exports.getResultForData = getResultForData;
    exports.getRawForData = getRawForData;
    exports.onResponse = onResponse;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
