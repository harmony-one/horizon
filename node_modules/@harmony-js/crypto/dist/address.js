"use strict";
/**
 * @packageDocumentation
 * @module harmony-crypto
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddress = exports.HarmonyAddress = void 0;
var utils_1 = require("@harmony-js/utils");
var keyTool_1 = require("./keyTool");
var bech32_1 = require("./bech32");
/**
 * ### How to use it?
 *
 * ```
 * // Step 1: import the class
 * const { HarmonyAddress } = require('@harmony-js/crypto');
 *
 * // Step 2: call functions
 * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
 * const res = HarmonyAddress.isValidBech32(addr);
 * console.log(res);
 * ```
 */
var HarmonyAddress = /** @class */ (function () {
    function HarmonyAddress(raw) {
        this.raw = raw;
        this.basic = this.getBasic(this.raw);
    }
    /**
     * @example
     * ```
     * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
     * const res = HarmonyAddress.isValidBech32(addr);
     * console.log(res);
     * ```
     */
    HarmonyAddress.isValidBasic = function (str) {
        var toTest = new HarmonyAddress(str);
        return toTest.raw === toTest.basic;
    };
    /**
     * @example
     * ```
     * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
     * const res = HarmonyAddress.isValidChecksum(addr);
     * console.log(res);
     * ```
     */
    HarmonyAddress.isValidChecksum = function (str) {
        var toTest = new HarmonyAddress(str);
        return toTest.raw === toTest.checksum;
    };
    /**
     * @example
     * ```
     * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
     * const res = HarmonyAddress.isValidBech32(addr);
     * console.log(res);
     * ```
     */
    HarmonyAddress.isValidBech32 = function (str) {
        var toTest = new HarmonyAddress(str);
        return toTest.raw === toTest.bech32;
    };
    /**
     * @example
     * ```
     * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
     * const res = HarmonyAddress.isValidBech32TestNet(addr);
     * console.log(res);
     * ```
     */
    HarmonyAddress.isValidBech32TestNet = function (str) {
        var toTest = new HarmonyAddress(str);
        return toTest.raw === toTest.bech32TestNet;
    };
    Object.defineProperty(HarmonyAddress.prototype, "basicHex", {
        /**
         * get basicHex of the address
         *
         * @example
         * ```
         * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
         * const instance = new HarmonyAddress(addr);
         * console.log(instance.basicHex);
         * ```
         */
        get: function () {
            return "0x" + this.basic;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HarmonyAddress.prototype, "checksum", {
        /**
         * @example
         * ```
         * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
         * const instance = new HarmonyAddress(addr);
         * console.log(instance.checksum);
         * ```
         */
        get: function () {
            return keyTool_1.toChecksumAddress("0x" + this.basic);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HarmonyAddress.prototype, "bech32", {
        /**
         * @example
         * ```
         * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
         * const instance = new HarmonyAddress(addr);
         * console.log(instance.bech32);
         * ```
         */
        get: function () {
            return bech32_1.toBech32(this.basic, bech32_1.HRP);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HarmonyAddress.prototype, "bech32TestNet", {
        /**
         * @example
         * ```
         * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
         * const instance = new HarmonyAddress(addr);
         * console.log(instance.bech32TestNet);
         * ```
         */
        get: function () {
            return bech32_1.toBech32(this.basic, bech32_1.tHRP);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Check whether the address has an valid address format
     *
     * @param addr string, the address
     *
     * @example
     * ```
     * const addr = 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'
     * const instance = new HarmonyAddress(addr);
     * const res = instance.getBasic(addr);
     * console.log(res)
     * ```
     */
    HarmonyAddress.prototype.getBasic = function (addr) {
        var basicBool = utils_1.isAddress(addr);
        var bech32Bool = utils_1.isBech32Address(addr);
        var bech32TestNetBool = utils_1.isBech32TestNetAddress(addr);
        if (basicBool) {
            return addr.replace('0x', '').toLowerCase();
        }
        if (bech32Bool) {
            var fromB32 = bech32_1.fromBech32(addr, bech32_1.HRP);
            return fromB32.replace('0x', '').toLowerCase();
        }
        if (bech32TestNetBool) {
            var fromB32TestNet = bech32_1.fromBech32(addr, bech32_1.tHRP);
            return fromB32TestNet.replace('0x', '').toLowerCase();
        }
        throw new Error("\"" + addr + "\" is an invalid address format");
    };
    return HarmonyAddress;
}());
exports.HarmonyAddress = HarmonyAddress;
/**
 * Using this function to get Harmony format address
 *
 * @param address
 *
 * @example
 * ```javascript
 * const { Harmony } = require('@harmony-js/core');
 * const { ChainID, ChainType } = require('@harmony-js/utils');
 * const { randomBytes } = require('@harmony-js/crypto')
 *
 * const hmy = new Harmony(
 *   'http://localhost:9500',
 *   {
 *   chainType: ChainType.Harmony,
 *   chainId: ChainID.HmyLocal,
 *   },
 * );
 *
 * const bytes = randomBytes(20);
 * const hAddress = hmy.crypto.getAddress(bytes);
 * console.log(hAddress)
 * ```
 */
function getAddress(address) {
    try {
        return new HarmonyAddress(address);
    }
    catch (error) {
        throw error;
    }
}
exports.getAddress = getAddress;
//# sourceMappingURL=address.js.map